utilizar bepd/builtins
utilizar bepd/x/puerto como Puerto
utilizar bepd/x/puerto/conPosición como PuertoConPos

utilizar tokens como TokensNS

clase Tokens
    metodo estatico desdeTokenizador: tokenizador

    metodo leerToken
    metodo avanzar
    metodo retroceder
    metodo puntoActual
    metodo irAPunto: punto
finclase

atributos Tokens#tokenizador, Tokens#tokens, Tokens#punto

metodo estatico Tokens#desdeTokenizador: tokenizador
    devolver clonar yo#_crear con
        tokenizador: tokenizador
        tokens: Arreglo#vacio
        punto: 0
    finclonar
finmetodo

metodo Tokens#estoyAlFinal
    devolver yo#punto >= yo#tokens#longitud
finmetodo

metodo Tokens#leerToken
    variable encontreEOF
    fijar encontreEOF a FALSO
    mientras (no encontreEOF) && yo#estoyAlFinal
        variable nuevoTk
        fijar nuevoTk a yo#tokenizador#tokenizarSiguiente
        si nuevoTk = Puerto#EOF
            fijar encontreEOF a VERDADERO
        sino
            yo#tokens#agregarAlFinal: nuevoTk
        finsi
    finmientras
    si encontreEOF
        fijar yo#punto a yo#tokens#longitud
        devolver Puerto#EOF
    sino
        variable tk
        fijar tk a yo#tokens#en: yo#punto
        fijar yo#punto a yo#punto + 1
        devolver tk
    finsi
finmetodo

metodo Tokens#avanzar
    yo#leerToken
finmetodo

metodo Tokens#retroceder
    fijar yo#punto a yo#punto - 1
    si yo#punto < 0
        fijar yo#punto a 0
    finsi
finmetodo

metodo Tokens#puntoActual
    devolver yo#punto
finmetodo

metodo Tokens#irAPunto: punto
    fijar yo#punto a punto
finmetodo

funcion AproximarPosiciónActual: tokens
    variables p, tk, inicio
    fijar p a tokens#puntoActual
    tokens#retroceder
    fijar tk a tokens#leerToken
    [ TODO: Hacer que esto no dependa de que `puntoActual` devuelva un número ]
    fijar inicio a tokens#puntoActual > p
    tokens#irAPunto: p
    [ A simple vista, puede parecer redundante `tokens#irAPunto: p`, digo,
      `leerToken` ya avanza el token y dado que habíamos retrocedido, ¿no
      nos debería dejar esto justo donde empezamos? Pero hay que tener en
      cuenta que `retroceder` no hace nada si ya está al principio del
      programa. ]
    si tk = Puerto#EOF
        [ El programa está "vacío" ]
        devolver NULO
    sino
        si inicio
            devolver tk#areaDelToken#posiciónInicial
        sino
            devolver tk#areaDelToken#posiciónFinal
        finsi
    finsi
finfuncion

clase Error
    atributos mensaje, lugar, causa

    metodo inicializar: mensaje, lugar, causa

    metodo estatico conMensaje: mensaje
    metodo estatico conMensajeYLugar: mensaje, lugar
    metodo estatico conMensajeLugarYCausa: mensaje, lugar, causa
    metodo estatico enToken: mensaje, token
    metodo estatico enTokenConCausa: mensaje, token, causa
    metodo estatico conCausa: mensaje, causa

    metodo comoTexto
finclase

metodo estatico Error#conMensaje: mensaje
    devolver yo#crear: mensaje, (PuertoConPos#PosiciónTextual#crear: {<desconocido>}, 1, 0), NULO
finmetodo

metodo estatico Error#conMensajeYLugar: mensaje, lugar
    devolver yo#crear: mensaje, lugar, NULO
finmetodo

metodo estatico Error#conMensajeLugarYCausa: mensaje, lugar, causa
    devolver yo#crear: mensaje, lugar, causa
finmetodo

metodo estatico Error#enToken: mensaje, token
    variable pos
    si token = Puerto#EOF
        fijar pos a PuertoConPos#PosiciónTextual#crear: {<desconocido>}, 1, 0
    sino
        fijar pos a token#areaDelToken#posiciónInicial
    finsi
    devolver yo#crear: mensaje, pos, NULO
finmetodo

metodo estatico Error#enTokenConCausa: mensaje, token, causa
    variable pos
    si token = Puerto#EOF
        fijar pos a PuertoConPos#PosiciónTextual#crear: {<desconocido>}, 1, 0
    sino
        fijar pos a token#areaDelToken#posiciónInicial
    finsi
    devolver yo#crear: mensaje, pos, causa
finmetodo

metodo estatico Error#conCausa: mensaje, causa
    devolver yo#crear: mensaje, causa#lugar, causa
finmetodo

metodo Error#inicializar: mensaje, lugar, causa
    fijar yo#mensaje a mensaje
    fijar yo#lugar a lugar
    fijar yo#causa a causa
finmetodo

metodo Error#comoTexto
    devolver {(Error en ~t: ~t causado por ~t)}#formatear: yo#lugar, yo#mensaje, yo#causa
finmetodo

funcion ComoTextoBonito: tkOEOF
    si tkOEOF = Puerto#EOF
        devolver {el fin del programa}
    sino
        devolver tkOEOF#comoTextoBonito
    finsi
finfuncion

clase Combinador
    metodo parsear: tokens
finclase

clase CombToken hereda Combinador
    atributos predicado, generarMensajeDeError
    metodo parsear: tokens
finclase

metodo CombToken#parsear: tokens
    variables posAct, tk
    fijar posAct a tokens#puntoActual
    fijar tk a tokens#leerToken
    si no yo#predicado#\llamar\: tk
        variable pos
        si tk = Puerto#EOF
            fijar pos a AproximarPosiciónActual: tokens
        sino
            fijar pos a tk#areaDelToken#posiciónInicial
        finsi
        devolver Resultado#error: (yo#generarMensajeDeError#\llamar\: tk, pos)
    finsi
    devolver Resultado#ok: tk
finmetodo

funcion Token: predicado, generarMensajeDeError
    variable comb
    fijar comb a CombToken#_crear
    fijar comb#predicado a predicado
    fijar comb#generarMensajeDeError a generarMensajeDeError
    devolver comb
finfuncion

funcion PalabraClave: pal
    funcion pred: tk
        si no EsInstancia: tk, TokensNS#TokenPalabraClave
            devolver FALSO
        sino
            devolver tk#palabraClave = pal
        finsi
    finfuncion
    funcion genMensjError: tk, pos
        devolver Error#conMensajeYLugar: ({Se esperaba la palabra clave [~t] pero se obtuvo ~t}#formatear: pal, (ComoTextoBonito: tk)), pos
    finfuncion
    devolver Token: &pred, &genMensjError
finfuncion

funcion Identificador
    funcion pred: tk
        devolver EsInstancia: tk, TokensNS#TokenIdentificador
    finfuncion
    funcion genMensjError: tk, pos
        devolver Error#conMensajeYLugar: ({Se esperaba un identificador pero se obtuvo ~t}#formatear: (ComoTextoBonito: tk)), pos
    finfuncion
    devolver Token: &pred, &genMensjError
finfuncion

funcion NumeroLiteral
    funcion pred: tk
        devolver EsInstancia: tk, TokensNS#TokenNumero
    finfuncion
    funcion genMensjError: tk, pos
        devolver Error#conMensajeYLugar: ({Se esperaba un número pero se obtuvo ~t}#formatear: (ComoTextoBonito: tk)), pos
    finfuncion
    devolver Token: &pred, &genMensjError
finfuncion

funcion Operador
    funcion pred: tk
        devolver EsInstancia: tk, TokensNS#TokenOperador
    finfuncion
    funcion genMensjError: tk, pos
        devolver Error#conMensajeYLugar: ({Se esperaba un operador pero se obtuvo ~t}#formatear: (ComoTextoBonito: tk)), pos
    finfuncion
    devolver Token: &pred, &genMensjError
finfuncion

funcion TextoLiteral
    funcion pred: tk
        devolver EsInstancia: tk, TokensNS#TokenTexto
    finfuncion
    funcion genMensjError: tk, pos
        devolver Error#conMensajeYLugar: ({Se esperaba un texto literal pero se obtuvo ~t}#formatear: (ComoTextoBonito: tk)), pos
    finfuncion
    devolver Token: &pred, &genMensjError
finfuncion

clase CombComponer hereda Combinador
    atributo combinadores
    metodo parsear: tokens
finclase

metodo CombComponer#parsear: tokens
    variable res
    fijar res a Resultado#ok: Arreglo#vacio
    ParaCadaElemento: yo#combinadores, procedimiento: comb
        si res#esError devolver NULO finsi
        variable r
        fijar r a comb#parsear: tokens
        si r#esError
            fijar res#error a r#error
        sino
            res#valor#agregarAlFinal: r#valor
        finsi
    finprocedimiento
    devolver res
finmetodo

funcion Componer: combs
    variable comb
    fijar comb a CombComponer#_crear
    fijar comb#combinadores a combs
    devolver comb
finfuncion

clase CombElegir hereda Combinador
    atributo combinadores
    metodo parsear: tokens
finclase

metodo CombElegir#mensajeDeError: tokens
    variables p, tk, pos
    fijar p a tokens#puntoActual
    fijar tk a tokens#leerToken
    tokens#irAPunto: p
    si tk = Puerto#EOF
        fijar pos a AproximarPosiciónActual: tokens
    sino
        fijar pos a tk#areaDelToken#posiciónInicial
    finsi
    devolver Error#conMensajeYLugar: ({No se esperaba ~t}#formatear: (ComoTextoBonito: tk)), pos
finmetodo

metodo CombElegir#parsear: tokens
    variables posIni, res, encajoCombinador
    fijar posIni a tokens#puntoActual
    fijar res a Resultado#error: (yo#mensajeDeError: tokens)
    fijar encajoCombinador a FALSO
    ParaCadaElemento: yo#combinadores, procedimiento: comb
        si encajoCombinador devolver NULO finsi
        variables posFinal, r
        fijar r a comb#parsear: tokens
        fijar posFinal a tokens#puntoActual
        si r#esError && (posIni = posFinal)
            [ Backtracking solo es utilizado si el combinador no consumio tokens ]
            tokens#irAPunto: posIni
        sino
            fijar res a r
            fijar encajoCombinador a VERDADERO
        finsi
    finprocedimiento
    devolver res
finmetodo

funcion Elegir: combs
    variable comb
    fijar comb a CombElegir#_crear
    fijar comb#combinadores a combs
    devolver comb
finfuncion

clase CombEfecto hereda Combinador
    atributo efecto, combinador
    metodo parsear: tokens
finclase

metodo CombEfecto#parsear: tokens
    variable res
    fijar res a yo#combinador#parsear: tokens
    si res#esOk
        devolver Resultado#ok: (yo#efecto#\llamar\: res#valor)
    sino
        devolver res
    finsi
finmetodo

funcion Efecto: efecto, combinador
    variable comb
    fijar comb a CombEfecto#_crear
    fijar comb#efecto a efecto
    fijar comb#combinador a combinador
    devolver comb
finfuncion

clase CombIntentar hereda Combinador
    atributo combinador
    metodo parsear: tokens
finclase

metodo CombIntentar#parsear: tokens
    variables posIni, res
    fijar posIni a tokens#puntoActual
    fijar res a yo#combinador#parsear: tokens
    si res#esError
        tokens#irAPunto: posIni
    finsi
    devolver res
finmetodo

funcion Intentar: comb
    variable inst
    fijar inst a CombIntentar#_crear
    fijar inst#combinador a comb
    devolver inst
finfuncion

clase CombMensajeDeError hereda Combinador
    atributos mensaje, combinador
    metodo parsear: tokens
finclase

metodo CombMensajeDeError#parsear: tokens
    variables res, optTk, pos
    fijar pos a tokens#puntoActual
    fijar optTk a tokens#leerToken
    tokens#irAPunto: pos
    fijar res a yo#combinador#parsear: tokens
    si res#esError
        si optTk = Puerto#EOF
            devolver Resultado#error: (Error#conCausa: yo#mensaje, res#error)
        sino
            devolver Resultado#error: (Error#enTokenConCausa: yo#mensaje, optTk, res#error)
        finsi
    sino
        devolver res
    finsi
finmetodo

funcion MensajeDeError: mensaje, combinador
    variable comb
    fijar comb a CombMensajeDeError#_crear
    fijar comb#mensaje a mensaje
    fijar comb#combinador a combinador
    devolver comb
finfuncion

clase CombRecursivo hereda Combinador
    atributo obtenerCombinador
    metodo parsear: tokens
finclase

metodo CombRecursivo#parsear: tokens
    devolver yo#obtenerCombinador#\llamar\#parsear: tokens
finmetodo

funcion Recursivo: obtenerCombinador
    variable comb
    fijar comb a CombRecursivo#_crear
    fijar comb#obtenerCombinador a obtenerCombinador
    devolver comb
finfuncion

clase CombRepetir hereda Combinador
    atributo combinador
    metodo parsear: tokens
finclase

metodo CombRepetir#parsear: tokens
    variable resultados
    fijar resultados a Arreglo#vacio
    mientras VERDADERO
        variables rescomb, posIni, posFinal
        fijar posIni a tokens#puntoActual
        fijar rescomb a yo#combinador#parsear: tokens
        fijar posFinal a tokens#puntoActual
        si rescomb#esOk
            resultados#agregarAlFinal: rescomb#valor
        sino
            si posIni = posFinal
                devolver Resultado#ok: resultados
            sino
                devolver rescomb
            finsi
        finsi
    finmientras
finmetodo

funcion Repetir: combinador
    variable comb
    fijar comb a CombRepetir#_crear
    fijar comb#combinador a combinador
    devolver comb
finfuncion

clase CombNoSigue hereda Combinador
    atributo combinador
    metodo parsear: tokens
finclase

metodo CombNoSigue#parsear: tokens
    variables posIni, res
    fijar posIni a tokens#puntoActual
    fijar res a yo#combinador#parsear: tokens
    si res#esError
        devolver Resultado#ok: NULO
    sino
        variable tk
        tokens#irAPunto: posIni
        fijar tk a tokens#leerToken
        devolver Resultado#error: (Error#enToken: ({El combinador de NoSigue la logrado parsear en ~t}#formatear: tk#areaDelToken), tk)
    finsi
finmetodo

funcion NoSigue: combinador
    variable comb
    fijar comb a CombNoSigue#_crear
    fijar comb#combinador a combinador
    devolver comb
finfuncion

clase CombSigue hereda Combinador
    atributo combinador
    metodo parsear: tokens
finclase

metodo CombSigue#parsear: tokens
    variables posIni, res
    fijar posIni a tokens#puntoActual
    fijar res a yo#combinador#parsear: tokens
    si res#esOk
        tokens#irAPunto: posIni
    finsi
    devolver res
finmetodo

funcion Sigue: combinador
    variable comb
    fijar comb a CombSigue#_crear
    fijar comb#combinador a combinador
    devolver comb
finfuncion

clase CombHasta hereda Combinador
    atributos final, principal
    metodo parsear: tokens
finclase

metodo CombHasta#parsear: tokens
    variables resultados, terminó
    fijar resultados a Arreglo#vacio
    fijar terminó a FALSO
    mientras no terminó
        variables posIni, posFinal, resFinal, resPrincipal
        fijar posIni a tokens#puntoActual
        fijar resFinal a yo#final#parsear: tokens
        fijar posFinal a tokens#puntoActual
        si resFinal#esOk
            fijar terminó a VERDADERO
        sino
            si no (posIni = posFinal)
                devolver resFinal
            finsi
            tokens#irAPunto: posIni
            fijar resPrincipal a yo#principal#parsear: tokens
            si resPrincipal#esOk
                resultados#agregarAlFinal: resPrincipal#valor
            sino
                devolver resPrincipal
            finsi
        finsi
    finmientras
    devolver Resultado#ok: resultados
finmetodo

funcion Hasta: terminar, comb
    variable inst
    fijar inst a CombHasta#_crear
    fijar inst#final a terminar
    fijar inst#principal a comb
    devolver inst
finfuncion
