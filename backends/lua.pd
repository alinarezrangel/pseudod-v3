utilizar bepd/builtins
utilizar bepd/utilidades/texto
utilizar bepd/x/sistemaDeArchivos/archivo como Archivos

utilizar ast como AST
utilizar caminaNodos como CN

utilizar resoluciónDeNombres como RN

utilizar módulos como Módulos

utilizar compilador como Compilador

utilizar backends/lua/emisor como Em

[ El backend de Lua está separado en dos partes. Espero, con el tiempo,
  "limpiar" mucho de este código (recuerda que el patrón del visitante ("Visitor
  Pattern") es realmente una manera de hacer "pattern matching" en lenguajes que
  no lo soportan).

  De cualquier forma, las dos partes son:

  - La clase `CompiladosSimpleALua` (hereda `CaminaNodos`): Va por cada nodo
    del AST y lo compila a Lua.
  - La clase `CompiladorALua` (hereda `CompiladorBase`): Compila ASTs, archivos
    y textos. "Orquestra" las operaciones de `CompiladorSimpleALua`.

  Para facilitar las cosas, `CompiladorSimpleALua` tiene un atributo
  `_compilador` que apunta al `CompiladorALua` que lo maneja. ]

[ Nombre código del backend. Véase también la variable del mismo nombre en
  `backends/lua/runtime.lua` y la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Lua Bootstrap}

[DOCUMENTA
@brief{Escapa un texto a Lua válido.}

@pd{texto} es una instancia de @pd{Texto}. Escapa todos los carácteres
especiales de @pd{texto} y lo envuelve en comillas, de forma que el texto
devuelto es una literal textual (string) válida para Lua.
DOCUMENTA]
funcion EscaparParaLua: texto
    si __Impl = {Lua Bootstrap}
        devolver __Lua: {function(texto)
return string.gsub(texto, "[\"\n\\]", "\\%1")
end}, texto
    [ " ]
    sino
        variable res
        fijar res a {"} [ " ]
        ParaCadaElemento: texto, procedimiento: car
            si car = {"} [ " ]
                fijar res a res#concatenar: {\"} [ " ]
            sino
                si car = {~%}#formatear
                    fijar res a res#concatenar: {\n}
                sino
                    si car = {\}
                        fijar res a res#concatenar: {\\}
                    sino
                        fijar res a res#concatenar: car
                    finsi
                finsi
            finsi
        finprocedimiento
        devolver res#concatenar: {"} [ " ]
    finsi
finfuncion

[ Por limitaciones de Lua, no se pueden tener más de 200 variables locales en
  cualquier ámbito de Lua. Lamentablemente son necesarias más de 200 variables
  locales para compilar PseudoD. La solución que utilicé es que en vez de crear
  variables locales, creo una sola llamada "_s" que es un "scope" (runtime.lua
  contiene la implementación en la función "M.scope"). Cada variable de PseudoD
  es un campo de la forma "_" + binding en la tabla "_s". Por ejemplo, la
  variable con el binding 5 está en "_s._5".

  Esto sería perfecto si no fuese por el hecho de que este sistema tiene una
  eficiencia abismalmente mala. Por eso, un segundo truco es realizado: si un
  ámbito y todos sus subámbitos tienen menos de 200 bindings el "scope hack"
  con `_s` no es necesario y variables locales de Lua son usadas. ]

[ Técnicamente hablando esta constante depende de como se compiló lua, pero 200
  es el predeterminado de Lua y creo que es aceptable que también sea el
  predeterminado aquí. ]
variable LUA_MAX_LOCALS
fijar LUA_MAX_LOCALS a 200

[ Todo el "compilado" se contruye incrementalmente de "partes de código", véase
  la documentación de `backends/lua/emisor` para la definición de una parte de
  código. ]

[DOCUMENTA
@brief{Devuelve el nombre en Lua de un binding.}

Automaticamente detecta si el ámbito

@pd{ámbito} es el ámbito en el que se está accediendo el
binding. Automaticamente utiliza variables locales de Lua o el objeto @code{_s}
dependiendo del número de bindings del ámbito que declaró @pd{binding}.

@devuelve{Una parte de código.}
DOCUMENTA]
funcion NombreEnLua: binding, ámbito
    variable ámbitoDefinído
    fijar ámbitoDefinído a ámbito#ámbitoDondeSeDefine: binding
    si ámbitoDefinído#númeroDeBindings < LUA_MAX_LOCALS
        devolver Em#Parte#sinAreaTextual: ({_~t}#formatear: binding)
    sino
        devolver Em#Parte#sinAreaTextual: ({_s._~t}#formatear: binding)
    finsi
finfuncion

[DOCUMENTA
@brief{Devuelve una instrucción en Lua que define un binding.}

Equivalente a @pd{DefineNombreEnLuaDesde} con @pd{luaExpr} igual a @pd{"nil"}.

Véase @pd{DefineNombreEnLuaDesde} para más información.
DOCUMENTA]
funcion DefineNombreEnLua: binding, ámbito
    devolver DefineNombreEnLuaDesde: binding, ámbito, {nil}
finfuncion

[DOCUMENTA
@brief{Devuelve una instrucción en Lua que define un binding.}

La parte de código devuelta contiene una o más instrucciones en Lua (separadas
por puntos y comas, más no incluyen un punto-y-coma final). Las instrucciones
devueltas declaran el binding: si el ámbito utiliza un objeto @code{_s},
entonces define el binding con @pd{rt.scopenewname}. Si, por el contrario, el
ámbito no utiliza @code{_s}, entonces las instrucciones devueltas declaran la
variable con @code{local}.

@pd{luaExpr} es una parte de código que será el valor inicial de la variable
(debe ser una expresión en Lua).
DOCUMENTA]
funcion DefineNombreEnLuaDesde: binding, ámbito, luaExpr
    variable ámbitoDefinído
    fijar ámbitoDefinído a ámbito#ámbitoDondeSeDefine: binding
    si ámbitoDefinído#númeroDeBindings < LUA_MAX_LOCALS
        devolver Em#Formatear: NULO, {local _~t = (~p)}, binding, luaExpr
    sino
        devolver Em#Formatear: NULO, {rt.scopenewname(_s, ~t); _s._~t = (~p)},
            (EscaparParaLua: ({_~t}#formatear: binding)),
            binding,
            luaExpr
    finsi
finfuncion

[ Tal como en resoluciónDeNombres.pd, una subclase de CN#CaminaNodos es
  utilizada para compilar el código. La clase "CompiladorSimpleALua" es solo un
  detalle de implementación y nunca se debería usar fuera de este módulo.

  Los métodos "visitarXYZ" siempre devuelven el código Lua compilado como una
  parte de código. De forma que "caminante#visitar: ast" devuelve una parte con
  todo el programa en Lua asumiendo que "ast" es un NodoPrograma y "caminante"
  una instancia de CompiladorSimpleALua.

  El compilado devuelto solo incluye al módulo. En la práctica estos compilados
  no son ejecutados directamente sino que son envueltos en funciones de lua
  para que queden de la forma "function() ...COMPILADO... end" y estas
  funciones son registradas con el runtime para que "utilizar" pueda resolver
  los nombres. Más abajo hay un comentario que explica todos los conceptos del
  runtime. También míra el método "compilarTodo". ]

clase CompiladorSimpleALua hereda CN#CaminaNodos
    metodo crearSubámbitoDesdeNodo: nodo
    metodo crearSubámbitoDesdeNombreEnNodo: nodo, llave

    metodo inicializar: moddb, ámbito, compilador

    metodo iniciar
    metodo registrarBuiltins

    metodo esBuiltin: nombre, binding
finclase

atributos CompiladorSimpleALua#_ámbito, [ Ámbito actual ]
          CompiladorSimpleALua#_moddb, [ Base de datos de módulos ]
          CompiladorSimpleALua#_compilador [ `CompiladorALua` que esta compilando ]

[DOCUMENTA
@brief{Crea un @pd{CompiladorSimpleALua} que es un subámbito del actual.}

Representa el ámbito de @pd{nodo}. Es un subámbito del actual.
DOCUMENTA]
metodo CompiladorSimpleALua#crearSubámbitoDesdeNodo: nodo
    devolver yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídos}
finmetodo

[DOCUMENTA
@brief{Crea un subámbito desde un nodo.}

@pd{nodo} es el nodo cuyo ámbito será usado. @pd{llave} es el nombre del
metadato que será leído. Este parámetro es configurable ya que los
condicionales "si" tienen dos llaves "nombresDefinídosSiVerdadero" y
"nombresDefinídosSiFalso" en vez de "nombresDefinídos" (que es el común).

Devuelve el subámbito (otra instancia de @pd{CompiladorSimpleALua}).
DOCUMENTA]
metodo CompiladorSimpleALua#crearSubámbitoDesdeNombreEnNodo: nodo, llave
    devolver CompiladorSimpleALua#crear:
                 yo#_moddb,
                 (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, llave),
                 yo#_compilador
finmetodo

metodo CompiladorSimpleALua#inicializar: moddb, ámbito, compilador
    fijar yo#_ámbito a ámbito
    fijar yo#_moddb a moddb
    fijar yo#_compilador a compilador
finmetodo

[

El Runtime y la estructura del compilador:

- En tiempo de ejecución, los números, textos, funciones, booles y el valor
  nulo tienen la representación en Lua que esperarías: números pasan a ser
  "number" (Lua 5.4 garantiza números tanto enteros como reales, tal como
  PseudoD). Booles pasan a ser "true" y "false". Nulo pasa a ser
  "nil". Funciones y procedimientos pasan a ser "functions".

- Como ya fue explicado antes, las variables locales pasan a ser campos en una
  tabla "_s" (más o menos, lee el comentario sobre los ámbitos).

- Enviar un mensaje a un objeto se realiza con la operación
  "rt.enviarMensaje". Esta automaticamente detecta el tipo del receptor y
  implementa algunos métodos sobre funciones, textos, etc. Enviar un mensaje
  donde el número de argumentos no se conoce sino hasta el tiempo de ejecución
  (por ejemplo, en "Sumar: 1, 2, ...x, ...y") se realiza con
  "rt.enviarMensajeV".

- Los espacios de nombres son implementados con "rt.ns". Al final de cada
  módulo, "rt.ns" es llamado con todos los nombres definídos (y algunos datos
  más) y este devuelve el espacio de nombres.

- Los arreglos son creados con "rt.arreglo", "rt.mkarreglo" y demás.

- Llamar a "rt.enviarMensaje" con los parámetros apropiados y escapando todo no
  es trivial, así que el método "enviarMensaje: objeto, mensaje, argumentos" se
  encarga de esto. Este automáticamente compila "argumentos" (que debe ser una
  lista de nodos de expresión), se encarga de los nodos variadic opcionales en
  "argumentos", llama automaticamente a "rt.enviarMensaje" o
  "rt.enviarMensajeV" y escapa el mensaje a enviar. "objeto" es el objeto al
  que se le enviará un mensaje. Nota que aunque los "argumentos" sean visitados
  (es decir, compilados), "objeto" no lo es, ese parámetro ya debe ser un texto
  que represente una expresión de Lua válida. ("enviarMensaje" está
  documentado, así que puedes ver su documentación para más información.)

- El código generado siempre tiene puntos-y-comas separando las instrucciones.

- Un patrón muy común es el de crear un arreglo de texto llamado "cods" (para
  "códigos") o "instrs" (para "instrucciones") e irlo llenando de partes de
  código para finalmente devolver "Em#Parte#crear: cods, nodo" o
  "Em#Unir: nodo, cods, {;}".

- Al compilar un NodoPrograma, el espacio de nombres es devuelto (con "return")
  desde el chunk de lua. "CompiladorALua#compilarTodo" contiene la
  implementación pero en realidad luego de compilar todos los módulos, sus
  compilados son envueltos en otras funciones de forma que cada módulo termina
  de la forma:

      rt.modulos.("./ruta/completa/al/módulo.pd") = function()
         ...TODO EL COMPILADO...
      end

   (reemplaza ".(XYZ)" por corchetes, recuerda que no se pueden poner corchetes
   en comentarios en PseudoD).

   De esta forma, el espacio de nombres devuelto por el compilado de un
   NodoPrograma termina siendo el "return" de la función asignada a la tabla
   "rt.modulos". Esto es debido a que este backend no compila cada módulo a un
   archivo de Lua distínto, sino que los compila todos a un único archivo
   enorme. Para esto "runtime.lua" también incluye una implementación sencilla
   de un sistema de módulos similar al de lua, solo que en vez de tener los
   módulos en archivos son funciones en "rt.modulos" y en vez de usar "require"
   usas "rt.importar" (o "rt.import", son aliases).

Creo que todo esto es lo necesario para entender este backend. A parte de esto,
no es muy complicado, más que todo un monton de llamadas a "Em#Formatear" para
concatenar las partes del código.

]

[ Los siguientes métodos son de utilidad: Permiten no especificar el parámetro
  "ámbito" de las respectivas funciones. ]
metodo CompiladorSimpleALua#nombreEnLua: binding
    si EsInstancia: binding, AST#NodoIdentificador
        fijar binding a RN#NombreResueltoDe: binding
    finsi
    devolver NombreEnLua: binding, yo#_ámbito
finmetodo

metodo CompiladorSimpleALua#defineNombreEnLua: binding
    devolver DefineNombreEnLua: binding, yo#_ámbito
finmetodo

metodo CompiladorSimpleALua#defineNombreEnLuaDesde: binding, luaExpr
    devolver DefineNombreEnLuaDesde: binding, yo#_ámbito, luaExpr
finmetodo

[ Este método es llamado al inicio de cada ámbito. Inicializa variables
  importantes del runtime (como "_s"). ]
metodo CompiladorSimpleALua#iniciar
    variables res, padre
    fijar res a Arreglo#vacio
    si no EsNulo: yo#_ámbito#ámbitoPadre
        fijar padre a {_s}
    sino
        fijar padre a {}
    finsi
    res#agregarAlFinal: ({local _s = rt.scope(~t);~%}#formatear: padre)
    ParaCadaElemento: yo#_ámbito#todosLosBindingsLocales, procedimiento: id
        res#agregarAlFinal: (yo#defineNombreEnLua: id)
        res#agregarAlFinal: {;~%}#formatear
    finprocedimiento
    devolver res
finmetodo

[ Devuelve una parte de código que registra todos los builtins en su respectivo
  ámbito. ]
metodo CompiladorSimpleALua#registrarBuiltins
    variable cods
    fijar cods a Arreglo#vacio
    yo#_compilador#_builtins#paraCadaPar: procedimiento: nombreEnRT, binding
        cods#agregarAlFinal: (Em#Formatear: NULO, {~p = rt.builtins[~t];~%}, (yo#nombreEnLua: binding), (EscaparParaLua: nombreEnRT))
    finprocedimiento
    devolver cods
finmetodo

metodo CompiladorSimpleALua#esBuiltin: nombre, binding
    devolver (yo#_compilador#_builtins#en: nombre) = binding
finmetodo

metodo CompiladorSimpleALua#visitarPrograma: nodo
    variables instrs, ámbito
    fijar instrs a Arreglo#crearCon:
        (yo#compilarInstrucciones: nodo#instrucciones)
    fijar ámbito a RN#ObtenerNombresDefinídos: nodo
    instrs#agregarAlFinal: {return rt.ns({}#formatear
    ámbito#paraCadaVariable: procedimiento: nombre, dv
        instrs#agregarAlFinal: (Em#Formatear: nodo, {  [~t] = { value = ~p, autoexecutable = ~t ~e,~%},
            (EscaparParaLua: nombre),
            (yo#nombreEnLua: dv#binding),
            (dv#esAutoejecutable#escojer: {true}, {false}))
    finprocedimiento
    instrs#agregarAlFinal: {~e);~%}#formatear
    devolver Em#Parte#crear: instrs, nodo
finmetodo

metodo CompiladorSimpleALua#visitarVariable: nodo
    devolver {}
finmetodo

metodo CompiladorSimpleALua#visitarFijar: nodo
    si EsInstancia: nodo#objetivo, AST#NodoIdentificador
        variables obj, expr
        fijar obj a yo#nombreEnLua: nodo#objetivo
        fijar expr a yo#visitar: nodo#valor
        devolver Em#Formatear: nodo, {~p = (~p);~%}, obj, expr
    sino
        necesitas EsInstancia: nodo#objetivo, AST#NodoEnviarMensaje
        necesitas nodo#objetivo#argumentos#longitud = 0
        variable base, fieldname
        fijar base a yo#visitar: nodo#objetivo#objeto
        fijar fieldname a {fijar_}#concatenar: nodo#objetivo#mensaje
        devolver Em#Formatear: nodo, {~p;~%}, (yo#enviarMensaje: base, fieldname, (Arreglo#crearCon: nodo#valor))
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarEscribir: nodo
    devolver Em#Formatear: nodo, {rt.escribir(~p);~%}, (yo#visitar: nodo#valor)
finmetodo

metodo CompiladorSimpleALua#visitarNl: nodo
    devolver Em#Formatear: nodo, {rt.nl();~%}
finmetodo

metodo CompiladorSimpleALua#visitarClase: nodo
    variables cods, clssym, base, nodoClaseBaseSrc
    fijar clssym a yo#nombreEnLua: nodo#nombre
    fijar cods a Arreglo#vacio
    si no EsNulo: nodo#claseBase
        fijar base a yo#visitar: nodo#claseBase
        fijar nodoClaseBaseSrc a nodo#claseBase
    sino
        fijar base a {rt.clases.Objeto}
        fijar nodoClaseBaseSrc a nodo
    finsi
    cods#agregarAlFinal: (Em#Formatear:
        nodo,
        {~p = (~p);~%},
        clssym,
        (yo#enviarMensaje:
            (Em#Formatear: nodoClaseBaseSrc, {(~p)}, base),
            {subclase},
            Arreglo#vacio))
    cods#agregarAlFinal: (Em#Formatear:
        nodo#nombre,
        {rt.enviarMensaje(~p, "fijar_nombre", ~t);~%},
        clssym,
        (EscaparParaLua: nodo#nombre#nombre))
    ParaCadaElemento: nodo#declaraciones, procedimiento: declr
        si EsInstancia: declr, AST#NodoDeclaraciónDeAtributosEnClase
            cods#agregarAlFinal: (Em#Formatear: declr, {~p;~%}, (yo#visitar: (clonar AST#NodoAtributos#crear con
                areaTextual: declr#areaTextual
                deClase: nodo#nombre
                nombres: declr#nombres
            finclonar)))
        sino
            [ Nada que hacer para los NodoDeclaraciónDeMétodoEnClase ]
        finsi
    finprocedimiento
    devolver Em#Parte#crear: cods, nodo
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeAtributosEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeMétodoEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarImplementa: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineAtributosEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineMétodoEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#expresiónDeFunción: nombreResueltoDeYo, parámetros, cuerpo
    variables cods, params, variadic, met, paramsbody
    fijar cods a Arreglo#vacio
    fijar variadic a NULO

    [ Debido a que a veces las variables están en un objeto `_s`, no podemos
      simplemente pasar todos los parámetros de la función por Lua (no es
      posible escribir algo como `function(_s._1, _s._2)`). La solución que
      implementa este método es crear nombres falsos para los parámetros (en
      vez de `_s._1` o `_1` usan `_p1`) y luego los asignan a las variables
      locales. Por ejemplo, una función con dos parámetros podría compilarse a:

      function(_p1, _p2)
         local _1, _2
         _1 = _p1
         _2 = _p2
         ...
      end

      Los parámetros de la función en lua están en `params`, mientras que el
      código que los asigna a variables en `_s` o variables locales está en
      `paramsbody`. ]

    funcion CódigoDeParam: param
        si EsInstancia: param, AST#NodoIdentificador
            devolver {_p~t}#formatear: (RN#NombreResueltoDe: param)
        sino
            fijar variadic a param
            devolver {...}
        finsi
    finfuncion

    fijar params a Unir: (Mapear: parámetros, &CódigoDeParam), {, }

    si no EsNulo: nombreResueltoDeYo
        fijar met a Em#Formatear: NULO, {_p~t}, nombreResueltoDeYo
        si parámetros#longitud > 0
            fijar params a {, }#concatenar: params
        finsi
    sino
        fijar met a {}
    finsi

    funcion CódigoDeParamBody: param
        si EsInstancia: param, AST#NodoIdentificador
            devolver Em#Formatear: param, {~p = _p~t;~%}, (yo#nombreEnLua: (RN#NombreResueltoDe: param)), (RN#NombreResueltoDe: param)
        sino
            [ Los parámetros variadic son manejados más abajo. ]
            devolver {}
        finsi
    finfuncion

    fijar paramsbody a Em#Unir: NULO, (Mapear: parámetros, &CódigoDeParamBody), {;~%}#formatear

    si no EsNulo: nombreResueltoDeYo
        fijar paramsbody a Em#Formatear:
            NULO,
            {~p;~%~p;~%},
            paramsbody,
            (yo#defineNombreEnLuaDesde:
                nombreResueltoDeYo,
                (Em#Formatear: NULO, {_p~t}, nombreResueltoDeYo))
    finsi

    cods#agregarAlFinal: (Em#Formatear: NULO, {function(~p~p)~%}, met, params)
    cods#agregarAlFinal: yo#iniciar
    cods#agregarAlFinal: paramsbody
    cods#agregarAlFinal: {;~%}#formatear
    si no EsNulo: variadic
        [ Los parámetros variadic no son declarados al principio de las
          funciones/métodos/procedimientos. Por esto debemos declarar este
          manualmente. ]
        cods#agregarAlFinal: (Em#Formatear: NULO, {~p = rt.arreglo(...);~%}, (yo#nombreEnLua: variadic#interno))
    finsi

    cods#agregarAlFinal: (yo#compilarInstrucciones: cuerpo)
    cods#agregarAlFinal: {end~%}#formatear

    devolver cods
finmetodo

metodo CompiladorSimpleALua#visitarFunción: nodo
    variables cods, id, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídos}
    fijar id a yo#nombreEnLua: nodo#nombre
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: (Em#Formatear: nodo,
        {~p = (~p);~%},
        id,
        (subyo#expresiónDeFunción: NULO, nodo#parámetros, nodo#cuerpo)
    )
    devolver Em#Parte#crear: cods, nodo
finmetodo

metodo CompiladorSimpleALua#visitarNecesitas: nodo
    devolver Em#Formatear: nodo, {assert(~p);~%}, (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarDevolver: nodo
    devolver Em#Formatear: nodo, {do return ~p; end;}, (yo#visitar: nodo#expresión)
finmetodo

clase ComparaciónDeBuiltin
    atributos tipoIgualdad, rhs
finclase

[DOCUMENTA
@brief{Trata de separar una comparación de un builtin con una literal en sus
partes.}

@pd{nodo} es un @pd{AST#NodoExpresion}. @pd{rnBuiltin} debe ser el binding del
builtin que se quiere saber si compara.

Si nodo corresponde al AST generado para expresiones de la forma
@pd{BUILTIN = LIT}, @pd{son iguales BUILTIN y LIT} o
@pd{son diferentes BUILTIN y LIT}, donde @pd{BUILTIN} es el builtin
identificado por @pd{rnBuiltin} y @pd{LIT} es cualquier literal textual o
numérica. devuelve una instancia de @pd{ComparaciónDeBuiltin} donde
@pd{tipoIgualdad} es uno de los valores de la enumeración @pd{AST#TipoIgualdad}
y @pd{rhs} es el valor de la literal (un @pd{Texto} si era una literal textual
o un @pd{Numero} si era una literal numérica).

Si @pd{nodo} no tiene ninguno de esos patrones, devuelve @pd{FALSO}.
DOCUMENTA]
funcion SepararComparaciónDeBuiltin: nodo, rnBuiltin
    variables lhs, rhs, op
    si EsInstancia: nodo, AST#NodoOperador
        fijar lhs a nodo#lhs
        fijar rhs a nodo#rhs
        si nodo#op#texto = {=}
            fijar op a AST#TipoIgualdad#IGUALES
        sino
            devolver FALSO
        finsi
    sino
        si EsInstancia: nodo, AST#NodoSonIguales
            fijar lhs a nodo#lhs
            fijar rhs a nodo#rhs
            si nodo#tipoIgualdad = AST#TipoIgualdad#IGUALES
                fijar op a AST#TipoIgualdad#IGUALES
            sino
                fijar op a AST#TipoIgualdad#DIFERENTES
            finsi
        sino
            devolver FALSO
        finsi
    finsi
    si no (EsInstancia: lhs, AST#NodoIdentificador)
        devolver FALSO
    finsi
    si no (RN#NombreResueltoDe: lhs) = rnBuiltin
        devolver FALSO
    finsi
    variable valorRhs
    si EsInstancia: rhs, AST#NodoTextoLiteral
        fijar valorRhs a rhs#valor
    sino
        si EsInstancia: rhs, AST#NodoNumeroLiteral
            fijar valorRhs a rhs#valor
        sino
            devolver FALSO
        finsi
    finsi
    devolver clonar ComparaciónDeBuiltin#crear con
        tipoIgualdad: op
        rhs: valorRhs
    finclonar
finfuncion

metodo CompiladorSimpleALua#visitarSi: nodo
    variables cods, subSiVerdadero, subSiFalso

    fijar cods a Arreglo#vacio
    fijar subSiVerdadero a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiVerdadero}
    fijar subSiFalso a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiFalso}

    procedimiento CompilarBloque: nodos, sub
        cods#agregarAlFinal: sub#iniciar
        cods#agregarAlFinal: (sub#compilarInstrucciones: nodos)
    finprocedimiento

    [ Si se compara directamente __Impl con una literal de texto igual a
      PSEUDOD_IMPL, entonces compila únicamente la rama que sabemos que
      pasará. ]
    variable cmp
    fijar cmp a SepararComparaciónDeBuiltin: nodo#condicional, (yo#_compilador#_builtins#en: {__Impl})
    si EsInstancia: cmp, ComparaciónDeBuiltin
        cods#agregarAlFinal: {;do;~%}#formatear
        si cmp#tipoIgualdad = AST#TipoIgualdad#IGUALES
            si cmp#rhs = PSEUDOD_IMPL
                CompilarBloque: nodo#siVerdadero, subSiVerdadero
            sino
                CompilarBloque: nodo#siFalso, subSiFalso
            finsi
        sino
            si cmp#rhs = PSEUDOD_IMPL
                CompilarBloque: nodo#siFalso, subSiFalso
            sino
                CompilarBloque: nodo#siVerdadero, subSiVerdadero
            finsi
        finsi
        cods#agregarAlFinal: {;end;~%}#formatear
    sino
        cods#agregarAlFinal: (Em#Formatear: nodo, {if ~p then~%}, (yo#visitar: nodo#condicional))
        CompilarBloque: nodo#siVerdadero, subSiVerdadero
        cods#agregarAlFinal: {else~%}#formatear
        CompilarBloque: nodo#siFalso, subSiFalso
        cods#agregarAlFinal: {end~%}#formatear
    finsi

    devolver Em#Parte#crear: cods, nodo
finmetodo

metodo CompiladorSimpleALua#visitarMientras: nodo
    variables cods, subyo

    fijar subyo a yo#crearSubámbitoDesdeNodo: nodo

    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: (Em#Formatear: nodo, {while ~p do~%}, (yo#visitar: nodo#condicional))

    cods#agregarAlFinal: subyo#iniciar
    cods#agregarAlFinal: (subyo#compilarInstrucciones: nodo#cuerpo)

    cods#agregarAlFinal: {end~%}#formatear

    devolver Em#Parte#crear: cods, nodo
finmetodo

metodo CompiladorSimpleALua#visitarMétodo: nodo
    variables clssym, nrdyo, subyo, cuerpoMet
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídos}
    fijar clssym a yo#nombreEnLua: nodo#deClase
    fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    fijar cuerpoMet a subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
    si nodo#esEstático
        devolver Em#Formatear:
            nodo,
            {(~p).methods[~t] = ~p;~%},
            clssym,
            (EscaparParaLua: nodo#nombre#nombre),
            cuerpoMet
    sino
        devolver Em#Formatear:
            nodo,
            {rt.enviarMensaje(~p, "agregarMetodo", ~p, ~p);~%},
            clssym,
            (EscaparParaLua: nodo#nombre#nombre),
            cuerpoMet
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarAtributos: nodo
    variables clssym, cods
    fijar clssym a yo#nombreEnLua: nodo#deClase
    fijar cods a Arreglo#vacio
    ParaCadaElemento: nodo#nombres, procedimiento: nodoId
        cods#agregarAlFinal: (Em#Formatear: nodoId, {rt.enviarMensaje(~p, "agregarAtributo", ~p);~%}, clssym, (EscaparParaLua: nodoId#nombre))
    finprocedimiento
    devolver Em#Parte#crear: cods, nodo
finmetodo

metodo CompiladorSimpleALua#visitarUtilizar: nodo
    variables módulo, nombreDelMódulo, mapeoDeImportados, espacioDeNombresResuelto
    si EsInstancia: nodo#módulo, AST#NodoIdentificador
        fijar nombreDelMódulo a nodo#módulo#nombre
    sino
        fijar nombreDelMódulo a nodo#módulo
    finsi
    fijar módulo a yo#_compilador#importarMódulo: nombreDelMódulo

    fijar mapeoDeImportados a Diccionario#vacío
    si no EsNulo: nodo#espacioDeNombres
        fijar espacioDeNombresResuelto a RN#NombreResueltoDe: nodo#espacioDeNombres
    finsi
    si no EsNulo: nodo#nombresEspecíficos
        ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: importado
            variables nombreEnMódulo, nombreFinal
            [ Si importamos la variable "Hola" como "Adios", por ejemplo, con
              `utilizar ejemplo (Hola como Adios)`, entonces nombreEnMódulo es `Hola`
              y nombreFinal es `Adios`. Si esta variable importada no fue renombrada
              (por ejemplo, `utilizar ejemplo (Hola)`) entonces nombreEnMódulo y
              nombreFinal son iguales. ]
            si EsInstancia: importado, AST#NodoIdentificador
                fijar nombreEnMódulo a importado
                fijar nombreFinal a importado
            sino
                fijar nombreEnMódulo a importado#en: 0
                fijar nombreFinal a importado#en: 1
            finsi
            mapeoDeImportados#fijarEn: nombreEnMódulo#nombre, (RN#NombreResueltoDe: nombreFinal)
        finprocedimiento
    finsi
    si (EsNulo: nodo#espacioDeNombres) && (EsNulo: nodo#nombresEspecíficos)
        fijar mapeoDeImportados a
            nodo#obtenerMetadato:
                RN#LLAVE_RESOLUCIÓN_DE_NOMBRES,
                {nombresImportadosResueltos}
    finsi

    variable cods
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: (Em#Formatear: nodo, {rt.ans_ns = rt.import(~p);~%}, (EscaparParaLua: módulo#llave#nombreCompletoDelArchivo))
    cods#agregarAlFinal: {do~%}#formatear
    mapeoDeImportados#paraCadaPar: procedimiento: nombre, id
        cods#agregarAlFinal: (Em#Formatear: nodo, {  ~p = rt.ans_ns:at(~t);~%}, (yo#nombreEnLua: id), (EscaparParaLua: nombre))
    finprocedimiento
    cods#agregarAlFinal: {end~%}#formatear
    si no EsNulo: espacioDeNombresResuelto
        cods#agregarAlFinal: (Em#Formatear: nodo, {~p = rt.ans_ns;}, (yo#nombreEnLua: espacioDeNombresResuelto))
    finsi

    devolver Em#Parte#crear: cods, nodo
finmetodo

metodo CompiladorSimpleALua#visitarIdentificador: nodo
    variables esAutoejecutable, identificador
    si nodo#contieneMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
        fijar esAutoejecutable a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
    sino
        fijar esAutoejecutable a FALSO
    finsi
    fijar identificador a yo#nombreEnLua: nodo
    si esAutoejecutable
        devolver Em#Parte#crear: (yo#enviarMensaje: identificador, {llamar}, Arreglo#vacio), nodo
    sino
        devolver Em#Parte#crear: identificador, nodo
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarNúmeroLiteral: nodo
    devolver Em#Parte#crear: nodo#valor, nodo
finmetodo

metodo CompiladorSimpleALua#visitarTextoLiteral: nodo
    devolver Em#Parte#crear: (EscaparParaLua: nodo#valor), nodo
finmetodo

[DOCUMENTA
@brief{Compila un envío de un mensaje.}

@params(
@defparam(objeto){Un texto que es una expresión Lua válida. El mensaje será
enviado a el objeto resultante.}

@defparam(mensaje){Un texto, el mensaje a enviar. Será escapado con
@pd{EscaparParaLua}.}

@defparam(argumentos){Una lista de NodoExpresion que puede contener varios
NodoVariadic (o ninguno).}
)

@devuelve{La parte de código con una llamada adecuada a @code{rt.enviarMensaje}
o @code{rt.enviarMensajeV}.}
DOCUMENTA]
metodo CompiladorSimpleALua#enviarMensaje: objeto, mensaje, argumentos
    variables args, argsComoTexto, funciónParaEnviarMensaje, alMenosUnArgumento

    [ `args` será un arreglo con los argumentos del mensaje. Cada secuencia de
    argumentos que no incluyan un variadic será agregada a `args` como un
    arreglo de nodos, mientras que los variadics serán agregados tal cual. Por
    ejemplo, los argumentos `1, 2, ...x, 4, ...y` sería agregado a `args` como
    `Arreglo#crearCon: (Arreglo#crearCon: 1, 2), x, (Arreglo#crearCon: 4), y`
    (claro, los números y `x` y `y` serían realmente nodos del AST.) ]

    fijar args a Arreglo#vacio
    fijar alMenosUnArgumento a FALSO
    ParaCadaElemento: argumentos, procedimiento: arg
        si EsInstancia: arg, AST#NodoVariadic
            args#agregarAlFinal: arg
        sino
            si args#longitud = 0
                args#agregarAlFinal: Arreglo#vacio
            sino
                si EsInstancia: (ÚltimoElemento: args), AST#NodoVariadic
                    args#agregarAlFinal: Arreglo#vacio
                finsi
            finsi
            (ÚltimoElemento: args)#agregarAlFinal: arg
        finsi
        fijar alMenosUnArgumento a VERDADERO
    finprocedimiento

    funcion CompilarArgumentosSimples: args
        devolver Em#Unir: NULO, (Mapear: args, funcion: x devolver yo#visitar: x finfuncion), {, }
    finfuncion

    fijar funciónParaEnviarMensaje a NULO
    si args#longitud = 1
        si EsInstancia: (args#en: 0), Arreglo
            fijar argsComoTexto a CompilarArgumentosSimples: (args#en: 0)
            fijar funciónParaEnviarMensaje a {enviarMensaje}
        finsi
    finsi
    si EsNulo: funciónParaEnviarMensaje
        fijar funciónParaEnviarMensaje a {enviarMensajeV}
        fijar argsComoTexto a Em#Unir: NULO, (Mapear: args, funcion: arg
            si EsInstancia: arg, AST#NodoVariadic
                devolver yo#visitar: arg#interno
            sino
                devolver Em#Formatear: arg, {{ __pd_var=true, n=~t, ~p ~e}, arg#longitud, (CompilarArgumentosSimples: arg)
            finsi
        finfuncion), {, }
    finsi
    si alMenosUnArgumento
        fijar argsComoTexto a Em#Formatear: NULO, {, ~p}, argsComoTexto
    finsi

    devolver Em#Formatear:
        NULO,
        {rt.~t(~p, ~t~p)},
        funciónParaEnviarMensaje,
        objeto,
        (EscaparParaLua: mensaje),
        argsComoTexto
finmetodo

metodo CompiladorSimpleALua#visitarLlamarProcedimiento: nodo
    si yo#esBuiltin: {__Lua}, (RN#NombreResueltoDe: nodo#proc)
        devolver yo#compilarBuiltinLua: nodo
    finsi
    devolver Em#Parte#crear:
        (yo#enviarMensaje:
            (yo#nombreEnLua: nodo#proc),
            {llamar},
            nodo#argumentos),
        nodo
finmetodo

metodo CompiladorSimpleALua#compilarBuiltinLua: nodo
    necesitas nodo#argumentos#longitud >= 1
    variables arg, argumentosEvaluados
    fijar arg a nodo#argumentos#en: 0
    necesitas EsInstancia: arg, AST#NodoTextoLiteral
    fijar argumentosEvaluados a
        Mapear:
            (PedazoDeArreglo: nodo#argumentos, 1, -1),
            funcion: x
                si EsInstancia: x, AST#NodoVariadic
                    __FallarConMensaje: {No se puede pasar un variadic a un builtin}
                finsi
                devolver yo#visitar: x
            finfuncion
    devolver Em#Formatear:
        nodo,
        {((~p)(~p))},
        arg#valor,
        (Em#Unir: nodo, argumentosEvaluados, {, })
finmetodo

metodo CompiladorSimpleALua#visitarEnviarMensaje: nodo
    devolver Em#Parte#crear:
        (yo#enviarMensaje:
            (yo#visitar: nodo#objeto),
            nodo#mensaje,
            nodo#argumentos),
        nodo
finmetodo

metodo CompiladorSimpleALua#visitarOperador: nodo
    devolver Em#Formatear:
        nodo,
        {rt.enviarMensaje(~p, ~t, ~p)},
        (yo#visitar: nodo#lhs),
        (EscaparParaLua: ({operador_~t}#formatear: nodo#op#op)),
        (yo#visitar: nodo#rhs)
finmetodo

metodo CompiladorSimpleALua#visitarNoLlamar: nodo
    variable base
    si EsInstancia: nodo#base, AST#NodoIdentificador
        fijar base a yo#nombreEnLua: nodo#base
    sino
        fijar base a yo#visitar: nodo#base
    finsi
    si nodo#mensajes#longitud > 0
        variable cod
        fijar cod a Reducir: base, funcion: acc, mensaje
            devolver Em#Formatear: nodo, {rt.enviarMensaje(~p, ~t)}, acc, (EscaparParaLua: mensaje#texto)
        finfuncion, (PedazoDeArreglo: nodo#mensajes, 0, -2)
        fijar cod a Em#Formatear:
            nodo,
            {rt.enviarMensaje(~p, ~t, ...)},
            cod,
            (EscaparParaLua: (ÚltimoElemento: nodo#mensajes)#texto)
        devolver Em#Formatear: nodo, {function(...) return ~p end}, cod
    sino
        devolver Em#Parte#crear: base, nodo
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarAutoejecutar: nodo
    devolver Em#Parte#crear:
        (yo#enviarMensaje: (yo#visitar: nodo#expr), {llamar}, nodo#argumentos),
        nodo
finmetodo

metodo CompiladorSimpleALua#visitarFunciónAnónima: nodo
    variable nrdyo, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídos}
    si nodo#esMétodo
        fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    sino
        fijar nrdyo a NULO
    finsi
    devolver Em#Parte#crear:
        (subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo),
        nodo
finmetodo

metodo CompiladorSimpleALua#visitarSonIguales: nodo
    variable igual
    fijar igual a yo#enviarMensaje: (yo#visitar: nodo#lhs), {igualA}, (Arreglo#crearCon: nodo#rhs)
    si nodo#tipoIgualdad = AST#TipoIgualdad#IGUALES
        devolver Em#Parte#crear: igual, nodo
    sino
        devolver Em#Formatear: nodo, {not ~p}, igual
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarReferenciar: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarNo: nodo
    devolver Em#Formatear: nodo, {not ~p}, (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarClonar: nodo
    variable tabla
    fijar tabla a Em#Formatear: nodo, {{~p~e},
        (Em#Unir:
            nodo,
            (Mapear: nodo#campos, funcion: res
                devolver Em#Formatear: nodo, {[~t] = ~p},
                    (EscaparParaLua: (res#en: 0)),
                    (yo#visitar: (res#en: 1))
            finfuncion),
            {, })
    devolver Em#Formatear: nodo, {rt.clonar(~p, ~p)},
        (yo#visitar: nodo#expresiónAClonar),
        tabla
finmetodo

metodo CompiladorSimpleALua#visitarVariadic: nodo
    Inalcanzable
finmetodo

[DOCUMENTA
@brief{Compila un arreglo de nodos.}

@pd{nodos} es un arreglo de nodos, cada uno siendo una instrucción a compilar.

El motivo por el que este método exíste es porque en Lua no todas las
expresiones pueden usarse como instrucciones, este método captura expresiones
en @pd{nodos} y las transforma a instrucciones equivalentes que Lua acepta.

@devuelve{Una parte de código: los nodos compilados.}
DOCUMENTA]
metodo CompiladorSimpleALua#compilarInstrucciones: nodos
    variable cods
    fijar cods a Mapear: nodos, funcion: nodo
        si EsInstancia: nodo, AST#NodoExpresion
            devolver Em#Formatear: nodo, {rt.ignore(~p);~%}, (yo#visitar: nodo)
        sino
            devolver Em#Formatear: nodo, {~p;~%}, (yo#visitar: nodo)
        finsi
    finfuncion
    devolver Em#Parte#sinAreaTextual: cods
finmetodo

[DOCUMENTA
@brief{Compila un AST a Lua.}

@params(
@defparam(moddb){La base de datos de módulos a utilizar.}

@defparam(ast){El @pd{AST#NodoPrograma} a compilar.}

@defparam(ámbito){El ámbito global como fue devuelto por
@pd{RN#ResolverNombres}.}

@defparam(compilador){La instancia de @pd{CompiladorALua} que esta compilando
el programa.}
)

@devuelve{Un texto que es el código lua compilado.}
DOCUMENTA]
funcion CompilarALua: moddb, llaveDeMódulo, ast, ámbito, compilador
    variables comp, ini, builtins, código
    fijar comp a CompiladorSimpleALua#crear: moddb, ámbito, compilador
    fijar ini a comp#iniciar
    fijar builtins a comp#registrarBuiltins
    fijar código a Em#Formatear:
        ast,
        {local rt = require "backends.lua.runtime";~%~p~%~p~%~p~%},
        ini,
        builtins,
        (comp#visitar: ast)
    devolver clonar Compilador#ResultadoDeCompilación#crear con
        compilado: Em#EmitirCódigo: código
        informaciónDeDepuración:
            Em#EmitirInformaciónDeDepuración:
                llaveDeMódulo#nombreCompletoDelArchivo,
                código,
                &EscaparParaLua
    finclonar
finfuncion

[DOCUMENTA
@brief{El backend a Lua.}
DOCUMENTA]
clase CompiladorALua hereda Compilador#CompiladorBase
    [DOCUMENTA
    @brief{Inicializa la instancia del backend.}

    @pd{db} es la base de datos de módulos a usar.
    DOCUMENTA]
    metodo inicializar: db

    metodo compilarAST: llaveDeMódulo, ast, ámbito
    metodo importarMódulo: nombreDelMódulo
    metodo inyectarNombresEnÁmbito: ámbito

    [DOCUMENTA
    @brief{Compila todos los módulos.}

    Toma todos los módulos de la base de datos de módulos y los une en un solo
    programa en lua que contiene todo el programa, listo para ser ejecutado.

    @pd{llavePrincipal} es la llave del módulo que será importado
    automaticamente al inicio del programa en Lua. Este módulo básicamente será
    el "principal".

    Devuelve el programa compilado como un texto.
    DOCUMENTA]
    metodo compilarTodo: llavePrincipal
finclase

atributo CompiladorALua#_builtins, CompiladorALua#_builtinsAutoejecutables

metodo CompiladorALua#inicializar: db
    fijar yo#baseDeDatos a db
    fijar yo#_builtins a
        Diccionario#desdePares:
            {Objeto}, RN#GenerarIdDeNombre,
            {VERDADERO}, RN#GenerarIdDeNombre,
            {FALSO}, RN#GenerarIdDeNombre,
            {NULO}, RN#GenerarIdDeNombre,
            {Aplicar}, RN#GenerarIdDeNombre,
            {ProcedimientoVarargs}, RN#GenerarIdDeNombre,
            {TipoDe}, RN#GenerarIdDeNombre,
            {__EnviarMensaje}, RN#GenerarIdDeNombre,
            {__FallarConMensaje}, RN#GenerarIdDeNombre,
            {__ClonarObjeto}, RN#GenerarIdDeNombre,
            {__CompararObjeto}, RN#GenerarIdDeNombre,
            {__AbrirArchivo}, RN#GenerarIdDeNombre,
            {__ByteATexto}, RN#GenerarIdDeNombre,
            {__TextoAByte}, RN#GenerarIdDeNombre,
            {__ByteEof}, RN#GenerarIdDeNombre,
            {__Capturar}, RN#GenerarIdDeNombre,
            {__Argv}, RN#GenerarIdDeNombre,
            {__LeerCaracter}, RN#GenerarIdDeNombre,
            {__Impl}, RN#GenerarIdDeNombre,

            {Boole}, RN#GenerarIdDeNombre,
            {Numero}, RN#GenerarIdDeNombre,
            {Arreglo}, RN#GenerarIdDeNombre,
            {Procedimiento}, RN#GenerarIdDeNombre,
            {Texto}, RN#GenerarIdDeNombre,
            {EspacioDeNombres}, RN#GenerarIdDeNombre,
            {Referencia}, RN#GenerarIdDeNombre,
            {TipoNulo}, RN#GenerarIdDeNombre,
            {__Lua}, RN#GenerarIdDeNombre
    fijar yo#_builtinsAutoejecutables a
        Arreglo#crearCon:
            {__Lua}, {Aplicar}, {ProcedimientoVarargs}, {TipoDe},
            {__EnviarMensaje}, {__FallarConMensaje}, {__ClonarObjeto},
            {__CompararObjeto}, {__AbrirArchivo}, {__ByteATexto},
            {__TextoAByte}, {__ByteEof}, {__Capturar}, {__LeerCaracter}
finmetodo

metodo CompiladorALua#compilarAST: llaveDeMódulo, ast, ámbito
    devolver CompilarALua: yo#baseDeDatos, llaveDeMódulo, ast, ámbito, yo
finmetodo

metodo CompiladorALua#importarMódulo: nombreDelMódulo
    variables móduloOLlave, móduloCompilado
    fijar móduloOLlave a
        Módulos#ResolverMóduloPorNombre: yo#baseDeDatos, nombreDelMódulo, procedimiento: llave
            devolver llave
        finprocedimiento, procedimiento: mod
            devolver mod
        finprocedimiento, procedimiento
            __FallarConMensaje: ({Error: no se pudo encontrar el módulo ~t}#formatear: nombreDelMódulo)
        finprocedimiento
    Escribir: ({--- Buscando: ~t}#formatear: nombreDelMódulo)
    si EsInstancia: móduloOLlave, Módulos#Módulo
        Escribir: {--- Encontrado}
        devolver móduloOLlave
    sino
        Escribir: {--- No encontrado, compilandolo}
        fijar móduloCompilado a yo#compilarTexto:
            móduloOLlave,
            (Archivos#LeerArchivo: móduloOLlave#nombreCompletoDelArchivo)
        yo#baseDeDatos#agregarMódulo: móduloCompilado
        devolver móduloCompilado
    finsi
finmetodo

metodo CompiladorALua#inyectarNombresEnÁmbito: ámbito
    yo#_builtins#paraCadaPar: procedimiento: nombreEnRT, binding
        ámbito#agregar: nombreEnRT, binding
    finprocedimiento
    ParaCadaElemento: yo#_builtinsAutoejecutables, procedimiento: nombre
        ámbito#marcarComoAutoejecutable: nombre
    finprocedimiento
finmetodo

metodo CompiladorALua#removerNombresDeÁmbito: ámbito
    yo#_builtins#paraCadaPar: procedimiento: nombreEnRT, _binding
        ámbito#eliminarNombre: nombreEnRT
    finprocedimiento
finmetodo

metodo CompiladorALua#compilarTodo: llavePrincipal
    variables móduloPrincipal, cods
    fijar móduloPrincipal a yo#baseDeDatos#buscarMóduloPorLlave: llavePrincipal
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: {local rt = require "backends.lua.runtime";}
    cods#agregarAlFinal: {local errloc = require "backends.lua.errloc";}
    yo#baseDeDatos#paraCadaMódulo: procedimiento: módulo
        cods#agregarAlFinal: ({rt.modulos[~t] = function()~%~t~%end;}#formatear: (EscaparParaLua: módulo#llave#nombreCompletoDelArchivo), módulo#compilado)
        cods#agregarAlFinal: módulo#informaciónDeDepuración
    finprocedimiento
    cods#agregarAlFinal: ({;rt.llamarmain(rt.importarmain, ~t, ...);}#formatear: (EscaparParaLua: llavePrincipal#nombreCompletoDelArchivo))
    devolver Unir: cods, {~%}#formatear
finmetodo
