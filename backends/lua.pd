utilizar bepd/builtins
utilizar bepd/utilidades/texto
utilizar bepd/x/sistemaDeArchivos/archivo como Archivos

utilizar ast como AST
utilizar caminaNodos como CN

utilizar resoluciónDeNombres como RN

utilizar módulos como Módulos

utilizar compilador como Compilador

[ El backend de Lua está separado en dos partes. Espero, con el tiempo,
  "limpiar" mucho de este código (recuerda que el patrón del visitante ("Visitor
  Pattern") es realmente una manera de hacer "pattern matching" en lenguajes que
  no lo soportan).

  De cualquier forma, las dos partes son:

  - La clase `CompiladosSimpleALua` (hereda `CaminaNodos`): Va por cada nodo
    del AST y lo compila a Lua.
  - La clase `CompiladorALua` (hereda `CompiladorBase`): Compila ASTs, archivos
    y textos. "Orquestra" las operaciones de `CompiladorSimpleALua`.

  Para facilitar las cosas, `CompiladorSimpleALua` tiene un atributo
 `_compilador` que apunta al `CompiladorALua` que lo maneja. ]

funcion EscaparParaLua: texto
    variable res
    fijar res a {"} [ " ]
    ParaCadaElemento: texto, procedimiento: car
        si car = {"} [ " ]
            fijar res a res#concatenar: {\"} [ " ]
        sino
            si car = {~%}#formatear
                fijar res a res#concatenar: {\n}
            sino
                si car = {\}
                    fijar res a res#concatenar: {\\}
                sino
                    fijar res a res#concatenar: car
                finsi
            finsi
        finsi
    finprocedimiento
    devolver res#concatenar: {"} [ " ]
finfuncion

funcion IdentificadorDe: id
    devolver {_s._}#concatenar: (RN#NombreResueltoDe: id)#comoTexto
finfuncion

clase CompiladorSimpleALua hereda CN#CaminaNodos
    metodo crearSubámbitoDesdeNodo: nodo
    metodo crearSubámbitoDesdeNombreEnNodo: nodo, llave

    metodo inicializar: moddb, ámbito, compilador

    metodo iniciar
    metodo registrarBuiltins

    metodo esBuiltin: nombre, binding
finclase

atributos CompiladorSimpleALua#_ámbito, [ Ámbito actual ]
          CompiladorSimpleALua#_moddb, [ Base de datos de módulos ]
          CompiladorSimpleALua#_compilador [ `CompiladorALua` que esta compilando ]

metodo CompiladorSimpleALua#crearSubámbitoDesdeNodo: nodo
    devolver yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídos}
finmetodo

metodo CompiladorSimpleALua#crearSubámbitoDesdeNombreEnNodo: nodo, llave
    devolver CompiladorSimpleALua#crear:
                 yo#_moddb,
                 (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, llave),
                 yo#_compilador
finmetodo

metodo CompiladorSimpleALua#inicializar: moddb, ámbito, compilador
    fijar yo#_ámbito a ámbito
    fijar yo#_moddb a moddb
    fijar yo#_compilador a compilador
finmetodo

metodo CompiladorSimpleALua#iniciar
    variables res, padre
    fijar res a Arreglo#vacio
    si no EsNulo: yo#_ámbito#ámbitoPadre
        fijar padre a {_s}
    sino
        fijar padre a {}
    finsi
    res#agregarAlFinal: ({local _s = rt.scope(~t)}#formatear: padre)
    ParaCadaElemento: yo#_ámbito#todosLosBindingsLocales, procedimiento: id
        res#agregarAlFinal: ({rt.scopenewname(_s, "_~t");}#formatear: id)
    finprocedimiento
    devolver Unir: res, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#registrarBuiltins
    variable cods
    fijar cods a Arreglo#vacio
    yo#_compilador#_builtins#paraCadaPar: procedimiento: nombreEnRT, binding
        cods#agregarAlFinal: ({_s._~t = rt.builtins[~t];}#formatear: binding, (EscaparParaLua: nombreEnRT))
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#esBuiltin: nombre, binding
    devolver (yo#_compilador#_builtins#en: nombre) = binding
finmetodo

metodo CompiladorSimpleALua#visitarPrograma: nodo
    variables instrs, ámbito
    fijar instrs a Arreglo#vacio
    ParaCadaElemento: nodo#instrucciones, procedimiento: instr
        instrs#agregarAlFinal: ((yo#visitar: instr)#concatenar: {;})
    finprocedimiento
    fijar ámbito a RN#ObtenerNombresDefinídos: nodo
    instrs#agregarAlFinal: {return rt.ns({}#formatear
    ámbito#paraCadaVariable: procedimiento: nombre, dv
        instrs#agregarAlFinal: ({  [~t] = { value = _s._~t, autoexecutable = ~t ~e,}#formatear:
            (EscaparParaLua: nombre),
            dv#binding,
            (dv#esAutoejecutable#escojer: {true}, {false}))
    finprocedimiento
    instrs#agregarAlFinal: {~e);}#formatear
    devolver Unir: instrs, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarVariable: nodo
    devolver {}
finmetodo

metodo CompiladorSimpleALua#visitarFijar: nodo
    si EsInstancia: nodo#objetivo, AST#NodoIdentificador
        variables obj, expr
        fijar obj a IdentificadorDe: nodo#objetivo
        fijar expr a yo#visitar: nodo#valor
        devolver {~t = (~t);}#formatear: obj, expr
    sino
        necesitas EsInstancia: nodo#objetivo, AST#NodoEnviarMensaje
        necesitas nodo#objetivo#argumentos#longitud = 0
        variable base, fieldname
        fijar base a yo#visitar: nodo#objetivo#objeto
        fijar fieldname a {fijar_}#concatenar: nodo#objetivo#mensaje
        devolver yo#enviarMensaje: base, fieldname, (Arreglo#crearCon: nodo#valor)
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarEscribir: nodo
    devolver {rt.escribir(~t);}#formatear: (yo#visitar: nodo#valor)
finmetodo

metodo CompiladorSimpleALua#visitarNl: nodo
    devolver {rt.nl();}
finmetodo

metodo CompiladorSimpleALua#visitarClase: nodo
    variables cods, clssym, base
    fijar clssym a IdentificadorDe: nodo#nombre
    fijar cods a Arreglo#vacio
    si no EsNulo: nodo#claseBase
        fijar base a yo#visitar: nodo#claseBase
    sino
        fijar base a {rt.clases.Objeto}
    finsi
    cods#agregarAlFinal: ({~t = (~t);}#formatear: clssym, (yo#enviarMensaje: ({(~t)}#formatear: base), {subclase}, Arreglo#vacio))
    cods#agregarAlFinal: ({rt.enviarMensaje(~t, "fijar_nombre", ~t);}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre))
    ParaCadaElemento: nodo#declaraciones, procedimiento: declr
        si EsInstancia: declr, AST#NodoDeclaraciónDeAtributosEnClase
            cods#agregarAlFinal: ((yo#visitar: (clonar AST#NodoAtributos#crear con
                areaTextual: declr#areaTextual
                deClase: nodo#nombre
                nombres: declr#nombres
            finclonar))#concatenar: {;})
        sino
            [ Nada que hacer para los NodoDeclaraciónDeMétodoEnClase ]
        finsi
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeAtributosEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeMétodoEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarImplementa: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineAtributosEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineMétodoEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#expresiónDeFunción: nombreResueltoDeYo, parámetros, cuerpo
    variables cods, params, variadic, met, paramsbody
    fijar cods a Arreglo#vacio
    fijar variadic a NULO

    funcion CódigoDeParam: param
        si EsInstancia: param, AST#NodoIdentificador
            devolver {_~t}#formatear: (RN#NombreResueltoDe: param)
        sino
            fijar variadic a param
            devolver {...}
        finsi
    finfuncion

    fijar params a Unir: (Mapear: parámetros, &CódigoDeParam), {, }

    si no EsNulo: nombreResueltoDeYo
        fijar met a {_~t}#formatear: nombreResueltoDeYo
        si parámetros#longitud > 0
            fijar params a {, }#concatenar: params
        finsi
    sino
        fijar met a {}
    finsi

    funcion CódigoDeParamBody: param
        si EsInstancia: param, AST#NodoIdentificador
            devolver {rt.scopenewname(_s, "_~t"); ~t = _~t}#formatear: (RN#NombreResueltoDe: param), (IdentificadorDe: param), (RN#NombreResueltoDe: param)
        sino
            devolver {rt.scopenewname(_s, "_~t")}#formatear: (RN#NombreResueltoDe: param#interno)
        finsi
    finfuncion

    fijar paramsbody a Unir: (Mapear: parámetros, &CódigoDeParamBody), {;~%}#formatear

    si no EsNulo: nombreResueltoDeYo
        fijar paramsbody a paramsbody#concatenar:
            ({~%;rt.scopenewname(_s, "_~t"); _s._~t = _~t}#formatear:
                nombreResueltoDeYo, nombreResueltoDeYo, nombreResueltoDeYo)
    finsi

    cods#agregarAlFinal: ({function(~t~t)}#formatear: met, params)
    cods#agregarAlFinal: yo#iniciar
    cods#agregarAlFinal: (paramsbody#concatenar: {;})
    si no EsNulo: variadic
        [ Los parámetros no son declarados al principio de las
          funciones/métodos/procedimientos. Por esto debemos declarar este
          manualmente. ]
        cods#agregarAlFinal: ({~t = rt.arreglo(...)}#formatear: (IdentificadorDe: variadic#interno))
    finsi

    ParaCadaElemento: cuerpo, procedimiento: stmt
        cods#agregarAlFinal: ((yo#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarFunción: nodo
    variables cods, id, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    fijar id a IdentificadorDe: nodo#nombre
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({~t = (~t);}#formatear:
        id,
        (subyo#expresiónDeFunción: NULO, nodo#parámetros, nodo#cuerpo)
    )
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarNecesitas: nodo
    devolver {assert(~t);}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarDevolver: nodo
    devolver {do return ~t; end;}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarSi: nodo
    variables cods, subSiVerdadero, subSiFalso

    fijar subSiVerdadero a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiVerdadero}
    fijar subSiFalso a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiFalso}

    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({if ~t then}#formatear: (yo#visitar: nodo#condicional))

    cods#agregarAlFinal: subSiVerdadero#iniciar
    ParaCadaElemento: nodo#siVerdadero, procedimiento: stmt
        cods#agregarAlFinal: ((subSiVerdadero#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {else}

    cods#agregarAlFinal: subSiFalso#iniciar
    ParaCadaElemento: nodo#siFalso, procedimiento: stmt
        cods#agregarAlFinal: ((subSiFalso#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarMientras: nodo
    variables cods, subyo

    fijar subyo a yo#crearSubámbitoDesdeNodo: nodo

    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({while ~t do}#formatear: (yo#visitar: nodo#condicional))

    cods#agregarAlFinal: subyo#iniciar
    ParaCadaElemento: nodo#cuerpo, procedimiento: stmt
        cods#agregarAlFinal: ((subyo#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarMétodo: nodo
    variables clssym, nrdyo, subyo, cuerpoMet
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    fijar clssym a IdentificadorDe: nodo#deClase
    fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    fijar cuerpoMet a subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
    si nodo#esEstático
        devolver {(~t).methods[~t] = ~t}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre), cuerpoMet
    sino
        devolver {rt.enviarMensaje(~t, "agregarMetodo", ~t, ~t);}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre), cuerpoMet
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarAtributos: nodo
    variables clssym, cods
    fijar clssym a IdentificadorDe: nodo#deClase
    fijar cods a Arreglo#vacio
    ParaCadaElemento: nodo#nombres, procedimiento: nodoId
        cods#agregarAlFinal: ({rt.enviarMensaje(~t, "agregarAtributo", ~t);}#formatear: clssym, (EscaparParaLua: nodoId#nombre))
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarUtilizar: nodo
    variables módulo, nombreDelMódulo, mapeoDeImportados, espacioDeNombresResuelto
    si EsInstancia: nodo#módulo, AST#NodoIdentificador
        fijar nombreDelMódulo a nodo#módulo#nombre
    sino
        fijar nombreDelMódulo a nodo#módulo
    finsi
    fijar módulo a yo#_compilador#importarMódulo: nombreDelMódulo

    fijar mapeoDeImportados a Diccionario#vacío
    si no EsNulo: nodo#espacioDeNombres
        fijar espacioDeNombresResuelto a RN#NombreResueltoDe: nodo#espacioDeNombres
    finsi
    si no EsNulo: nodo#nombresEspecíficos
        ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: importado
            variables nombreEnMódulo, nombreFinal
            [ Si importamos la variable "Hola" como "Adios", por ejemplo, con
              `utilizar ejemplo (Hola como Adios)`, entonces nombreEnMódulo es `Hola`
              y nombreFinal es `Adios`. Si esta variable importada no fue renombrada
              (por ejemplo, `utilizar ejemplo (Hola)`) entonces nombreEnMódulo y
              nombreFinal son iguales. ]
            si EsInstancia: importado, AST#NodoIdentificador
                fijar nombreEnMódulo a importado
                fijar nombreFinal a importado
            sino
                fijar nombreEnMódulo a importado#en: 0
                fijar nombreFinal a importado#en: 1
            finsi
            mapeoDeImportados#fijarEn: nombreEnMódulo#nombre, (RN#NombreResueltoDe: nombreFinal)
        finprocedimiento
    finsi
    si (EsNulo: nodo#espacioDeNombres) && (EsNulo: nodo#nombresEspecíficos)
        fijar mapeoDeImportados a
            nodo#obtenerMetadato:
                RN#LLAVE_RESOLUCIÓN_DE_NOMBRES,
                {nombresImportadosResueltos}
    finsi

    variable cods
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({rt.ans_ns = rt.import(~t)}#formatear: (EscaparParaLua: módulo#llave#nombreCompletoDelArchivo))
    cods#agregarAlFinal: {;do}
    mapeoDeImportados#paraCadaPar: procedimiento: nombre, id
        cods#agregarAlFinal: ({  _s._~t = rt.ans_ns:at(~t);}#formatear: id, (EscaparParaLua: nombre))
    finprocedimiento
    cods#agregarAlFinal: {end}
    si no EsNulo: espacioDeNombresResuelto
        cods#agregarAlFinal: ({;_s._~t = rt.ans_ns;}#formatear: espacioDeNombresResuelto)
    finsi

    devolver (Unir: cods, {~%}#formatear)
finmetodo

metodo CompiladorSimpleALua#visitarIdentificador: nodo
    variables esAutoejecutable, identificador
    si nodo#contieneMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
        fijar esAutoejecutable a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
    sino
        fijar esAutoejecutable a FALSO
    finsi
    fijar identificador a IdentificadorDe: nodo
    si esAutoejecutable
        devolver yo#enviarMensaje: identificador, {llamar}, Arreglo#vacio
    sino
        devolver identificador
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarNúmeroLiteral: nodo
    devolver nodo#valor
finmetodo

metodo CompiladorSimpleALua#visitarTextoLiteral: nodo
    devolver EscaparParaLua: nodo#valor
finmetodo

metodo CompiladorSimpleALua#enviarMensaje: objeto, mensaje, argumentos
    variables args, argsComoTexto, funciónParaEnviarMensaje

    fijar args a Arreglo#vacio
    ParaCadaElemento: argumentos, procedimiento: arg
        si EsInstancia: arg, AST#NodoVariadic
            args#agregarAlFinal: arg
        sino
            si args#longitud = 0
                args#agregarAlFinal: Arreglo#vacio
            sino
                si EsInstancia: (ÚltimoElemento: args), AST#NodoVariadic
                    args#agregarAlFinal: Arreglo#vacio
                finsi
            finsi
            (ÚltimoElemento: args)#agregarAlFinal: arg
        finsi
    finprocedimiento

    funcion CompilarArgumentosSimples: args
        devolver Unir: (Mapear: args, funcion: x devolver yo#visitar: x finfuncion), {, }
    finfuncion

    fijar funciónParaEnviarMensaje a NULO
    si args#longitud = 1
        si EsInstancia: (args#en: 0), Arreglo
            fijar argsComoTexto a CompilarArgumentosSimples: (args#en: 0)
            fijar funciónParaEnviarMensaje a {enviarMensaje}
        finsi
    finsi
    si EsNulo: funciónParaEnviarMensaje
        fijar funciónParaEnviarMensaje a {enviarMensajeV}
        fijar argsComoTexto a Unir: (Mapear: args, funcion: arg
            si EsInstancia: arg, AST#NodoVariadic
                devolver yo#visitar: arg#interno
            sino
                devolver {{ __pd_var=true, n=~t, ~t ~e}#formatear: arg#longitud, (CompilarArgumentosSimples: arg)
            finsi
        finfuncion), {, }
    finsi
    si argsComoTexto#longitud > 0
        fijar argsComoTexto a {, }#concatenar: argsComoTexto
    finsi

    devolver {rt.~t(~t, ~t~t)}#formatear: funciónParaEnviarMensaje, objeto, (EscaparParaLua: mensaje), argsComoTexto
finmetodo

metodo CompiladorSimpleALua#visitarLlamarProcedimiento: nodo
    si yo#esBuiltin: {__Lua}, (RN#NombreResueltoDe: nodo#proc)
        devolver yo#compilarBuiltinLua: nodo
    finsi
    devolver yo#enviarMensaje: (IdentificadorDe: nodo#proc), {llamar}, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#compilarBuiltinLua: nodo
    necesitas nodo#argumentos#longitud >= 1
    variables arg, argumentosEvaluados
    fijar arg a nodo#argumentos#en: 0
    necesitas EsInstancia: arg, AST#NodoTextoLiteral
    fijar argumentosEvaluados a
        Mapear:
            (PedazoDeArreglo: nodo#argumentos, 1, -1),
            funcion: x devolver yo#visitar: x finfuncion
    devolver {((~t)(~t))}#formatear: arg#valor, (Unir: argumentosEvaluados, {, })
finmetodo

metodo CompiladorSimpleALua#visitarEnviarMensaje: nodo
    devolver yo#enviarMensaje: (yo#visitar: nodo#objeto), nodo#mensaje, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarOperador: nodo
    devolver {rt.enviarMensaje(~t, ~t, ~t)}#formatear:
        (yo#visitar: nodo#lhs),
        (EscaparParaLua: ({operador_~t}#formatear: nodo#op#op)),
        (yo#visitar: nodo#rhs)
finmetodo

metodo CompiladorSimpleALua#visitarNoLlamar: nodo
    variable base
    si EsInstancia: nodo#base, AST#NodoIdentificador
        fijar base a IdentificadorDe: nodo#base
    sino
        fijar base a yo#visitar: nodo#base
    finsi
    si nodo#mensajes#longitud > 0
        variable cod
        fijar cod a Reducir: base, funcion: acc, mensaje
            devolver {rt.enviarMensaje(~t, ~t)}#formatear: acc, (EscaparParaLua: mensaje#texto)
        finfuncion, (PedazoDeArreglo: nodo#mensajes, 0, -2)
        fijar cod a {rt.enviarMensaje(~t, ~t, ...)}#formatear: cod, (EscaparParaLua: (ÚltimoElemento: nodo#mensajes)#texto)
        devolver {function(...) return ~t end}#formatear: cod
    sino
        devolver base
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarAutoejecutar: nodo
    devolver yo#enviarMensaje: (yo#visitar: nodo#expr), {llamar}, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarFunciónAnónima: nodo
    variable nrdyo, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    si nodo#esMétodo
        fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    sino
        fijar nrdyo a NULO
    finsi
    devolver subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
finmetodo

metodo CompiladorSimpleALua#visitarSonIguales: nodo
    variable igual
    fijar igual a yo#enviarMensaje: (yo#visitar: nodo#lhs), {igualA}, (Arreglo#crearCon: nodo#rhs)
    si nodo#tipoIgualdad = AST#TipoIgualdad#IGUALES
        devolver igual
    sino
        devolver {not ~t}#formatear: igual
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarReferenciar: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarNo: nodo
    devolver {not ~t}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarClonar: nodo
    variable tabla
    fijar tabla a {{~t~e}#formatear:
        (Unir:
            (Mapear: nodo#campos, funcion: res
                devolver {[~t] = ~t}#formatear: (EscaparParaLua: (res#en: 0)), (yo#visitar: (res#en: 1))
            finfuncion),
            {, })
    devolver {rt.clonar(~t, ~t)}#formatear: (yo#visitar: nodo#expresiónAClonar), tabla
finmetodo

metodo CompiladorSimpleALua#visitarVariadic: nodo
    Inalcanzable
finmetodo

funcion CompilarALua: moddb, ast, ámbito, compilador
    variables comp, ini, builtins
    fijar comp a CompiladorSimpleALua#crear: moddb, ámbito, compilador
    fijar ini a comp#iniciar
    fijar builtins a comp#registrarBuiltins
    devolver {local rt = require "backends.lua.runtime";~%~t~%~t~%~t}#formatear: ini, builtins, (comp#visitar: ast)
finfuncion

clase CompiladorALua hereda Compilador#CompiladorBase
    metodo inicializar: db
    metodo compilarAST: ast, ámbito
    metodo importarMódulo: nombreDelMódulo
    metodo inyectarNombresEnÁmbito: ámbito
    metodo compilarTodo: llavePrincipal
finclase

atributo CompiladorALua#_builtins, CompiladorALua#_builtinsAutoejecutables

metodo CompiladorALua#inicializar: db
    fijar yo#baseDeDatos a db
    fijar yo#_builtins a
        Diccionario#desdePares:
            {Objeto}, RN#GenerarIdDeNombre,
            {VERDADERO}, RN#GenerarIdDeNombre,
            {FALSO}, RN#GenerarIdDeNombre,
            {NULO}, RN#GenerarIdDeNombre,
            {Aplicar}, RN#GenerarIdDeNombre,
            {ProcedimientoVarargs}, RN#GenerarIdDeNombre,
            {TipoDe}, RN#GenerarIdDeNombre,
            {__EnviarMensaje}, RN#GenerarIdDeNombre,
            {__FallarConMensaje}, RN#GenerarIdDeNombre,
            {__ClonarObjeto}, RN#GenerarIdDeNombre,
            {__CompararObjeto}, RN#GenerarIdDeNombre,
            {__AbrirArchivo}, RN#GenerarIdDeNombre,
            {__ByteATexto}, RN#GenerarIdDeNombre,
            {__TextoAByte}, RN#GenerarIdDeNombre,
            {__ByteEof}, RN#GenerarIdDeNombre,
            {__Capturar}, RN#GenerarIdDeNombre,
            {__Argv}, RN#GenerarIdDeNombre,
            {__LeerCaracter}, RN#GenerarIdDeNombre,

            {Boole}, RN#GenerarIdDeNombre,
            {Numero}, RN#GenerarIdDeNombre,
            {Arreglo}, RN#GenerarIdDeNombre,
            {Procedimiento}, RN#GenerarIdDeNombre,
            {Texto}, RN#GenerarIdDeNombre,
            {EspacioDeNombres}, RN#GenerarIdDeNombre,
            {Referencia}, RN#GenerarIdDeNombre,
            {TipoNulo}, RN#GenerarIdDeNombre,
            {__Lua}, RN#GenerarIdDeNombre
    fijar yo#_builtinsAutoejecutables a
        Arreglo#crearCon:
            {__Lua}, {Aplicar}, {ProcedimientoVarargs}, {TipoDe},
            {__EnviarMensaje}, {__FallarConMensaje}, {__ClonarObjeto},
            {__CompararObjeto}, {__AbrirArchivo}, {__ByteATexto},
            {__TextoAByte}, {__ByteEof}, {__Capturar}
finmetodo

metodo CompiladorALua#compilarAST: ast, ámbito
    devolver CompilarALua: yo#baseDeDatos, ast, ámbito, yo
finmetodo

metodo CompiladorALua#importarMódulo: nombreDelMódulo
    variables móduloOLlave, móduloCompilado
    fijar móduloOLlave a
        Módulos#ResolverMóduloPorNombre: yo#baseDeDatos, nombreDelMódulo, procedimiento: llave
            devolver llave
        finprocedimiento, procedimiento: mod
            devolver mod
        finprocedimiento, procedimiento
            __FallarConMensaje: ({Error: no se pudo encontrar el módulo ~t}#formatear: nombreDelMódulo)
        finprocedimiento
    Escribir: ({--- Buscando: ~t}#formatear: nombreDelMódulo)
    si EsInstancia: móduloOLlave, Módulos#Módulo
        Escribir: {--- Encontrado}
        devolver móduloOLlave
    sino
        Escribir: {--- No encontrado, compilandolo}
        fijar móduloCompilado a yo#compilarTexto:
            móduloOLlave,
            (Archivos#LeerArchivo: móduloOLlave#nombreCompletoDelArchivo)
        yo#baseDeDatos#agregarMódulo: móduloCompilado
        devolver móduloCompilado
    finsi
finmetodo

metodo CompiladorALua#inyectarNombresEnÁmbito: ámbito
    yo#_builtins#paraCadaPar: procedimiento: nombreEnRT, binding
        ámbito#agregar: nombreEnRT, binding
    finprocedimiento
    ParaCadaElemento: yo#_builtinsAutoejecutables, procedimiento: nombre
        ámbito#marcarComoAutoejecutable: nombre
    finprocedimiento
finmetodo

metodo CompiladorALua#compilarTodo: llavePrincipal
    variables móduloPrincipal, cods
    fijar móduloPrincipal a yo#baseDeDatos#buscarMóduloPorLlave: llavePrincipal
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: {local rt = require "backends.lua.runtime";}
    yo#baseDeDatos#paraCadaMódulo: procedimiento: módulo
        cods#agregarAlFinal: ({rt.modulos[~t] = function()~%~t~%end;}#formatear: (EscaparParaLua: módulo#llave#nombreCompletoDelArchivo), módulo#compilado)
    finprocedimiento
    cods#agregarAlFinal: ({;rt.importar(~t);}#formatear: (EscaparParaLua: llavePrincipal#nombreCompletoDelArchivo))
    devolver Unir: cods, {~%}#formatear
finmetodo
