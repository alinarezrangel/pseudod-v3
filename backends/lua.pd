utilizar bepd/builtins
utilizar bepd/utilidades/texto
utilizar bepd/x/sistemaDeArchivos/archivo como Archivos

utilizar ast como AST
utilizar caminaNodos como CN

utilizar resoluciónDeNombres como RN

utilizar módulos como Módulos

utilizar compilador como Compilador

[ El backend de Lua está separado en dos partes. Espero, con el tiempo,
  "limpiar" mucho de este código (recuerda que el patrón del visitante ("Visitor
  Pattern") es realmente una manera de hacer "pattern matching" en lenguajes que
  no lo soportan).

  De cualquier forma, las dos partes son:

  - La clase `CompiladosSimpleALua` (hereda `CaminaNodos`): Va por cada nodo
    del AST y lo compila a Lua.
  - La clase `CompiladorALua` (hereda `CompiladorBase`): Compila ASTs, archivos
    y textos. "Orquestra" las operaciones de `CompiladorSimpleALua`.

  Para facilitar las cosas, `CompiladorSimpleALua` tiene un atributo
 `_compilador` que apunta al `CompiladorALua` que lo maneja. ]

funcion EscaparParaLua: texto
    variable res
    fijar res a {"} [ " ]
    ParaCadaElemento: texto, procedimiento: car
        si car = {"} [ " ]
            fijar res a res#concatenar: {\"} [ " ]
        sino
            si car = {~%}#formatear
                fijar res a res#concatenar: {~%}#formatear
            sino
                fijar res a res#concatenar: car
            finsi
        finsi
    finprocedimiento
    devolver res#concatenar: {"} [ " ]
finfuncion

funcion IdentificadorDe: id
    devolver {_}#concatenar: (RN#NombreResueltoDe: id)#comoTexto
finfuncion

clase CompiladorSimpleALua hereda CN#CaminaNodos
    metodo crearSubámbitoDesdeNodo: nodo
    metodo crearSubámbitoDesdeNombreEnNodo: nodo, llave

    metodo inicializar: moddb, ámbito, compilador

    metodo iniciar
finclase

atributos CompiladorSimpleALua#_ámbito, [ Ámbito actual ]
          CompiladorSimpleALua#_moddb, [ Base de datos de módulos ]
          CompiladorSimpleALua#_compilador [ `CompiladorALua` que esta compilando ]

metodo CompiladorSimpleALua#crearSubámbitoDesdeNodo: nodo
    devolver yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídos}
finmetodo

metodo CompiladorSimpleALua#crearSubámbitoDesdeNombreEnNodo: nodo, llave
    devolver CompiladorSimpleALua#crear:
                 yo#_moddb,
                 (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, llave),
                 yo#_compilador
finmetodo

metodo CompiladorSimpleALua#inicializar: moddb, ámbito, compilador
    fijar yo#_ámbito a ámbito
    fijar yo#_moddb a moddb
    fijar yo#_compilador a compilador
finmetodo

metodo CompiladorSimpleALua#iniciar
    variable res
    fijar res a Arreglo#vacio
    yo#_ámbito#_mapeo#paraCadaPar: procedimiento: nombreEnPseudoD, id
        res#agregarAlFinal: ({local _~t  --  ~t}#formatear: id, nombreEnPseudoD)
    finprocedimiento
    devolver Unir: res, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarPrograma: nodo
    variables instrs, ámbito
    fijar instrs a Arreglo#vacio
    ParaCadaElemento: nodo#instrucciones, procedimiento: instr
        instrs#agregarAlFinal: (yo#visitar: instr)
    finprocedimiento
    fijar ámbito a RN#ObtenerNombresDefinídos: nodo
    instrs#agregarAlFinal: {return rt.ns({}#formatear
    ámbito#_mapeo#paraCadaPar: procedimiento: nombre, id
        instrs#agregarAlFinal: ({  [~t] = _~t,}#formatear: (EscaparParaLua: nombre), id)
    finprocedimiento
    instrs#agregarAlFinal: {~e)}#formatear
    devolver Unir: instrs, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarVariable: nodo
    devolver {}
finmetodo

metodo CompiladorSimpleALua#visitarFijar: nodo
    necesitas EsInstancia: nodo#objetivo, AST#NodoIdentificador
    variable obj, expr
    fijar obj a IdentificadorDe: nodo#objetivo
    fijar expr a yo#visitar: nodo#valor
    devolver {~t = ~t}#formatear: obj, expr
finmetodo

metodo CompiladorSimpleALua#visitarEscribir: nodo
    devolver {rt.escribir(~t)}#formatear: (yo#visitar: nodo#valor)
finmetodo

metodo CompiladorSimpleALua#visitarNl: nodo
    devolver {rt.nl()}
finmetodo

metodo CompiladorSimpleALua#visitarClase: nodo
    variables cods, clssym
    fijar clssym a IdentificadorDe: nodo#nombre
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({~t = ~t}#formatear: clssym, (yo#enviarMensaje: {rt.clases.Objeto}, {subclase}, Arreglo#vacio))
    cods#agregarAlFinal: ({rt.enviarMensaje(~t, "fijar_nombre", ~t)}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre))
    ParaCadaElemento: nodo#declaraciones, procedimiento: declr
        si EsInstancia: declr, AST#NodoDeclaraciónDeAtributosEnClase
            cods#agregarAlFinal: (yo#visitar: (clonar AST#NodoAtributos#crear con
                areaTextual: declr#areaTextual
                deClase: nodo#nombre
                nombres: declr#nombres
            finclonar))
        sino
            [ Nada que hacer para los NodoDeclaraciónDeMétodoEnClase ]
        finsi
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeAtributosEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeMétodoEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarImplementa: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineAtributosEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineMétodoEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#expresiónDeFunción: nombreResueldoDeYo, parámetros, cuerpo
    variables cods, params, met
    fijar cods a Arreglo#vacio

    fijar params a Unir: (Mapear: parámetros, &IdentificadorDe), {, }

    si no EsNulo: nombreResueldoDeYo
        fijar met a {_~t}#formatear: nombreResueldoDeYo
        si parámetros#longitud > 0
            fijar params a {, }#concatenar: params
        finsi
    sino
        fijar met a {}
    finsi
    cods#agregarAlFinal: ({function(~t~t)}#formatear: met, params)
    cods#agregarAlFinal: yo#iniciar

    ParaCadaElemento: cuerpo, procedimiento: stmt
        cods#agregarAlFinal: (yo#visitar: stmt)
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarFunción: nodo
    variables cods, id, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    fijar id a IdentificadorDe: nodo#nombre
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({~t = ~t}#formatear:
        id,
        (subyo#expresiónDeFunción: NULO, nodo#parámetros, nodo#cuerpo)
    )
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarNecesitas: nodo
    devolver {assert(~t)}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarDevolver: nodo
    devolver {return ~t}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarSi: nodo
    variables cods, subSiVerdadero, subSiFalso

    fijar subSiVerdadero a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiVerdadero}
    fijar subSiFalso a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiFalso}

    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({if ~t then}#formatear: (yo#visitar: nodo#condicional))

    cods#agregarAlFinal: subSiVerdadero#iniciar
    ParaCadaElemento: nodo#siVerdadero, procedimiento: stmt
        cods#agregarAlFinal: (subSiVerdadero#visitar: stmt)
    finprocedimiento

    cods#agregarAlFinal: {else}

    cods#agregarAlFinal: subSiFalso#iniciar
    ParaCadaElemento: nodo#siFalso, procedimiento: stmt
        cods#agregarAlFinal: (subSiFalso#visitar: stmt)
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarMientras: nodo
    variables cods, subyo

    fijar subSiVerdadero a yo#crearSubámbitoDesdeNodo: nodo

    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({while ~t do}#formatear: (yo#visitar: nodo#condicional))

    cods#agregarAlFinal: subyo#iniciar
    ParaCadaElemento: nodo#siVerdadero, procedimiento: stmt
        cods#agregarAlFinal: (subyo#visitar: stmt)
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarMétodo: nodo
    variables clssym, nrdyo, subyo, cuerpoMet
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    fijar clssym a IdentificadorDe: nodo#deClase
    fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    fijar cuerpoMet a subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
    devolver {rt.enviarMensaje(~t, "agregarMetodo", ~t, ~t)}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre), cuerpoMet
finmetodo

metodo CompiladorSimpleALua#visitarAtributos: nodo
    variables clssym, cods
    fijar clssym a IdentificadorDe: nodo#deClase
    fijar cods a Arreglo#vacio
    ParaCadaElemento: nodo#nombres, procedimiento: nodoId
        cods#agregarAlFinal: ({rt.enviarMensaje(~t, "agregarAtributo", ~t)}#formatear: clssym, (EscaparParaLua: nodoId#nombre))
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarUtilizar: nodo
    variables módulo, nombreDelMódulo, mapeoDeImportados, espacioDeNombresResuelto
    si EsInstancia: nodo#módulo, AST#NodoIdentificador
        fijar nombreDelMódulo a nodo#módulo#nombre
    sino
        fijar nombreDelMódulo a nodo#módulo
    finsi
    fijar módulo a yo#_compilador#importarMódulo: nombreDelMódulo

    fijar mapeoDeImportados a Diccionario#vacío
    si no EsNulo: nodo#espacioDeNombres
        fijar espacioDeNombresResuelto a RN#NombreResueltoDe: nodo#espacioDeNombres
    finsi
    si no EsNulo: nodo#nombresEspecíficos
        ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: importado
            variables nombreEnMódulo, nombreFinal
            [ Si importamos la variable "Hola" como "Adios", por ejemplo, con
              `utilizar ejemplo (Hola como Adios)`, entonces nombreEnMódulo es `Hola`
              y nombreFinal es `Adios`. Si esta variable importada no fue renombrada
              (por ejemplo, `utilizar ejemplo (Hola)`) entonces nombreEnMódulo y
              nombreFinal son iguales. ]
            si EsInstancia: importado, AST#NodoIdentificador
                fijar nombreEnMódulo a importado
                fijar nombreFinal a importado
            sino
                fijar nombreEnMódulo a importado#en: 0
                fijar nombreFinal a importado#en: 1
            finsi
            mapeoDeImportados#fijarEn: nombreEnMódulo#nombre, (RN#NombreResueltoDe: nombreFinal)
        finprocedimiento
    finsi
    si (EsNulo: nodo#espacioDeNombres) && (EsNulo: nodo#nombresEspecíficos)
        fijar mapeoDeImportados a
            nodo#obtenerMetadato:
                RN#LLAVE_RESOLUCIÓN_DE_NOMBRES,
                {nombresImportadosResueltos}
    finsi

    variable cods
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({rt.ans_ns = rt.import(~t)}#formatear: (EscaparParaLua: módulo#rutaAlCompilado))
    cods#agregarAlFinal: {;do}
    mapeoDeImportados#paraCadaPar: procedimiento: nombre, id
        cods#agregarAlFinal: ({  _~t = rt.ans_ns:at(~t);}#formatear: id, (EscaparParaLua: nombre))
    finprocedimiento
    cods#agregarAlFinal: {end}
    si no EsNulo: espacioDeNombresResuelto
        cods#agregarAlFinal: ({;_~t = rt.ans_ns;}#formatear: espacioDeNombresResuelto)
    finsi

    devolver (Unir: cods, {~%}#formatear)
finmetodo

metodo CompiladorSimpleALua#visitarIdentificador: nodo
    devolver IdentificadorDe: nodo
finmetodo

metodo CompiladorSimpleALua#visitarNúmeroLiteral: nodo
    devolver nodo#valor
finmetodo

metodo CompiladorSimpleALua#visitarTextoLiteral: nodo
    devolver EscaparParaLua: nodo#valor
finmetodo

metodo CompiladorSimpleALua#enviarMensaje: objeto, mensaje, argumentos
    variables args, argsComoTexto
    fijar args a Mapear: argumentos, funcion: arg
        devolver yo#visitar: arg
    finfuncion
    si args#longitud = 0
        fijar argsComoTexto a {}
    sino
        fijar argsComoTexto a {, }#concatenar: (Unir: args, {, })
    finsi
    devolver {rt.enviarMensaje(~t, ~t~t)}#formatear: objeto, (EscaparParaLua: mensaje), argsComoTexto
finmetodo

metodo CompiladorSimpleALua#visitarLlamarProcedimiento: nodo
    devolver yo#enviarMensaje: (IdentificadorDe: nodo#proc), {llamar}, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarEnviarMensaje: nodo
    devolver yo#enviarMensaje: (yo#visitar: nodo#objeto), nodo#mensaje, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarOperador: nodo
    devolver {rt.enviarMensaje(~t, ~t, ~t)}#formatear:
        (yo#visitar: nodo#lhs),
        (EscaparParaLua: ({operador_~t}#formatear: nodo#op#op)),
        (yo#visitar: nodo#rhs)
finmetodo

metodo CompiladorSimpleALua#visitarNoLlamar: nodo
    variables cod
    si nodo#mensajes#longitud > 0
        fijar cod a Reducir: (yo#visitar: nodo#base), funcion: acc, mensaje
            devolver {rt.enviarMensaje(~t, ~t)}#formatear: acc, (EscaparParaLua: mensaje)
        finfuncion, (PedazoDeArreglo: nodo#mensajes, 0, -1)
        fijar cod a {rt.enviarMensaje(~t, ~t, ...)}#formatear: cod, (ÚltimoElemento: nodo#mensajes)
    sino
        fijar cod a {rt.enviarMensaje(~t, "llamar", ...)}#formatear: (yo#visitar: nodo#base)
    finsi
    devolver {function(...) return ~t end}#formatear: cod
finmetodo

metodo CompiladorSimpleALua#visitarAutoejecutar: nodo
    devolver yo#enviarMensaje: (yo#visitar: nodo#expr), {llamar}, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarFunciónAnónima: nodo
    variable nrdyo, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    si nodo#esMétodo
        fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    sino
        fijar nrdyo a NULO
    finsi
    devolver subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
finmetodo

metodo CompiladorSimpleALua#visitarSonIguales: nodo
    variable igual
    fijar igual a yo#enviarMensaje: (yo#visitar: nodo#lhs), {igualA}, (Arreglo#crearCon: nodo#rhs)
    si nodo#tipoIgualdad = AST#TipoIgualdad#IGUALES
        devolver igual
    sino
        devolver {not ~t}#formatear: igual
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarReferenciar: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarNo: nodo
    devolver {not ~t}#formatear: (yo#visitar: nodo#expresión)
finmetodo

funcion CompilarALua: moddb, ast, ámbito, compilador
    variables comp, ini
    fijar comp a CompiladorSimpleALua#crear: moddb, ámbito, compilador
    fijar ini a comp#iniciar
    devolver {local rt = require "backends.lua.runtime"~%~t~%~t}#formatear: ini, comp#visitar: ast
finfuncion

clase CompiladorALua hereda Compilador#CompiladorBase
    metodo inicializar: db
    metodo compilarAST: ast, ámbito
    metodo importarMódulo: nombreDelMódulo
finclase

metodo CompiladorALua#inicializar: db
    fijar yo#baseDeDatos a db
finmetodo

metodo CompiladorALua#compilarAST: ast, ámbito
    devolver CompilarALua: yo#baseDeDatos, ast, ámbito, yo
finmetodo

metodo CompiladorALua#importarMódulo: nombreDelMódulo
    variables móduloOLlave, móduloCompilado
    fijar móduloOLlave a
        Módulos#ResolverMóduloPorNombre: yo#baseDeDatos, nombreDelMódulo, procedimiento: llave
            devolver llave
        finprocedimiento, procedimiento: mod
            devolver mod
        finprocedimiento, procedimiento
            __FallarConMensaje: ({Error: no se pudo encontrar el módulo ~t}#formatear: nombreDelMódulo)
        finprocedimiento
    si EsInstancia: móduloOLlave, Módulos#Módulo
        devolver móduloOLlave
    sino
        fijar móduloCompilado a yo#compilarTexto:
            móduloOLlave,
            (Archivos#LeerArchivo: móduloOLlave#nombreCompletoDelArchivo)
        yo#baseDeDatos#agregarMódulo: móduloCompilado
        devolver móduloCompilado
    finsi
finmetodo
