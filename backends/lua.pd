utilizar bepd/builtins
utilizar bepd/utilidades/texto
utilizar bepd/x/sistemaDeArchivos/archivo como Archivos

utilizar ast como AST
utilizar caminaNodos como CN

utilizar resoluciónDeNombres como RN

utilizar módulos como Módulos

utilizar compilador como Compilador

[ El backend de Lua está separado en dos partes. Espero, con el tiempo,
  "limpiar" mucho de este código (recuerda que el patrón del visitante ("Visitor
  Pattern") es realmente una manera de hacer "pattern matching" en lenguajes que
  no lo soportan).

  De cualquier forma, las dos partes son:

  - La clase `CompiladosSimpleALua` (hereda `CaminaNodos`): Va por cada nodo
    del AST y lo compila a Lua.
  - La clase `CompiladorALua` (hereda `CompiladorBase`): Compila ASTs, archivos
    y textos. "Orquestra" las operaciones de `CompiladorSimpleALua`.

  Para facilitar las cosas, `CompiladorSimpleALua` tiene un atributo
  `_compilador` que apunta al `CompiladorALua` que lo maneja. ]

[ Nombre código del backend. Véase también la variable del mismo nombre en
  `backends/lua/runtime.lua` y la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Lua Bootstrap}

[DOCUMENTA
@brief{Escapa un texto a Lua válido.}

@pd{texto} es una instancia de @pd{Texto}. Escapa todos los carácteres
especiales de @pd{texto} y lo envuelve en comillas, de forma que el texto
devuelto es una literal textual (string) válida para Lua.
DOCUMENTA]
funcion EscaparParaLua: texto
    variable res
    fijar res a {"} [ " ]
    ParaCadaElemento: texto, procedimiento: car
        si car = {"} [ " ]
            fijar res a res#concatenar: {\"} [ " ]
        sino
            si car = {~%}#formatear
                fijar res a res#concatenar: {\n}
            sino
                si car = {\}
                    fijar res a res#concatenar: {\\}
                sino
                    fijar res a res#concatenar: car
                finsi
            finsi
        finsi
    finprocedimiento
    devolver res#concatenar: {"} [ " ]
finfuncion

[ Por limitaciones de Lua, no se pueden tener más de 200 variables locales en
  cualquier ámbito de Lua. Lamentablemente son necesarias más de 200 variables
  locales para compilar PseudoD. La solución que utilizé es que en vez de crear
  variables locales, creo una sola llamada "_s" que es un "scope" (runtime.lua
  contiene la implementación en la función "M.scope"). Cada variable de PseudoD
  es un campo de la forma "_" + binding en la tabla "_s". Por ejemplo, la
  variable con el binding 5 está en "_s._5". ]

[DOCUMENTA
@brief{Obtiene el identificador en Lua de un nombre.}

@pd{id} debe ser un nodo identificador.
DOCUMENTA]
funcion IdentificadorDe: id
    devolver {_s._}#concatenar: (RN#NombreResueltoDe: id)#comoTexto
finfuncion

[ Tal como en resoluciónDeNombres.pd, una subclase de CN#CaminaNodos es
  utilizada para compilar el código. La clase "CompiladorSimpleALua" es solo un
  detalle de implementación y nunca se debería usar fuera de este módulo.

  Los métodos "visitarXYZ" siempre devuelven el código Lua compilado como un
  texto. De forma que "caminante#visitar: ast" devuelve todo el programa Lua
  asumiendo que "ast" es un NodoPrograma y "caminante" una instancia de
  CompiladorSimpleALua.

  El compilado devuelto solo incluye al módulo. En la práctica estos compilados
  no son ejecutados directamente sino que son envueltos en funciones de lua
  para que queden de la forma "function() ...COMPILADO... end" y estas
  funciones son registradas con el runtime para que "utilizar" pueda resolver
  los nombres. Más abajo hay un comentario que explica todos los conceptos del
  runtime. También míra el método "compilarTodo". ]

clase CompiladorSimpleALua hereda CN#CaminaNodos
    metodo crearSubámbitoDesdeNodo: nodo
    metodo crearSubámbitoDesdeNombreEnNodo: nodo, llave

    metodo inicializar: moddb, ámbito, compilador

    metodo iniciar
    metodo registrarBuiltins

    metodo esBuiltin: nombre, binding
finclase

atributos CompiladorSimpleALua#_ámbito, [ Ámbito actual ]
          CompiladorSimpleALua#_moddb, [ Base de datos de módulos ]
          CompiladorSimpleALua#_compilador [ `CompiladorALua` que esta compilando ]

[DOCUMENTA
@brief{Crea un @pd{CompiladorSimpleALua} que es un subámbito del actual.}

Representa el ámbito de @pd{nodo}. Es un subámbito del actual.
DOCUMENTA]
metodo CompiladorSimpleALua#crearSubámbitoDesdeNodo: nodo
    devolver yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídos}
finmetodo

[DOCUMENTA
@brief{Crea un subámbito desde un nodo.}

@pd{nodo} es el nodo cuyo ámbito será usado. @pd{llave} es el nombre del
metadato que será leído. Este parámetro es configurable ya que los
condicionales "si" tienen dos llaves "nombresDefinídosSiVerdadero" y
"nombresDefinídosSiFalso" en vez de "nombresDefinídos" (que es el común).

Devuelve el subámbito (otra instancia de @pd{CompiladorSimpleALua}).
DOCUMENTA]
metodo CompiladorSimpleALua#crearSubámbitoDesdeNombreEnNodo: nodo, llave
    devolver CompiladorSimpleALua#crear:
                 yo#_moddb,
                 (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, llave),
                 yo#_compilador
finmetodo

metodo CompiladorSimpleALua#inicializar: moddb, ámbito, compilador
    fijar yo#_ámbito a ámbito
    fijar yo#_moddb a moddb
    fijar yo#_compilador a compilador
finmetodo

[

El Runtime y la estructura del compilador:

- En tiempo de ejecución, números, textos, funciones, booles y el valor nulo
  tienen la representación en Lua que esperarías: números pasan a ser "number"
  (Lua 5.4 garantiza números tanto enteros como reales, tal como
  PseudoD). Booles pasan a ser "true" y "false". Nulo pasa a ser
  "nil". Funciones y procedimientos pasan a ser "functions".

- Como ya fue explicado antes, las variables locales pasan a ser campos en una
  tabla "_s".

- Enviar un mensaje a un objeto se realiza con la operación
  "rt.enviarMensaje". Esta automaticamente detecta el tipo del receptor y
  implementa algunos métodos sobre funciones, textos, etc. Enviar un mensaje
  donde el número de argumentos no se conoce sino hasta el tiempo de ejecución
  (por ejemplo, en "Sumar: 1, 2, ...x, ...y") se realiza con
  "rt.enviarMensajeV".

- Los espacios de nombres son implementados con "rt.ns". Al final de cada
  módulo, "rt.ns" es llamado con todos los nombres definídos (y algunos datos
  más) y este devuelve el espacio de nombres.

- Los arreglos son creados con "rt.arreglo", "rt.mkarreglo" y demás.

- Llamar a "rt.enviarMensaje" con los parámetros apropiados y escapando todo no
  es trivial, así que el método "enviarMensaje: objeto, mensaje, argumentos" se
  encarga de esto. Este automáticamente compila "argumentos" (que debe ser una
  lista de nodos de expresión), se encarga de los nodos variadic opcionales en
  "argumentos", llama automaticamente a "rt.enviarMensaje" o
  "rt.enviarMensajeV" y escapa el mensaje a enviar. "objeto" es el objeto al
  que se le enviará un mensaje. Nota que aunque los "argumentos" sean visitados
  (es decir, compilados), "objeto" no lo es, ese parámetro ya debe ser un texto
  que represente una expresión de Lua válida.

- El código generado siempre tiene puntos-y-comas separando las instrucciones.

- Un patrón muy común es el de crear un arreglo de texto llamado "cods" (para
  "códigos") e irlo llenando de textos para luego devolver "Unir: cods,
  {;~%}#formatear".

- Al compilar un NodoPrograma, el espacio de nombres es devuelto (con "return")
  desde el chunk de lua. "CompiladorALua#compilarTodo" contiene la
  implementación pero en realidad luego de compilar todos los módulos, sus
  compilados son envueltos en otras funciones de forma que cada módulo termina
  de la forma:

      rt.modulos.("./ruta/completa/al/módulo.pd") = function()
         ...TODO EL COMPILADO...
      end

   (reemplaza ".(XYZ)" por corchetes, recuerda que no se pueden poner corchetes
   en comentarios en PseudoD).

   De esta forma, el espacio de nombres devuelto por el compilado de un
   NodoPrograma termina siendo el "return" de la función asignada a la tabla
   "rt.modulos". Esto es debido a que este backend no compila cada módulo a un
   archivo de Lua distínto, sino que los compila todos a un único archivo
   enorme. Para esto "runtime.lua" también incluye una implementación sencilla
   de un sistema de módulos similar al de lua, solo que en vez de tener los
   módulos en archivos son funciones en "rt.modulos" y en vez de usar "require"
   usas "rt.importar" (o "rt.import", son aliases).

Creo que todo esto es lo necesario para entender este backend. A parte de esto,
no es muy complicado, más que todo un monton de llamadas a "formatear" para
concatenar textos.

]

[ Este método es llamado al inicio de cada ámbito. Inicializa variables
  importantes del runtime (como "_s"). ]
metodo CompiladorSimpleALua#iniciar
    variables res, padre
    fijar res a Arreglo#vacio
    si no EsNulo: yo#_ámbito#ámbitoPadre
        fijar padre a {_s}
    sino
        fijar padre a {}
    finsi
    res#agregarAlFinal: ({local _s = rt.scope(~t)}#formatear: padre)
    ParaCadaElemento: yo#_ámbito#todosLosBindingsLocales, procedimiento: id
        res#agregarAlFinal: ({rt.scopenewname(_s, "_~t");}#formatear: id)
    finprocedimiento
    devolver Unir: res, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#registrarBuiltins
    variable cods
    fijar cods a Arreglo#vacio
    yo#_compilador#_builtins#paraCadaPar: procedimiento: nombreEnRT, binding
        cods#agregarAlFinal: ({_s._~t = rt.builtins[~t];}#formatear: binding, (EscaparParaLua: nombreEnRT))
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#esBuiltin: nombre, binding
    devolver (yo#_compilador#_builtins#en: nombre) = binding
finmetodo

metodo CompiladorSimpleALua#visitarPrograma: nodo
    variables instrs, ámbito
    fijar instrs a Arreglo#vacio
    ParaCadaElemento: nodo#instrucciones, procedimiento: instr
        instrs#agregarAlFinal: ((yo#visitar: instr)#concatenar: {;})
    finprocedimiento
    fijar ámbito a RN#ObtenerNombresDefinídos: nodo
    instrs#agregarAlFinal: {return rt.ns({}#formatear
    ámbito#paraCadaVariable: procedimiento: nombre, dv
        instrs#agregarAlFinal: ({  [~t] = { value = _s._~t, autoexecutable = ~t ~e,}#formatear:
            (EscaparParaLua: nombre),
            dv#binding,
            (dv#esAutoejecutable#escojer: {true}, {false}))
    finprocedimiento
    instrs#agregarAlFinal: {~e);}#formatear
    devolver Unir: instrs, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarVariable: nodo
    devolver {}
finmetodo

metodo CompiladorSimpleALua#visitarFijar: nodo
    si EsInstancia: nodo#objetivo, AST#NodoIdentificador
        variables obj, expr
        fijar obj a IdentificadorDe: nodo#objetivo
        fijar expr a yo#visitar: nodo#valor
        devolver {~t = (~t);}#formatear: obj, expr
    sino
        necesitas EsInstancia: nodo#objetivo, AST#NodoEnviarMensaje
        necesitas nodo#objetivo#argumentos#longitud = 0
        variable base, fieldname
        fijar base a yo#visitar: nodo#objetivo#objeto
        fijar fieldname a {fijar_}#concatenar: nodo#objetivo#mensaje
        devolver yo#enviarMensaje: base, fieldname, (Arreglo#crearCon: nodo#valor)
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarEscribir: nodo
    devolver {rt.escribir(~t);}#formatear: (yo#visitar: nodo#valor)
finmetodo

metodo CompiladorSimpleALua#visitarNl: nodo
    devolver {rt.nl();}
finmetodo

metodo CompiladorSimpleALua#visitarClase: nodo
    variables cods, clssym, base
    fijar clssym a IdentificadorDe: nodo#nombre
    fijar cods a Arreglo#vacio
    si no EsNulo: nodo#claseBase
        fijar base a yo#visitar: nodo#claseBase
    sino
        fijar base a {rt.clases.Objeto}
    finsi
    cods#agregarAlFinal: ({~t = (~t);}#formatear: clssym, (yo#enviarMensaje: ({(~t)}#formatear: base), {subclase}, Arreglo#vacio))
    cods#agregarAlFinal: ({rt.enviarMensaje(~t, "fijar_nombre", ~t);}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre))
    ParaCadaElemento: nodo#declaraciones, procedimiento: declr
        si EsInstancia: declr, AST#NodoDeclaraciónDeAtributosEnClase
            cods#agregarAlFinal: ((yo#visitar: (clonar AST#NodoAtributos#crear con
                areaTextual: declr#areaTextual
                deClase: nodo#nombre
                nombres: declr#nombres
            finclonar))#concatenar: {;})
        sino
            [ Nada que hacer para los NodoDeclaraciónDeMétodoEnClase ]
        finsi
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeAtributosEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeMétodoEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarImplementa: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineAtributosEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineMétodoEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#expresiónDeFunción: nombreResueltoDeYo, parámetros, cuerpo
    variables cods, params, variadic, met, paramsbody
    fijar cods a Arreglo#vacio
    fijar variadic a NULO

    funcion CódigoDeParam: param
        si EsInstancia: param, AST#NodoIdentificador
            devolver {_~t}#formatear: (RN#NombreResueltoDe: param)
        sino
            fijar variadic a param
            devolver {...}
        finsi
    finfuncion

    fijar params a Unir: (Mapear: parámetros, &CódigoDeParam), {, }

    si no EsNulo: nombreResueltoDeYo
        fijar met a {_~t}#formatear: nombreResueltoDeYo
        si parámetros#longitud > 0
            fijar params a {, }#concatenar: params
        finsi
    sino
        fijar met a {}
    finsi

    funcion CódigoDeParamBody: param
        si EsInstancia: param, AST#NodoIdentificador
            devolver {rt.scopenewname(_s, "_~t"); ~t = _~t}#formatear: (RN#NombreResueltoDe: param), (IdentificadorDe: param), (RN#NombreResueltoDe: param)
        sino
            devolver {rt.scopenewname(_s, "_~t")}#formatear: (RN#NombreResueltoDe: param#interno)
        finsi
    finfuncion

    fijar paramsbody a Unir: (Mapear: parámetros, &CódigoDeParamBody), {;~%}#formatear

    si no EsNulo: nombreResueltoDeYo
        fijar paramsbody a paramsbody#concatenar:
            ({~%;rt.scopenewname(_s, "_~t"); _s._~t = _~t}#formatear:
                nombreResueltoDeYo, nombreResueltoDeYo, nombreResueltoDeYo)
    finsi

    cods#agregarAlFinal: ({function(~t~t)}#formatear: met, params)
    cods#agregarAlFinal: yo#iniciar
    cods#agregarAlFinal: (paramsbody#concatenar: {;})
    si no EsNulo: variadic
        [ Los parámetros no son declarados al principio de las
          funciones/métodos/procedimientos. Por esto debemos declarar este
          manualmente. ]
        cods#agregarAlFinal: ({~t = rt.arreglo(...)}#formatear: (IdentificadorDe: variadic#interno))
    finsi

    ParaCadaElemento: cuerpo, procedimiento: stmt
        cods#agregarAlFinal: ((yo#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarFunción: nodo
    variables cods, id, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    fijar id a IdentificadorDe: nodo#nombre
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({~t = (~t);}#formatear:
        id,
        (subyo#expresiónDeFunción: NULO, nodo#parámetros, nodo#cuerpo)
    )
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarNecesitas: nodo
    devolver {assert(~t);}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarDevolver: nodo
    devolver {do return ~t; end;}#formatear: (yo#visitar: nodo#expresión)
finmetodo

clase ComparaciónDeBuiltin
    atributos tipoIgualdad, rhs
finclase

[DOCUMENTA
@brief{Trata de separar una comparación de un builtin con una literal en sus
partes.}

@pd{nodo} es un @pd{AST#NodoExpresion}. @pd{rnBuiltin} debe ser el binding del
builtin que se quiere saber si compara.

Si nodo corresponde al AST generado para expresiones de la forma
@pd{BUILTIN = LIT}, @pd{son iguales BUILTIN y LIT} o
@pd{son diferentes BUILTIN y LIT}, donde @pd{BUILTIN} es el builtin
identificado por @pd{rnBuiltin} y @pd{LIT} es cualquier literal textual o
numérica. devuelve una instancia de @pd{ComparaciónDeBuiltin} donde
@pd{tipoIgualdad} es uno de los valores de la enumeración @pd{AST#TipoIgualdad}
y @pd{rhs} es el valor de la literal (un @pd{Texto} si era una literal textual
o un @pd{Numero} si era una literal numérica).

Si @pd{nodo} no tiene ninguno de esos patrones, devuelve @pd{FALSO}.
DOCUMENTA]
funcion SepararComparaciónDeBuiltin: nodo, rnBuiltin
    variables lhs, rhs, op
    si EsInstancia: nodo, AST#NodoOperador
        fijar lhs a nodo#lhs
        fijar rhs a nodo#rhs
        si nodo#op#texto = {=}
            fijar op a AST#TipoIgualdad#IGUALES
        sino
            devolver FALSO
        finsi
    sino
        si EsInstancia: nodo, AST#NodoSonIguales
            fijar lhs a nodo#lhs
            fijar rhs a nodo#rhs
            si nodo#tipoIgualdad = AST#TipoIgualdad#IGUALES
                fijar op a AST#TipoIgualdad#IGUALES
            sino
                fijar op a AST#TipoIgualdad#DIFERENTES
            finsi
        sino
            devolver FALSO
        finsi
    finsi
    si no (EsInstancia: lhs, AST#NodoIdentificador)
        devolver FALSO
    finsi
    si no (RN#NombreResueltoDe: lhs) = rnBuiltin
        devolver FALSO
    finsi
    variable valorRhs
    si EsInstancia: rhs, AST#NodoTextoLiteral
        fijar valorRhs a rhs#valor
    sino
        si EsInstancia: rhs, AST#NodoNumeroLiteral
            fijar valorRhs a rhs#valor
        sino
            devolver FALSO
        finsi
    finsi
    devolver clonar ComparaciónDeBuiltin#crear con
        tipoIgualdad: op
        rhs: valorRhs
    finclonar
finfuncion

metodo CompiladorSimpleALua#visitarSi: nodo
    variables cods, subSiVerdadero, subSiFalso

    fijar cods a Arreglo#vacio
    fijar subSiVerdadero a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiVerdadero}
    fijar subSiFalso a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiFalso}

    procedimiento CompilarBloque: nodos, sub
        cods#agregarAlFinal: sub#iniciar
        ParaCadaElemento: nodos, procedimiento: stmt
            cods#agregarAlFinal: ((sub#visitar: stmt)#concatenar: {;})
        finprocedimiento
    finprocedimiento

    [ Si se compara directamente __Impl con una literal de texto igual a
      PSEUDOD_IMPL, entonces compila únicamente la rama que sabemos que
      pasará. ]
    variable cmp
    fijar cmp a SepararComparaciónDeBuiltin: nodo#condicional, (yo#_compilador#_builtins#en: {__Impl})
    si EsInstancia: cmp, ComparaciónDeBuiltin
        cods#agregarAlFinal: {;do;}
        si cmp#tipoIgualdad = AST#TipoIgualdad#IGUALES
            si cmp#rhs = PSEUDOD_IMPL
                CompilarBloque: nodo#siVerdadero, subSiVerdadero
            sino
                CompilarBloque: nodo#siFalso, subSiFalso
            finsi
        sino
            si cmp#rhs = PSEUDOD_IMPL
                CompilarBloque: nodo#siFalso, subSiFalso
            sino
                CompilarBloque: nodo#siVerdadero, subSiVerdadero
            finsi
        finsi
        cods#agregarAlFinal: {;end;}
    sino
        cods#agregarAlFinal: ({if ~t then}#formatear: (yo#visitar: nodo#condicional))
        CompilarBloque: nodo#siVerdadero, subSiVerdadero
        cods#agregarAlFinal: {else}
        CompilarBloque: nodo#siFalso, subSiFalso
        cods#agregarAlFinal: {end}
    finsi

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarMientras: nodo
    variables cods, subyo

    fijar subyo a yo#crearSubámbitoDesdeNodo: nodo

    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({while ~t do}#formatear: (yo#visitar: nodo#condicional))

    cods#agregarAlFinal: subyo#iniciar
    ParaCadaElemento: nodo#cuerpo, procedimiento: stmt
        cods#agregarAlFinal: ((subyo#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarMétodo: nodo
    variables clssym, nrdyo, subyo, cuerpoMet
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    fijar clssym a IdentificadorDe: nodo#deClase
    fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    fijar cuerpoMet a subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
    si nodo#esEstático
        devolver {(~t).methods[~t] = ~t}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre), cuerpoMet
    sino
        devolver {rt.enviarMensaje(~t, "agregarMetodo", ~t, ~t);}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre), cuerpoMet
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarAtributos: nodo
    variables clssym, cods
    fijar clssym a IdentificadorDe: nodo#deClase
    fijar cods a Arreglo#vacio
    ParaCadaElemento: nodo#nombres, procedimiento: nodoId
        cods#agregarAlFinal: ({rt.enviarMensaje(~t, "agregarAtributo", ~t);}#formatear: clssym, (EscaparParaLua: nodoId#nombre))
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarUtilizar: nodo
    variables módulo, nombreDelMódulo, mapeoDeImportados, espacioDeNombresResuelto
    si EsInstancia: nodo#módulo, AST#NodoIdentificador
        fijar nombreDelMódulo a nodo#módulo#nombre
    sino
        fijar nombreDelMódulo a nodo#módulo
    finsi
    fijar módulo a yo#_compilador#importarMódulo: nombreDelMódulo

    fijar mapeoDeImportados a Diccionario#vacío
    si no EsNulo: nodo#espacioDeNombres
        fijar espacioDeNombresResuelto a RN#NombreResueltoDe: nodo#espacioDeNombres
    finsi
    si no EsNulo: nodo#nombresEspecíficos
        ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: importado
            variables nombreEnMódulo, nombreFinal
            [ Si importamos la variable "Hola" como "Adios", por ejemplo, con
              `utilizar ejemplo (Hola como Adios)`, entonces nombreEnMódulo es `Hola`
              y nombreFinal es `Adios`. Si esta variable importada no fue renombrada
              (por ejemplo, `utilizar ejemplo (Hola)`) entonces nombreEnMódulo y
              nombreFinal son iguales. ]
            si EsInstancia: importado, AST#NodoIdentificador
                fijar nombreEnMódulo a importado
                fijar nombreFinal a importado
            sino
                fijar nombreEnMódulo a importado#en: 0
                fijar nombreFinal a importado#en: 1
            finsi
            mapeoDeImportados#fijarEn: nombreEnMódulo#nombre, (RN#NombreResueltoDe: nombreFinal)
        finprocedimiento
    finsi
    si (EsNulo: nodo#espacioDeNombres) && (EsNulo: nodo#nombresEspecíficos)
        fijar mapeoDeImportados a
            nodo#obtenerMetadato:
                RN#LLAVE_RESOLUCIÓN_DE_NOMBRES,
                {nombresImportadosResueltos}
    finsi

    variable cods
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({rt.ans_ns = rt.import(~t)}#formatear: (EscaparParaLua: módulo#llave#nombreCompletoDelArchivo))
    cods#agregarAlFinal: {;do}
    mapeoDeImportados#paraCadaPar: procedimiento: nombre, id
        cods#agregarAlFinal: ({  _s._~t = rt.ans_ns:at(~t);}#formatear: id, (EscaparParaLua: nombre))
    finprocedimiento
    cods#agregarAlFinal: {end}
    si no EsNulo: espacioDeNombresResuelto
        cods#agregarAlFinal: ({;_s._~t = rt.ans_ns;}#formatear: espacioDeNombresResuelto)
    finsi

    devolver (Unir: cods, {~%}#formatear)
finmetodo

metodo CompiladorSimpleALua#visitarIdentificador: nodo
    variables esAutoejecutable, identificador
    si nodo#contieneMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
        fijar esAutoejecutable a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
    sino
        fijar esAutoejecutable a FALSO
    finsi
    fijar identificador a IdentificadorDe: nodo
    si esAutoejecutable
        devolver yo#enviarMensaje: identificador, {llamar}, Arreglo#vacio
    sino
        devolver identificador
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarNúmeroLiteral: nodo
    devolver nodo#valor
finmetodo

metodo CompiladorSimpleALua#visitarTextoLiteral: nodo
    devolver EscaparParaLua: nodo#valor
finmetodo

[DOCUMENTA
@brief{Compila un envío de un mensaje.}

@params(
@defparam(objeto){Un texto que es una expresión Lua válida. El mensaje será
enviado a el objeto resultante.}

@defparam(mensaje){Un texto, el mensaje a enviar. Será escapado con
@pd{EscaparParaLua}.}

@defparam(argumentos){Una lista de NodoExpresion que puede contener varios
NodoVariadic (o ninguno).}
)

@devuelve{Una llamada adecuada a "rt.enviarMensaje" o "rt.enviarMensajeV".}
DOCUMENTA]
metodo CompiladorSimpleALua#enviarMensaje: objeto, mensaje, argumentos
    variables args, argsComoTexto, funciónParaEnviarMensaje

    fijar args a Arreglo#vacio
    ParaCadaElemento: argumentos, procedimiento: arg
        si EsInstancia: arg, AST#NodoVariadic
            args#agregarAlFinal: arg
        sino
            si args#longitud = 0
                args#agregarAlFinal: Arreglo#vacio
            sino
                si EsInstancia: (ÚltimoElemento: args), AST#NodoVariadic
                    args#agregarAlFinal: Arreglo#vacio
                finsi
            finsi
            (ÚltimoElemento: args)#agregarAlFinal: arg
        finsi
    finprocedimiento

    funcion CompilarArgumentosSimples: args
        devolver Unir: (Mapear: args, funcion: x devolver yo#visitar: x finfuncion), {, }
    finfuncion

    fijar funciónParaEnviarMensaje a NULO
    si args#longitud = 1
        si EsInstancia: (args#en: 0), Arreglo
            fijar argsComoTexto a CompilarArgumentosSimples: (args#en: 0)
            fijar funciónParaEnviarMensaje a {enviarMensaje}
        finsi
    finsi
    si EsNulo: funciónParaEnviarMensaje
        fijar funciónParaEnviarMensaje a {enviarMensajeV}
        fijar argsComoTexto a Unir: (Mapear: args, funcion: arg
            si EsInstancia: arg, AST#NodoVariadic
                devolver yo#visitar: arg#interno
            sino
                devolver {{ __pd_var=true, n=~t, ~t ~e}#formatear: arg#longitud, (CompilarArgumentosSimples: arg)
            finsi
        finfuncion), {, }
    finsi
    si argsComoTexto#longitud > 0
        fijar argsComoTexto a {, }#concatenar: argsComoTexto
    finsi

    devolver {rt.~t(~t, ~t~t)}#formatear: funciónParaEnviarMensaje, objeto, (EscaparParaLua: mensaje), argsComoTexto
finmetodo

metodo CompiladorSimpleALua#visitarLlamarProcedimiento: nodo
    si yo#esBuiltin: {__Lua}, (RN#NombreResueltoDe: nodo#proc)
        devolver yo#compilarBuiltinLua: nodo
    finsi
    devolver yo#enviarMensaje: (IdentificadorDe: nodo#proc), {llamar}, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#compilarBuiltinLua: nodo
    necesitas nodo#argumentos#longitud >= 1
    variables arg, argumentosEvaluados
    fijar arg a nodo#argumentos#en: 0
    necesitas EsInstancia: arg, AST#NodoTextoLiteral
    fijar argumentosEvaluados a
        Mapear:
            (PedazoDeArreglo: nodo#argumentos, 1, -1),
            funcion: x
                si EsInstancia: x, AST#NodoVariadic
                    __FallarConMensaje: {No se puede pasar un variadic a un builtin}
                finsi
                devolver yo#visitar: x
            finfuncion
    devolver {((~t)(~t))}#formatear: arg#valor, (Unir: argumentosEvaluados, {, })
finmetodo

metodo CompiladorSimpleALua#visitarEnviarMensaje: nodo
    devolver yo#enviarMensaje: (yo#visitar: nodo#objeto), nodo#mensaje, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarOperador: nodo
    devolver {rt.enviarMensaje(~t, ~t, ~t)}#formatear:
        (yo#visitar: nodo#lhs),
        (EscaparParaLua: ({operador_~t}#formatear: nodo#op#op)),
        (yo#visitar: nodo#rhs)
finmetodo

metodo CompiladorSimpleALua#visitarNoLlamar: nodo
    variable base
    si EsInstancia: nodo#base, AST#NodoIdentificador
        fijar base a IdentificadorDe: nodo#base
    sino
        fijar base a yo#visitar: nodo#base
    finsi
    si nodo#mensajes#longitud > 0
        variable cod
        fijar cod a Reducir: base, funcion: acc, mensaje
            devolver {rt.enviarMensaje(~t, ~t)}#formatear: acc, (EscaparParaLua: mensaje#texto)
        finfuncion, (PedazoDeArreglo: nodo#mensajes, 0, -2)
        fijar cod a {rt.enviarMensaje(~t, ~t, ...)}#formatear: cod, (EscaparParaLua: (ÚltimoElemento: nodo#mensajes)#texto)
        devolver {function(...) return ~t end}#formatear: cod
    sino
        devolver base
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarAutoejecutar: nodo
    devolver yo#enviarMensaje: (yo#visitar: nodo#expr), {llamar}, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarFunciónAnónima: nodo
    variable nrdyo, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    si nodo#esMétodo
        fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    sino
        fijar nrdyo a NULO
    finsi
    devolver subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
finmetodo

metodo CompiladorSimpleALua#visitarSonIguales: nodo
    variable igual
    fijar igual a yo#enviarMensaje: (yo#visitar: nodo#lhs), {igualA}, (Arreglo#crearCon: nodo#rhs)
    si nodo#tipoIgualdad = AST#TipoIgualdad#IGUALES
        devolver igual
    sino
        devolver {not ~t}#formatear: igual
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarReferenciar: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarNo: nodo
    devolver {not ~t}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarClonar: nodo
    variable tabla
    fijar tabla a {{~t~e}#formatear:
        (Unir:
            (Mapear: nodo#campos, funcion: res
                devolver {[~t] = ~t}#formatear: (EscaparParaLua: (res#en: 0)), (yo#visitar: (res#en: 1))
            finfuncion),
            {, })
    devolver {rt.clonar(~t, ~t)}#formatear: (yo#visitar: nodo#expresiónAClonar), tabla
finmetodo

metodo CompiladorSimpleALua#visitarVariadic: nodo
    Inalcanzable
finmetodo

[DOCUMENTA
@brief{Compila un AST a Lua.}

@params(
@defparam(moddb){La base de datos de módulos a utilizar.}

@defparam(ast){El @pd{AST#NodoPrograma} a compilar.}

@defparam(ámbito){El ámbito global como fue devuelto por
@pd{RN#ResolverNombres}.}

@defparam(compilador){La instancia de @pd{CompiladorALua} que esta compilando
el programa.}
)

@devuelve{Un texto que es el código lua compilado.}
DOCUMENTA]
funcion CompilarALua: moddb, ast, ámbito, compilador
    variables comp, ini, builtins
    fijar comp a CompiladorSimpleALua#crear: moddb, ámbito, compilador
    fijar ini a comp#iniciar
    fijar builtins a comp#registrarBuiltins
    devolver {local rt = require "backends.lua.runtime";~%~t~%~t~%~t}#formatear: ini, builtins, (comp#visitar: ast)
finfuncion

[DOCUMENTA
@brief{El backend a Lua.}
DOCUMENTA]
clase CompiladorALua hereda Compilador#CompiladorBase
    [DOCUMENTA
    @brief{Inicializa la instancia del backend.}

    @pd{db} es la base de datos de módulos a usar.
    DOCUMENTA]
    metodo inicializar: db

    metodo compilarAST: ast, ámbito
    metodo importarMódulo: nombreDelMódulo
    metodo inyectarNombresEnÁmbito: ámbito

    [DOCUMENTA
    @brief{Compila todos los módulos.}

    Toma todos los módulos de la base de datos de módulos y los une en un solo
    programa en lua que contiene todo el programa, listo para ser ejecutado.

    @pd{llavePrincipal} es la llave del módulo que será importado
    automaticamente al inicio del programa en Lua. Este módulo básicamente será
    el "principal".

    Devuelve el programa compilado como un texto.
    DOCUMENTA]
    metodo compilarTodo: llavePrincipal
finclase

atributo CompiladorALua#_builtins, CompiladorALua#_builtinsAutoejecutables

metodo CompiladorALua#inicializar: db
    fijar yo#baseDeDatos a db
    fijar yo#_builtins a
        Diccionario#desdePares:
            {Objeto}, RN#GenerarIdDeNombre,
            {VERDADERO}, RN#GenerarIdDeNombre,
            {FALSO}, RN#GenerarIdDeNombre,
            {NULO}, RN#GenerarIdDeNombre,
            {Aplicar}, RN#GenerarIdDeNombre,
            {ProcedimientoVarargs}, RN#GenerarIdDeNombre,
            {TipoDe}, RN#GenerarIdDeNombre,
            {__EnviarMensaje}, RN#GenerarIdDeNombre,
            {__FallarConMensaje}, RN#GenerarIdDeNombre,
            {__ClonarObjeto}, RN#GenerarIdDeNombre,
            {__CompararObjeto}, RN#GenerarIdDeNombre,
            {__AbrirArchivo}, RN#GenerarIdDeNombre,
            {__ByteATexto}, RN#GenerarIdDeNombre,
            {__TextoAByte}, RN#GenerarIdDeNombre,
            {__ByteEof}, RN#GenerarIdDeNombre,
            {__Capturar}, RN#GenerarIdDeNombre,
            {__Argv}, RN#GenerarIdDeNombre,
            {__LeerCaracter}, RN#GenerarIdDeNombre,
            {__Impl}, RN#GenerarIdDeNombre,

            {Boole}, RN#GenerarIdDeNombre,
            {Numero}, RN#GenerarIdDeNombre,
            {Arreglo}, RN#GenerarIdDeNombre,
            {Procedimiento}, RN#GenerarIdDeNombre,
            {Texto}, RN#GenerarIdDeNombre,
            {EspacioDeNombres}, RN#GenerarIdDeNombre,
            {Referencia}, RN#GenerarIdDeNombre,
            {TipoNulo}, RN#GenerarIdDeNombre,
            {__Lua}, RN#GenerarIdDeNombre
    fijar yo#_builtinsAutoejecutables a
        Arreglo#crearCon:
            {__Lua}, {Aplicar}, {ProcedimientoVarargs}, {TipoDe},
            {__EnviarMensaje}, {__FallarConMensaje}, {__ClonarObjeto},
            {__CompararObjeto}, {__AbrirArchivo}, {__ByteATexto},
            {__TextoAByte}, {__ByteEof}, {__Capturar}, {__LeerCaracter}
finmetodo

metodo CompiladorALua#compilarAST: ast, ámbito
    devolver CompilarALua: yo#baseDeDatos, ast, ámbito, yo
finmetodo

metodo CompiladorALua#importarMódulo: nombreDelMódulo
    variables móduloOLlave, móduloCompilado
    fijar móduloOLlave a
        Módulos#ResolverMóduloPorNombre: yo#baseDeDatos, nombreDelMódulo, procedimiento: llave
            devolver llave
        finprocedimiento, procedimiento: mod
            devolver mod
        finprocedimiento, procedimiento
            __FallarConMensaje: ({Error: no se pudo encontrar el módulo ~t}#formatear: nombreDelMódulo)
        finprocedimiento
    Escribir: ({--- Buscando: ~t}#formatear: nombreDelMódulo)
    si EsInstancia: móduloOLlave, Módulos#Módulo
        Escribir: {--- Encontrado}
        devolver móduloOLlave
    sino
        Escribir: {--- No encontrado, compilandolo}
        fijar móduloCompilado a yo#compilarTexto:
            móduloOLlave,
            (Archivos#LeerArchivo: móduloOLlave#nombreCompletoDelArchivo)
        yo#baseDeDatos#agregarMódulo: móduloCompilado
        devolver móduloCompilado
    finsi
finmetodo

metodo CompiladorALua#inyectarNombresEnÁmbito: ámbito
    yo#_builtins#paraCadaPar: procedimiento: nombreEnRT, binding
        ámbito#agregar: nombreEnRT, binding
    finprocedimiento
    ParaCadaElemento: yo#_builtinsAutoejecutables, procedimiento: nombre
        ámbito#marcarComoAutoejecutable: nombre
    finprocedimiento
finmetodo

metodo CompiladorALua#removerNombresDeÁmbito: ámbito
    yo#_builtins#paraCadaPar: procedimiento: nombreEnRT, _binding
        ámbito#eliminarNombre: nombreEnRT
    finprocedimiento
finmetodo

metodo CompiladorALua#compilarTodo: llavePrincipal
    variables móduloPrincipal, cods
    fijar móduloPrincipal a yo#baseDeDatos#buscarMóduloPorLlave: llavePrincipal
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: {local rt = require "backends.lua.runtime";}
    yo#baseDeDatos#paraCadaMódulo: procedimiento: módulo
        cods#agregarAlFinal: ({rt.modulos[~t] = function()~%~t~%end;}#formatear: (EscaparParaLua: módulo#llave#nombreCompletoDelArchivo), módulo#compilado)
    finprocedimiento
    cods#agregarAlFinal: ({;rt.importar(~t);}#formatear: (EscaparParaLua: llavePrincipal#nombreCompletoDelArchivo))
    devolver Unir: cods, {~%}#formatear
finmetodo
