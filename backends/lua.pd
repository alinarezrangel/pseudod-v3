utilizar bepd/builtins
utilizar bepd/utilidades/texto
utilizar bepd/x/sistemaDeArchivos/archivo como Archivos

utilizar ast como AST
utilizar caminaNodos como CN

utilizar resoluciónDeNombres como RN

utilizar módulos como Módulos

utilizar compilador como Compilador

[ El backend de Lua está separado en dos partes. Espero, con el tiempo,
  "limpiar" mucho de este código (recuerda que el patrón del visitante ("Visitor
  Pattern") es realmente una manera de hacer "pattern matching" en lenguajes que
  no lo soportan).

  De cualquier forma, las dos partes son:

  - La clase `CompiladosSimpleALua` (hereda `CaminaNodos`): Va por cada nodo
    del AST y lo compila a Lua.
  - La clase `CompiladorALua` (hereda `CompiladorBase`): Compila ASTs, archivos
    y textos. "Orquestra" las operaciones de `CompiladorSimpleALua`.

  Para facilitar las cosas, `CompiladorSimpleALua` tiene un atributo
 `_compilador` que apunta al `CompiladorALua` que lo maneja. ]

funcion EscaparParaLua: texto
    variable res
    fijar res a {"} [ " ]
    ParaCadaElemento: texto, procedimiento: car
        si car = {"} [ " ]
            fijar res a res#concatenar: {\"} [ " ]
        sino
            si car = {~%}#formatear
                fijar res a res#concatenar: {\n}
            sino
                fijar res a res#concatenar: car
            finsi
        finsi
    finprocedimiento
    devolver res#concatenar: {"} [ " ]
finfuncion

funcion IdentificadorDe: id
    devolver {_}#concatenar: (RN#NombreResueltoDe: id)#comoTexto
finfuncion

clase CompiladorSimpleALua hereda CN#CaminaNodos
    metodo crearSubámbitoDesdeNodo: nodo
    metodo crearSubámbitoDesdeNombreEnNodo: nodo, llave

    metodo inicializar: moddb, ámbito, compilador

    metodo iniciar
    metodo registrarBuiltins

    metodo esBuiltin: nombre, binding
finclase

atributos CompiladorSimpleALua#_ámbito, [ Ámbito actual ]
          CompiladorSimpleALua#_moddb, [ Base de datos de módulos ]
          CompiladorSimpleALua#_compilador [ `CompiladorALua` que esta compilando ]

metodo CompiladorSimpleALua#crearSubámbitoDesdeNodo: nodo
    devolver yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídos}
finmetodo

metodo CompiladorSimpleALua#crearSubámbitoDesdeNombreEnNodo: nodo, llave
    devolver CompiladorSimpleALua#crear:
                 yo#_moddb,
                 (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, llave),
                 yo#_compilador
finmetodo

metodo CompiladorSimpleALua#inicializar: moddb, ámbito, compilador
    fijar yo#_ámbito a ámbito
    fijar yo#_moddb a moddb
    fijar yo#_compilador a compilador
finmetodo

metodo CompiladorSimpleALua#iniciar
    variable res
    fijar res a Arreglo#vacio
    ParaCadaElemento: yo#_ámbito#todosLosBindingsLocales, procedimiento: id
        res#agregarAlFinal: ({local _~t;}#formatear: id)
    finprocedimiento
    devolver Unir: res, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#registrarBuiltins
    variable cods
    fijar cods a Arreglo#vacio
    yo#_compilador#_builtins#paraCadaPar: procedimiento: nombreEnRT, binding
        cods#agregarAlFinal: ({_~t = rt.builtins[~t];}#formatear: binding, (EscaparParaLua: nombreEnRT))
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#esBuiltin: nombre, binding
    devolver (yo#_compilador#_builtins#en: nombre) = binding
finmetodo

metodo CompiladorSimpleALua#visitarPrograma: nodo
    variables instrs, ámbito
    fijar instrs a Arreglo#vacio
    ParaCadaElemento: nodo#instrucciones, procedimiento: instr
        instrs#agregarAlFinal: ((yo#visitar: instr)#concatenar: {;})
    finprocedimiento
    fijar ámbito a RN#ObtenerNombresDefinídos: nodo
    instrs#agregarAlFinal: {return rt.ns({}#formatear
    ámbito#paraCadaBinding: procedimiento: nombre, id
        instrs#agregarAlFinal: ({  [~t] = _~t,}#formatear: (EscaparParaLua: nombre), id)
    finprocedimiento
    instrs#agregarAlFinal: {~e);}#formatear
    devolver Unir: instrs, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarVariable: nodo
    devolver {}
finmetodo

metodo CompiladorSimpleALua#visitarFijar: nodo
    si EsInstancia: nodo#objetivo, AST#NodoIdentificador
        variables obj, expr
        fijar obj a IdentificadorDe: nodo#objetivo
        fijar expr a yo#visitar: nodo#valor
        devolver {~t = (~t);}#formatear: obj, expr
    sino
        necesitas EsInstancia: nodo#objetivo, AST#NodoEnviarMensaje
        necesitas nodo#objetivo#argumentos#longitud = 0
        variable base, fieldname
        fijar base a yo#visitar: nodo#objetivo#objeto
        fijar fieldname a {fijar_}#concatenar: nodo#objetivo#mensaje
        devolver yo#enviarMensaje: base, fieldname, (Arreglo#crearCon: nodo#valor)
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarEscribir: nodo
    devolver {rt.escribir(~t);}#formatear: (yo#visitar: nodo#valor)
finmetodo

metodo CompiladorSimpleALua#visitarNl: nodo
    devolver {rt.nl();}
finmetodo

metodo CompiladorSimpleALua#visitarClase: nodo
    variables cods, clssym
    fijar clssym a IdentificadorDe: nodo#nombre
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({~t = (~t);}#formatear: clssym, (yo#enviarMensaje: {rt.clases.Objeto}, {subclase}, Arreglo#vacio))
    cods#agregarAlFinal: ({rt.enviarMensaje(~t, "fijar_nombre", ~t);}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre))
    ParaCadaElemento: nodo#declaraciones, procedimiento: declr
        si EsInstancia: declr, AST#NodoDeclaraciónDeAtributosEnClase
            cods#agregarAlFinal: ((yo#visitar: (clonar AST#NodoAtributos#crear con
                areaTextual: declr#areaTextual
                deClase: nodo#nombre
                nombres: declr#nombres
            finclonar))#concatenar: {;})
        sino
            [ Nada que hacer para los NodoDeclaraciónDeMétodoEnClase ]
        finsi
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeAtributosEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarDeclaraciónDeMétodoEnClase: nodo
    Inalcanzable
finmetodo

metodo CompiladorSimpleALua#visitarImplementa: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineAtributosEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarDefineMétodoEnClase: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#expresiónDeFunción: nombreResueltoDeYo, parámetros, cuerpo
    variables cods, params, met
    fijar cods a Arreglo#vacio

    fijar params a Unir: (Mapear: parámetros, &IdentificadorDe), {, }

    si no EsNulo: nombreResueltoDeYo
        fijar met a {_~t}#formatear: nombreResueltoDeYo
        si parámetros#longitud > 0
            fijar params a {, }#concatenar: params
        finsi
    sino
        fijar met a {}
    finsi
    cods#agregarAlFinal: ({function(~t~t)}#formatear: met, params)
    cods#agregarAlFinal: yo#iniciar

    ParaCadaElemento: cuerpo, procedimiento: stmt
        cods#agregarAlFinal: ((yo#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarFunción: nodo
    variables cods, id, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    fijar id a IdentificadorDe: nodo#nombre
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({~t = (~t);}#formatear:
        id,
        (subyo#expresiónDeFunción: NULO, nodo#parámetros, nodo#cuerpo)
    )
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarNecesitas: nodo
    devolver {assert(~t);}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarDevolver: nodo
    devolver {do return ~t; end;}#formatear: (yo#visitar: nodo#expresión)
finmetodo

metodo CompiladorSimpleALua#visitarSi: nodo
    variables cods, subSiVerdadero, subSiFalso

    fijar subSiVerdadero a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiVerdadero}
    fijar subSiFalso a
        yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSiFalso}

    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({if ~t then}#formatear: (yo#visitar: nodo#condicional))

    cods#agregarAlFinal: subSiVerdadero#iniciar
    ParaCadaElemento: nodo#siVerdadero, procedimiento: stmt
        cods#agregarAlFinal: ((subSiVerdadero#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {else}

    cods#agregarAlFinal: subSiFalso#iniciar
    ParaCadaElemento: nodo#siFalso, procedimiento: stmt
        cods#agregarAlFinal: ((subSiFalso#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarMientras: nodo
    variables cods, subyo

    fijar subyo a yo#crearSubámbitoDesdeNodo: nodo

    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({while ~t do}#formatear: (yo#visitar: nodo#condicional))

    cods#agregarAlFinal: subyo#iniciar
    ParaCadaElemento: nodo#cuerpo, procedimiento: stmt
        cods#agregarAlFinal: ((subyo#visitar: stmt)#concatenar: {;})
    finprocedimiento

    cods#agregarAlFinal: {end}

    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarMétodo: nodo
    variables clssym, nrdyo, subyo, cuerpoMet
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    fijar clssym a IdentificadorDe: nodo#deClase
    fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    fijar cuerpoMet a subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
    devolver {rt.enviarMensaje(~t, "agregarMetodo", ~t, ~t);}#formatear: clssym, (EscaparParaLua: nodo#nombre#nombre), cuerpoMet
finmetodo

metodo CompiladorSimpleALua#visitarAtributos: nodo
    variables clssym, cods
    fijar clssym a IdentificadorDe: nodo#deClase
    fijar cods a Arreglo#vacio
    ParaCadaElemento: nodo#nombres, procedimiento: nodoId
        cods#agregarAlFinal: ({rt.enviarMensaje(~t, "agregarAtributo", ~t);}#formatear: clssym, (EscaparParaLua: nodoId#nombre))
    finprocedimiento
    devolver Unir: cods, {~%}#formatear
finmetodo

metodo CompiladorSimpleALua#visitarUtilizar: nodo
    variables módulo, nombreDelMódulo, mapeoDeImportados, espacioDeNombresResuelto
    si EsInstancia: nodo#módulo, AST#NodoIdentificador
        fijar nombreDelMódulo a nodo#módulo#nombre
    sino
        fijar nombreDelMódulo a nodo#módulo
    finsi
    fijar módulo a yo#_compilador#importarMódulo: nombreDelMódulo

    fijar mapeoDeImportados a Diccionario#vacío
    si no EsNulo: nodo#espacioDeNombres
        fijar espacioDeNombresResuelto a RN#NombreResueltoDe: nodo#espacioDeNombres
    finsi
    si no EsNulo: nodo#nombresEspecíficos
        ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: importado
            variables nombreEnMódulo, nombreFinal
            [ Si importamos la variable "Hola" como "Adios", por ejemplo, con
              `utilizar ejemplo (Hola como Adios)`, entonces nombreEnMódulo es `Hola`
              y nombreFinal es `Adios`. Si esta variable importada no fue renombrada
              (por ejemplo, `utilizar ejemplo (Hola)`) entonces nombreEnMódulo y
              nombreFinal son iguales. ]
            si EsInstancia: importado, AST#NodoIdentificador
                fijar nombreEnMódulo a importado
                fijar nombreFinal a importado
            sino
                fijar nombreEnMódulo a importado#en: 0
                fijar nombreFinal a importado#en: 1
            finsi
            mapeoDeImportados#fijarEn: nombreEnMódulo#nombre, (RN#NombreResueltoDe: nombreFinal)
        finprocedimiento
    finsi
    si (EsNulo: nodo#espacioDeNombres) && (EsNulo: nodo#nombresEspecíficos)
        fijar mapeoDeImportados a
            nodo#obtenerMetadato:
                RN#LLAVE_RESOLUCIÓN_DE_NOMBRES,
                {nombresImportadosResueltos}
    finsi

    variable cods
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: ({rt.ans_ns = rt.import(~t)}#formatear: (EscaparParaLua: módulo#llave#nombreCompletoDelArchivo))
    cods#agregarAlFinal: {;do}
    mapeoDeImportados#paraCadaPar: procedimiento: nombre, id
        cods#agregarAlFinal: ({  _~t = rt.ans_ns:at(~t);}#formatear: id, (EscaparParaLua: nombre))
    finprocedimiento
    cods#agregarAlFinal: {end}
    si no EsNulo: espacioDeNombresResuelto
        cods#agregarAlFinal: ({;_~t = rt.ans_ns;}#formatear: espacioDeNombresResuelto)
    finsi

    devolver (Unir: cods, {~%}#formatear)
finmetodo

metodo CompiladorSimpleALua#visitarIdentificador: nodo
    variables esAutoejecutable, identificador
    fijar esAutoejecutable a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
    fijar identificador a IdentificadorDe: nodo
    si esAutoejecutable
        devolver yo#enviarMensaje: identificador, {llamar}, Arreglo#vacio
    sino
        devolver identificador
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarNúmeroLiteral: nodo
    devolver nodo#valor
finmetodo

metodo CompiladorSimpleALua#visitarTextoLiteral: nodo
    devolver EscaparParaLua: nodo#valor
finmetodo

metodo CompiladorSimpleALua#enviarMensaje: objeto, mensaje, argumentos
    variables args, argsComoTexto
    fijar args a Mapear: argumentos, funcion: arg
        devolver yo#visitar: arg
    finfuncion
    si args#longitud = 0
        fijar argsComoTexto a {}
    sino
        fijar argsComoTexto a {, }#concatenar: (Unir: args, {, })
    finsi
    devolver {rt.enviarMensaje(~t, ~t~t)}#formatear: objeto, (EscaparParaLua: mensaje), argsComoTexto
finmetodo

metodo CompiladorSimpleALua#visitarLlamarProcedimiento: nodo
    si yo#esBuiltin: {__Lua}, (RN#NombreResueltoDe: nodo#proc)
        devolver yo#compilarBuiltinLua: nodo
    finsi
    devolver yo#enviarMensaje: (IdentificadorDe: nodo#proc), {llamar}, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#compilarBuiltinLua: nodo
    necesitas nodo#argumentos#longitud >= 1
    variables arg, argumentosEvaluados
    fijar arg a nodo#argumentos#en: 0
    necesitas EsInstancia: arg, AST#NodoTextoLiteral
    fijar argumentosEvaluados a
        Mapear:
            (PedazoDeArreglo: nodo#argumentos, 1, -1),
            funcion: x devolver yo#visitar: x finfuncion
    devolver {((~t)(~t))}#formatear: arg#valor, (Unir: argumentosEvaluados, {, })
finmetodo

metodo CompiladorSimpleALua#visitarEnviarMensaje: nodo
    devolver yo#enviarMensaje: (yo#visitar: nodo#objeto), nodo#mensaje, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarOperador: nodo
    devolver {rt.enviarMensaje(~t, ~t, ~t)}#formatear:
        (yo#visitar: nodo#lhs),
        (EscaparParaLua: ({operador_~t}#formatear: nodo#op#op)),
        (yo#visitar: nodo#rhs)
finmetodo

metodo CompiladorSimpleALua#visitarNoLlamar: nodo
    variables cod
    si nodo#mensajes#longitud > 0
        fijar cod a Reducir: (yo#visitar: nodo#base), funcion: acc, mensaje
            devolver {rt.enviarMensaje(~t, ~t)}#formatear: acc, (EscaparParaLua: mensaje)
        finfuncion, (PedazoDeArreglo: nodo#mensajes, 0, -1)
        fijar cod a {rt.enviarMensaje(~t, ~t, ...)}#formatear: cod, (ÚltimoElemento: nodo#mensajes)
    sino
        fijar cod a {rt.enviarMensaje(~t, "llamar", ...)}#formatear: (yo#visitar: nodo#base)
    finsi
    devolver {function(...) return ~t end}#formatear: cod
finmetodo

metodo CompiladorSimpleALua#visitarAutoejecutar: nodo
    devolver yo#enviarMensaje: (yo#visitar: nodo#expr), {llamar}, nodo#argumentos
finmetodo

metodo CompiladorSimpleALua#visitarFunciónAnónima: nodo
    variable nrdyo, subyo
    fijar subyo a yo#crearSubámbitoDesdeNombreEnNodo: nodo, {nombresDefinídosSinParámetros}
    si nodo#esMétodo
        fijar nrdyo a nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
    sino
        fijar nrdyo a NULO
    finsi
    devolver subyo#expresiónDeFunción: nrdyo, nodo#parámetros, nodo#cuerpo
finmetodo

metodo CompiladorSimpleALua#visitarSonIguales: nodo
    variable igual
    fijar igual a yo#enviarMensaje: (yo#visitar: nodo#lhs), {igualA}, (Arreglo#crearCon: nodo#rhs)
    si nodo#tipoIgualdad = AST#TipoIgualdad#IGUALES
        devolver igual
    sino
        devolver {not ~t}#formatear: igual
    finsi
finmetodo

metodo CompiladorSimpleALua#visitarReferenciar: nodo
    NoImplementado
finmetodo

metodo CompiladorSimpleALua#visitarNo: nodo
    devolver {not ~t}#formatear: (yo#visitar: nodo#expresión)
finmetodo

funcion CompilarALua: moddb, ast, ámbito, compilador
    variables comp, ini, builtins
    fijar comp a CompiladorSimpleALua#crear: moddb, ámbito, compilador
    fijar ini a comp#iniciar
    fijar builtins a comp#registrarBuiltins
    devolver {local rt = require "backends.lua.runtime";~%~t~%~t~%~t}#formatear: ini, builtins, (comp#visitar: ast)
finfuncion

clase CompiladorALua hereda Compilador#CompiladorBase
    metodo inicializar: db
    metodo compilarAST: ast, ámbito
    metodo importarMódulo: nombreDelMódulo
    metodo inyectarNombresEnÁmbito: ámbito
    metodo compilarTodo: llavePrincipal
finclase

atributo CompiladorALua#_builtins, CompiladorALua#_builtinsAutoejecutables

metodo CompiladorALua#inicializar: db
    fijar yo#baseDeDatos a db
    fijar yo#_builtins a
        Diccionario#desdePares:
            {Objeto}, RN#GenerarIdDeNombre,
            {VERDADERO}, RN#GenerarIdDeNombre,
            {FALSO}, RN#GenerarIdDeNombre,
            {NULO}, RN#GenerarIdDeNombre,
            {Aplicar}, RN#GenerarIdDeNombre,
            {ProcedimientoVarargs}, RN#GenerarIdDeNombre,
            {TipoDe}, RN#GenerarIdDeNombre,
            {__EnviarMensaje}, RN#GenerarIdDeNombre,
            {__FallarConMensaje}, RN#GenerarIdDeNombre,
            {__ClonarObjeto}, RN#GenerarIdDeNombre,
            {__CompararObjeto}, RN#GenerarIdDeNombre,
            {__AbrirArchivo}, RN#GenerarIdDeNombre,
            {__ByteATexto}, RN#GenerarIdDeNombre,
            {__TextoAByte}, RN#GenerarIdDeNombre,
            {__ByteEof}, RN#GenerarIdDeNombre,
            {__Capturar}, RN#GenerarIdDeNombre,
            {__Argv}, RN#GenerarIdDeNombre,

            {Boole}, RN#GenerarIdDeNombre,
            {Numero}, RN#GenerarIdDeNombre,
            {Arreglo}, RN#GenerarIdDeNombre,
            {Procedimiento}, RN#GenerarIdDeNombre,
            {Texto}, RN#GenerarIdDeNombre,
            {EspacioDeNombres}, RN#GenerarIdDeNombre,
            {Referencia}, RN#GenerarIdDeNombre,
            {TipoNulo}, RN#GenerarIdDeNombre,
            {__Lua}, RN#GenerarIdDeNombre
    fijar yo#_builtinsAutoejecutables a
        Arreglo#crearCon:
            {__Lua}, {Aplicar}, {ProcedimientoVarargs}, {TipoDe},
            {__EnviarMensaje}, {__FallarConMensaje}, {__ClonarObjeto},
            {__CompararObjeto}, {__AbrirArchivo}, {__ByteATexto},
            {__TextoAByte}, {__ByteEof}, {__Capturar}
finmetodo

metodo CompiladorALua#compilarAST: ast, ámbito
    devolver CompilarALua: yo#baseDeDatos, ast, ámbito, yo
finmetodo

metodo CompiladorALua#importarMódulo: nombreDelMódulo
    variables móduloOLlave, móduloCompilado
    fijar móduloOLlave a
        Módulos#ResolverMóduloPorNombre: yo#baseDeDatos, nombreDelMódulo, procedimiento: llave
            devolver llave
        finprocedimiento, procedimiento: mod
            devolver mod
        finprocedimiento, procedimiento
            __FallarConMensaje: ({Error: no se pudo encontrar el módulo ~t}#formatear: nombreDelMódulo)
        finprocedimiento
    si EsInstancia: móduloOLlave, Módulos#Módulo
        devolver móduloOLlave
    sino
        fijar móduloCompilado a yo#compilarTexto:
            móduloOLlave,
            (Archivos#LeerArchivo: móduloOLlave#nombreCompletoDelArchivo)
        yo#baseDeDatos#agregarMódulo: móduloCompilado
        devolver móduloCompilado
    finsi
finmetodo

metodo CompiladorALua#inyectarNombresEnÁmbito: ámbito
    yo#_builtins#paraCadaPar: procedimiento: nombreEnRT, binding
        ámbito#agregar: nombreEnRT, binding
    finprocedimiento
    ParaCadaElemento: yo#_builtinsAutoejecutables, procedimiento: nombre
        ámbito#marcarComoAutoejecutable: nombre
    finprocedimiento
finmetodo

metodo CompiladorALua#compilarTodo: llavePrincipal
    variables móduloPrincipal, cods
    fijar móduloPrincipal a yo#baseDeDatos#buscarMóduloPorLlave: llavePrincipal
    fijar cods a Arreglo#vacio
    cods#agregarAlFinal: {local rt = require "backends.lua.runtime";}
    yo#baseDeDatos#paraCadaMódulo: procedimiento: módulo
        cods#agregarAlFinal: ({rt.modulos[~t] = function()~%~t~%end;}#formatear: (EscaparParaLua: módulo#llave#nombreCompletoDelArchivo), módulo#compilado)
    finprocedimiento
    cods#agregarAlFinal: ({;rt.importar(~t);}#formatear: (EscaparParaLua: llavePrincipal#nombreCompletoDelArchivo))
    devolver Unir: cods, {~%}#formatear
finmetodo
