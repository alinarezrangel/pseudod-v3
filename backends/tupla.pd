utilizar bepd/builtins
utilizar bepd/x/adhoc (ObjetoAdHoc)
utilizar bepd/datos/conjunto (Conjunto)
utilizar bepd/datos/diccionario (Diccionario)
utilizar bepd/x/puerto (SalidaEstándar, PuertoParaTexto, TextoDePuertoDeEscritura, TextoComoPuerto)
utilizar bepd/x/puerto/deArchivo como PDA
utilizar bepd/x/puerto/conPosición (PosiciónTextual)
utilizar bepd/x/sistemaDeArchivos/archivo como SistemaDeArchivos
utilizar bepd/utilidades/texto
utilizar bepd/utilidades/iteración
utilizar bepd/utilidades/arreglo
utilizar bepd/x/enum (Enum, EnumConValores)
utilizar bepd/x/sexpr (ParsearDato, DesparsearDato, Símbolo)

utilizar tokens como Tokens
utilizar ast como AST
utilizar parser como Parser
utilizar resoluciónDeNombres como RN
utilizar defuncionalización como Defun
utilizar módulos como Módulos
utilizar compilador como Compilador



[DOCUMENTA
@brief{Camina un AST.}

@pd{nodo} es el nodo que se recorrerá.

@pd{cuerpo} es el procedimiento que se llamará.

Específicamente, @pd{Caminar'} llamará a @pd{cuerpo} con dos valores, el nodo
actual (que al principio es @pd{nodo}) y un @italic{recursor}. El recursor
tiene 2 métodos:

@itemlist(
@item{@code{recursor#\llamar\: nodo}: Itera sobre cada subnodo de @pd{nodo}
(sin incluir @pd{nodo}) y continúa la recursión con cada uno.}

@item{@code{recursor#llamarConRecursión: nodo, nuevoCuerpo}: Itera sobre cada
subnodo de @pd{nodo} (sin incluirlo) y continúa la recursión con cada uno como
si @pd{Caminar'} se hubiese llamado con @pd{nuevoCuerpo} en vez de
@pd{cuerpo}.}
)

Devuelve un valor indefinido.
DOCUMENTA]
funcion Caminar': nodo, cuerpo
    funcion visitarPartesRecursivas: nodo, f
        si EsInstancia: nodo, AST#NodoPrograma
            devolver ParaCadaElemento: nodo#instrucciones, f
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoFijar
            %f: nodo#objetivo
            devolver %f: nodo#valor
        finsi
        si EsInstancia: nodo, AST#NodoEscribir
            devolver %f: nodo#valor
        finsi
        si EsInstancia: nodo, AST#NodoNl
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoClase
            %f: nodo#nombre
            si no EsNulo: nodo#claseBase
                %f: nodo#claseBase
            finsi
            ParaCadaElemento: nodo#extiendeClases, f
            ParaCadaElemento: nodo#implementaClases, f
            devolver ParaCadaElemento: nodo#declaraciones, f
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
            %f: nodo#nombre
            devolver ParaCadaElemento: nodo#parámetros, f
        finsi
        si EsInstancia: nodo, AST#NodoImplementa
            %f: nodo#nombre
            devolver ParaCadaElemento: nodo#definiciones, f
        finsi
        si EsInstancia: nodo, AST#NodoDefineAtributosEnClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoDefineMétodoEnClase
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoNecesitas
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoDevolver
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoSi
            %f: nodo#condicional
            ParaCadaElemento: nodo#siVerdadero, f
            devolver ParaCadaElemento: nodo#siFalso, f
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            %f: nodo#condicional
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoMétodo
            si no EsNulo: nodo#deClase
                %f: nodo#deClase
            finsi
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoAtributos
            %f: nodo#deClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoUtilizar
            %f: nodo#módulo
            si no EsNulo: nodo#espacioDeNombres
                %f: nodo#espacioDeNombres
            finsi
            si no EsNulo: nodo#nombresEspecíficos
                ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: nombreORenombre
                    si EsInstancia: nombreORenombre, AST#NodoIdentificador
                        %f: nombreORenombre
                    sino
                        %f: (nombreORenombre#en: 0)
                        %f: (nombreORenombre#en: 1)
                    finsi
                finprocedimiento
            finsi
            devolver NULO
        finsi

        si EsInstancia: nodo, AST#NodoIdentificador
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoNumeroLiteral
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoTextoLiteral
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoLlamarProcedimiento
            %f: nodo#proc
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoEnviarMensaje
            %f: nodo#objeto
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoOperador
            %f: nodo#lhs
            devolver %f: nodo#rhs
        finsi
        si EsInstancia: nodo, AST#NodoNoLlamar
            devolver %f: nodo#base
        finsi
        si EsInstancia: nodo, AST#NodoAutoejecutar
            %f: nodo#expr
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoFunciónAnónima
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoSonIguales
            %f: nodo#lhs
            devolver %f: nodo#rhs
        finsi
        si EsInstancia: nodo, AST#NodoReferenciar
            devolver %f: nodo#nombre
        finsi
        si EsInstancia: nodo, AST#NodoNo
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoClonar
            %f: nodo#expresiónAClonar
            devolver ParaCadaElemento: nodo#campos, funcion: campo
                devolver %f: (campo#en: 1)
            finfuncion
        finsi

        si EsInstancia: nodo, AST#NodoVariadic
            devolver %f: nodo#interno
        finsi

        [ Nunca se llega hasta aquí. ]
        Escribir: ({Caminar no implementado para ~t}#formatear: (TipoDe: nodo))
        Inalcanzable
    finfuncion

    clase RecursorDeCaminar
        metodo \llamar\: nodo
        metodo llamarConRecursión: nodo, recur
    finclase

    metodo RecursorDeCaminar#\llamar\: nodoEnElQueContinuar
        devolver yo#llamarConRecursión: nodoEnElQueContinuar, cuerpo
    finmetodo

    metodo RecursorDeCaminar#llamarConRecursión: nodoEnElQueContinuar, recur
        devolver visitarPartesRecursivas: nodoEnElQueContinuar, funcion: nodo
            devolver %recur: nodo, yo
        finfuncion
    finmetodo

    devolver %cuerpo: nodo, RecursorDeCaminar#crear
finfuncion

[DOCUMENTA
@brief{Versión más fácil de usar de @pd{Caminar'}.}

Llama a @pd{cuerpo} con cada subnodo de @pd{nodo} para el cual @pd{%filtro:
nodo} devuelva @pd{VERDADERO}. Esta es una versión más limitada pero también
más fácil de usar que @pd{Caminar'}.

Devuelve un valor indefinido.
DOCUMENTA]
funcion Caminar: nodo, filtro, cuerpo
    funcion bucle: nodo, K
        si %filtro: nodo
            devolver %cuerpo: nodo, funcion: nodoEnElQueContinuar
                devolver bucle: nodoEnElQueContinuar, K
            finfuncion
        sino
            devolver %K: nodo
        finsi
    finfuncion
    devolver Caminar': nodo, &bucle
finfuncion


[ Este backend consiste de varios "mini-pases". Actualmente se encuentran en
  este mismo archivo, quizás después deba moverlos a sus propios archivos.

  Todos estos minipases usan la llave de anotación de capturas. ]


[DOCUMENTA
@brief{Tipo de @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}.}
DOCUMENTA]
clase LlaveAnotaciónDeCapturas
    metodo comoTexto
finclase

metodo LlaveAnotaciónDeCapturas#comoTexto
    devolver {LLAVE_ANOTACIÓN_DE_CAPTURAS}
finmetodo

[DOCUMENTA
@brief{Llave de anotación de capturas.}

Es la llave usada por los pases del backend de tuplas para agregar metadatos a
los nodos.
DOCUMENTA]
variable LLAVE_ANOTACIÓN_DE_CAPTURAS
fijar LLAVE_ANOTACIÓN_DE_CAPTURAS a LlaveAnotaciónDeCapturas#crear

[DOCUMENTA
@brief{Obtiene los nombres libres de un nodo.}

Véase el pase de defuncionalización (@pd{Defuncionalizar}).
DOCUMENTA]
funcion NombresLibres: nodo
    si EsInstancia: nodo, AST#NodoPrograma
        devolver Conjunto#vacío
    sino
        devolver nodo#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres}
    finsi
finfuncion

funcion NombresImportadosResueltos: nodo
    si (EsNulo: nodo#espacioDeNombres) && (EsNulo: nodo#nombresEspecíficos)
        devolver nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresImportadosResueltos}
    sino
        devolver Diccionario#vacío
    finsi
finfuncion

procedimiento AnotaLosNombresImportadosImplícitamente: ast, bindingsAdicionales
    variable implícitos
    fijar implícitos a Conjunto#desdeArreglo: bindingsAdicionales

    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoUtilizar
    finfuncion, procedimiento: nodo
        variable impl
        fijar impl a Arreglo#vacio
        si (EsNulo: nodo#espacioDeNombres) && (EsNulo: nodo#nombresEspecíficos)
            variable nombres
            fijar nombres a NombresImportadosResueltos: nodo
            nombres#paraCadaPar: procedimiento: nombre, binding
                fijar implícitos a implícitos#unión: (Conjunto#crearCon: binding)
            finprocedimiento
        finsi
    finprocedimiento

    Caminar: ast, funcion: nodo
        devolver EsIdentificadorDeVariable: nodo
              || DebeIgnorarElNodo: nodo
    finfuncion, procedimiento: nodo
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {importado}, (implícitos#contiene: (RN#NombreResueltoDe: nodo))
    finprocedimiento
finprocedimiento

funcion EsImportado: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {importado}
finfuncion

[DOCUMENTA
@brief{Anota todos los identificadores que representan variables.}

Anota todos los @pd{AST#NodoIdentificador} de @pd{ast} con el metadato
@code{esBásicamenteTextual} (llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es
@pd{VERDADERO} o @pd{FALSO} dependiendo de si el @pd{AST#NodoIdentificador} es
"textual" (su @code{#nombre} debe ser interpretado de forma literal) o no (es
el nombre de una variable).
DOCUMENTA]
procedimiento AnotarIdentificadoresTextuales: ast
    variable especiales
    fijar especiales a Arreglo#crearCon:
        AST#NodoIdentificador, AST#NodoDeclaraciónDeAtributosEnClase,
        AST#NodoDeclaraciónDeMétodoEnClase, AST#NodoMétodo, AST#NodoAtributos,
        AST#NodoUtilizar
    procedimiento esTextual: nodo, es
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esBásicamenteTextual}, es
    finprocedimiento
    Caminar: ast, funcion: nodo
        devolver Algún: (Mapear: especiales, (Parcial: &EsInstancia, nodo))
    finfuncion, funcion: nodo, recur
        si EsInstancia: nodo, AST#NodoIdentificador
            esTextual: nodo, FALSO
        finsi
        si EsInstancia: nodo, AST#NodoUtilizar
            esTextual: nodo#módulo, VERDADERO
            si no EsNulo: nodo#espacioDeNombres
                esTextual: nodo#espacioDeNombres, FALSO
            finsi
            si no EsNulo: nodo#nombresEspecíficos
                ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: nombreORenombre
                    si EsInstancia: nombreORenombre, Arreglo
                        esTextual: (nombreORenombre#en: 0), VERDADERO
                        esTextual: (nombreORenombre#en: 1), FALSO
                    sino
                        esTextual: nombreORenombre, FALSO
                    finsi
                finprocedimiento
            finsi
        finsi
        si EsInstancia: nodo, AST#NodoMétodo
            esTextual: nodo#deClase, FALSO
            esTextual: nodo#nombre, VERDADERO
            ParaCadaElemento: nodo#parámetros, recur
            ParaCadaElemento: nodo#cuerpo, recur
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
            ParaCadaElemento: nodo#nombres, procedimiento: nombre
                esTextual: nombre, VERDADERO
            finprocedimiento
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
            esTextual: nodo#nombre, VERDADERO
            ParaCadaElemento: nodo#parámetros, recur
        finsi
        si EsInstancia: nodo, AST#NodoAtributos
            esTextual: nodo#deClase, FALSO
            ParaCadaElemento: nodo#nombres, procedimiento: nombre
                esTextual: nombre, VERDADERO
            finprocedimiento
        finsi
        si EsInstancia: nodo, AST#NodoNoLlamar
            %recur: ast#base
            ParaCadaElemento: nodo#mensajes, procedimiento: mensaje
                esTextual: mensaje, VERDADERO
            finprocedimiento
        finsi
    finfuncion
finprocedimiento

[DOCUMENTA
@brief{Obtiene el metadato @code{esBásicamenteTextual} (llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}).}

Si @pd{nodo} no es un @pd{AST#NodoIdentificador} devuelve @pd{FALSO}.
DOCUMENTA]
funcion EsBásicamenteTextual: nodo
    si EsInstancia: nodo, AST#NodoIdentificador
        devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esBásicamenteTextual}
    sino
        devolver FALSO
    finsi
finfuncion

[DOCUMENTA
@brief{Determina si el nodo representa una variable mediante el metadato
@code{esBásicamenteTextual} (llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}).}

Básicamente devuelve @code{no esBásicamenteTextual}. Si @pd{nodo} no es un
@pd{AST#NodoIdentificador} devuelve @pd{FALSO}.
DOCUMENTA]
funcion EsIdentificadorDeVariable: nodo
    si EsInstancia: nodo, AST#NodoIdentificador
        devolver no nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esBásicamenteTextual}
    sino
        devolver FALSO
    finsi
finfuncion

[DOCUMENTA
@brief{Determina si el nodo contiene una variable @pd{yo} implícita.}

Devuelve @pd{VERDADERO} si @pd{nodo} declara de forma implícita una variable
@pd{yo}. Por ejemplo, @pd{AST#NodoFunción}es que fueron declarados con
@code{metodo}, @pd{AST#NodoMétodo} y @pd{AST#NodoFunciónAnónima} que fueron
creadas con @code{metodo} declaran de forma implícita una variable @pd{yo}.
DOCUMENTA]
funcion ContieneYoImplícito: nodo
    si EsInstancia: nodo, AST#NodoFunciónAnónima
        devolver nodo#esMétodo
    finsi
    si EsInstancia: nodo, AST#NodoMétodo
        devolver VERDADERO
    finsi
    devolver FALSO
finfuncion

[DOCUMENTA
@brief{Devuelve el nombre resuelto (binding) del @pd{yo} implícito de un nodo.}

@pd{nodo} debe declarar un @pd{yo} implícito (véase @pd{ContieneYoImplícito}).
DOCUMENTA]
funcion NombreResueltoDelYoImplícito: nodo
    necesitas ContieneYoImplícito: nodo
    devolver nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
finfuncion

[DOCUMENTA
@brief{Si el nodo debe ser ignorado para propósitos de compilación.}

Algunos nodos, como los @pd{AST#NodoDeclaraciónDeMétodoEnClase} no deben ser
compilados ni analizados. Estos nodos básicamente no tienen funcionalidad para
el backend.

Devuelve @pd{VERDADERO} si @pd{nodo} debería ser ignorado y @pd{FALSO} de lo
contrario.
DOCUMENTA]
funcion DebeIgnorarElNodo: nodo
    devolver EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
finfuncion

[DOCUMENTA
@brief{Pase de anotación de capturas.}

Anota todos los @pd{AST#NodoIdentificador} del AST con un metadato
@code{esCapturado} (con llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un
@pd{Boole} indicando si ese identificador es capturado o no por una closure.
DOCUMENTA]
procedimiento AnotaciónDeCapturas: ast
    variable nombresCapturadosAcc, nombresCapturados
    fijar nombresCapturadosAcc a Arreglo#vacio
    Caminar: ast, funcion: nodo
        variable declaraciones
        fijar declaraciones a Arreglo#crearCon:
            AST#NodoVariable, AST#NodoFunción, AST#NodoClase,
            AST#NodoMétodo, AST#NodoFunciónAnónima, AST#NodoUtilizar
        devolver (DebeIgnorarElNodo: nodo)
              || (ContieneYoImplícito: nodo)
              || (Algún: (Mapear: declaraciones, (Parcial: &EsInstancia, nodo)))
    finfuncion, procedimiento: nodo, recur
        [ FIXME: Esto siempre captura `yo` incluso cuando no lo esta siendo realmente ]
        [ si ContieneYoImplícito: nodo ]
        [     nombresCapturadosAcc#agregarAlFinal: (Conjunto#conValores: (NombreResueltoDelYoImplícito: nodo)) ]
        [ finsi ]
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si (EsInstancia: nodo, AST#NodoFunción)
        || (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoMétodo)
            nombresCapturadosAcc#agregarAlFinal: (NombresLibres: nodo)
            ParaCadaElemento: nodo#cuerpo, procedimiento: cn
                devolver %recur: cn
            finprocedimiento
            devolver NULO
        finsi
    finprocedimiento
    fijar nombresCapturados a Reducir: Conjunto#vacío, (MétodoComoFunción: {unión}), nombresCapturadosAcc
    Caminar': ast, procedimiento: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si ContieneYoImplícito: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsCapturado},
                (nombresCapturados#contiene: (NombreResueltoDelYoImplícito: nodo))
        finsi
        si EsIdentificadorDeVariable: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado},
                (nombresCapturados#contiene: (RN#NombreResueltoDe: nodo))
        finsi
        devolver %recur: nodo
    finprocedimiento
finprocedimiento

[ TODO: Documenta las siguientes clases ]
clase LocalDelProcedimiento
    metodo nombre
    metodo esCapturado
    metodo binding
    metodo índiceDeCaptura
    metodo esLocal
    metodo altura
    metodo profundidad
    metodo esLocalInmediata
    metodo esLocalDirecta
    metodo estáEnElEntorno
    metodo datosDeVariable
    metodo areaTextual
finclase

metodo LocalDelProcedimiento#comoTexto
    devolver {(~t nombre = ~t, esCapturado = ~t, binding = ~t, índiceDeCaptura = ~t, esLocal = ~t, altura = ~t, profundidad = ~t, esLocalInmediata = ~t, esLocalDirecta = ~t, estáEnElEntorno = ~t, datos = ~t)}#formatear: (TipoDe: yo), yo#nombre, yo#esCapturado, yo#binding, yo#índiceDeCaptura, yo#esLocal, yo#altura, yo#profundidad, yo#esLocalInmediata, yo#esLocalDirecta, yo#estáEnElEntorno, yo#datosDeVariable
finmetodo

clase IdentificadorLocalDelProcedimiento hereda LocalDelProcedimiento
    metodo estatico crear: nid, datosDeVariable
    metodo nodo
finclase

atributos IdentificadorLocalDelProcedimiento#nodo,
          IdentificadorLocalDelProcedimiento#datosDeVariable

metodo IdentificadorLocalDelProcedimiento#inicializar: nid, datosDeVariable
    fijar yo#nodo a nid
    fijar yo#datosDeVariable a datosDeVariable
finmetodo

metodo IdentificadorLocalDelProcedimiento#nombre
    devolver yo#nodo#nombre
finmetodo

metodo IdentificadorLocalDelProcedimiento#binding
    devolver RN#NombreResueltoDe: yo#nodo
finmetodo

metodo IdentificadorLocalDelProcedimiento#esCapturado
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#índiceDeCaptura
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#esLocal
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#altura
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#profundidad
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#esLocalInmediata
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalInmediata}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalInmediata}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#esLocalDirecta
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#estáEnElEntorno
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#areaTextual
    devolver yo#nodo#areaTextual
finmetodo

clase YoLocalDelProcedimiento hereda LocalDelProcedimiento
    metodo estatico crear: nodoConYo, datosDeVariable
    metodo nodoConYo
finclase

atributos YoLocalDelProcedimiento#nodoConYo,
          YoLocalDelProcedimiento#datosDeVariable

metodo YoLocalDelProcedimiento#inicializar: nodoConYo, datosDeVariable
    necesitas ContieneYoImplícito: nodoConYo
    fijar yo#nodoConYo a nodoConYo
    fijar yo#datosDeVariable a datosDeVariable
finmetodo

metodo YoLocalDelProcedimiento#nombre
    devolver {yo}
finmetodo

metodo YoLocalDelProcedimiento#binding
    devolver NombreResueltoDelYoImplícito: yo#nodoConYo
finmetodo

metodo YoLocalDelProcedimiento#esCapturado
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsCapturado}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsCapturado}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#índiceDeCaptura
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeYo}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeYo}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#esLocal
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocal}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocal}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#altura
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeYo}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeYo}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#profundidad
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeYo}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeYo}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#esLocalInmediata
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalInmediata}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalInmediata}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#esLocalDirecta
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalDirecta}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalDirecta}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#estáEnElEntorno
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEstáEnElEntorno}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEstáEnElEntorno}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#areaTextual
    devolver yo#nodoConYo#areaTextual
finmetodo

clase ImportadoLocalEnElProcedimiento hereda LocalDelProcedimiento
    metodo estatico crear: nodoUtilizar, binding, nombre, datosDeVariable
    metodo nodo
finclase

atributos ImportadoLocalEnElProcedimiento#nodo,
          ImportadoLocalEnElProcedimiento#binding,
          ImportadoLocalEnElProcedimiento#nombre,
          ImportadoLocalEnElProcedimiento#datosDeVariable

metodo ImportadoLocalEnElProcedimiento#inicializar: nodoUtilizar, binding, nombre, datosDeVariable
    fijar yo#nodo a nodoUtilizar
    fijar yo#binding a binding
    fijar yo#nombre a nombre
    fijar yo#datosDeVariable a datosDeVariable
finmetodo

metodo ImportadoLocalEnElProcedimiento#igualA: otro
    si no EsInstancia: otro, (TipoDe: yo)
        devolver FALSO
    sino
        devolver (Defun#SonElMismoObjeto: yo#nodo, otro#nodo) && (yo#binding = otro#binding)
    finsi
finmetodo

metodo ImportadoLocalEnElProcedimiento#\operador_=\: otro
    devolver yo#igualA: otro
finmetodo

metodo ImportadoLocalEnElProcedimiento#esCapturado
    devolver VERDADERO
finmetodo

metodo ImportadoLocalEnElProcedimiento#índiceDeCaptura
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeImportaciones}
        devolver (yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeImportaciones})#en: yo#binding
    sino
        devolver NULO
    finsi
finmetodo

metodo ImportadoLocalEnElProcedimiento#esLocal
    devolver FALSO
finmetodo

metodo ImportadoLocalEnElProcedimiento#altura
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeImportaciones}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeImportaciones}
    sino
        devolver NULO
    finsi
finmetodo

metodo ImportadoLocalEnElProcedimiento#profundidad
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeImportaciones}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeImportaciones}
    sino
        devolver NULO
    finsi
finmetodo

metodo ImportadoLocalEnElProcedimiento#esLocalInmediata
    [ FIXME: Estoy bastante seguro de que este método nunca se está usando... ]
    devolver NULO
finmetodo

metodo ImportadoLocalEnElProcedimiento#esLocalDirecta
    devolver FALSO
finmetodo

metodo ImportadoLocalEnElProcedimiento#estáEnElEntorno
    devolver VERDADERO
finmetodo

metodo ImportadoLocalEnElProcedimiento#areaTextual
    devolver yo#nodo#areaTextual
finmetodo

clase LocalBuiltinDelPrograma hereda LocalDelProcedimiento
    metodo estatico crear: nodoPrograma, binding, nombre, datosDeVariable
    metodo nodo
finclase

atributos LocalBuiltinDelPrograma#nodo,
          LocalBuiltinDelPrograma#binding,
          LocalBuiltinDelPrograma#nombre,
          LocalBuiltinDelPrograma#datosDeVariable

metodo LocalBuiltinDelPrograma#inicializar: nodoPrograma, binding, nombre, datosDeVariable
    fijar yo#nodo a nodoPrograma
    fijar yo#binding a binding
    fijar yo#nombre a nombre
    fijar yo#datosDeVariable a datosDeVariable
finmetodo

metodo LocalBuiltinDelPrograma#igualA: otro
    si no EsInstancia: otro, (TipoDe: yo)
        devolver FALSO
    sino
        devolver (Defun#SonElMismoObjeto: yo#nodo, otro#nodo) && (yo#binding = otro#binding)
    finsi
finmetodo

metodo LocalBuiltinDelPrograma#\operador_=\: otro
    devolver yo#igualA: otro
finmetodo

metodo LocalBuiltinDelPrograma#esCapturado
    devolver VERDADERO
finmetodo

metodo LocalBuiltinDelPrograma#índiceDeCaptura
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeBuiltins}
        devolver (yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeBuiltins})#en: yo#binding
    sino
        devolver NULO
    finsi
finmetodo

metodo LocalBuiltinDelPrograma#esLocal
    devolver FALSO
finmetodo

metodo LocalBuiltinDelPrograma#altura
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeBuiltins}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeBuiltins}
    sino
        devolver NULO
    finsi
finmetodo

metodo LocalBuiltinDelPrograma#profundidad
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeBuiltins}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeBuiltins}
    sino
        devolver NULO
    finsi
finmetodo

metodo LocalBuiltinDelPrograma#esLocalInmediata
    [ FIXME: Sigo bastante seguro de que este método nunca se está usando... ]
    devolver NULO
finmetodo

metodo LocalBuiltinDelPrograma#esLocalDirecta
    devolver FALSO
finmetodo

metodo LocalBuiltinDelPrograma#estáEnElEntorno
    devolver VERDADERO
finmetodo

metodo LocalBuiltinDelPrograma#areaTextual
    devolver yo#nodo#areaTextual
finmetodo


[ TODO: Documenta este pase ]
procedimiento EnumeraciónDeLocalesDeProcedimiento: ast, ámbitoContenedor, builtins
    necesitas (EsInstancia: ast, AST#NodoFunción)
           || (EsInstancia: ast, AST#NodoFunciónAnónima)
           || (EsInstancia: ast, AST#NodoMétodo)
           || (EsInstancia: ast, AST#NodoPrograma)
    variables locales, ámbitosLocales, nodosLocales
    fijar locales a Arreglo#vacio
    fijar ámbitosLocales a Pila#vacía
    fijar nodosLocales a Pila#vacía

    funcion ObtenerDatosDeLocal: bindingONodo
        si EsInstancia: bindingONodo, AST#NodoIdentificador
            fijar bindingONodo a RN#NombreResueltoDe: bindingONodo
        finsi
        devolver ámbitosLocales#últimoValorApilado#obtenerDatosDeVariable: bindingONodo
    finfuncion

    procedimiento AgregarLocal: local
        locales#agregarAlFinal: local
        necesitas ámbitosLocales#longitud = nodosLocales#longitud
        ParaCadaElemento: nodosLocales#_elementos, procedimiento: agregador
            devolver %agregador: local
        finprocedimiento
    finprocedimiento

    procedimiento FijarMetadatoConIdentificadorLocal: nid
        variable local
        fijar local a IdentificadorLocalDelProcedimiento#crear: nid, (ObtenerDatosDeLocal: nid)
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {local}, local
        devolver local
    finprocedimiento

    procedimiento AgregarIdentificadorLocal: nid
        devolver AgregarLocal: (FijarMetadatoConIdentificadorLocal: nid)
    finprocedimiento

    procedimiento AgregarYoLocal: nodoConYo
        necesitas ContieneYoImplícito: nodoConYo
        variable local
        fijar local a YoLocalDelProcedimiento#crear: nodoConYo, (ObtenerDatosDeLocal: (NombreResueltoDelYoImplícito: nodoConYo))
        nodoConYo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localYo}, local
        devolver AgregarLocal: local
    finprocedimiento

    procedimiento AgregarLocalesImportadas: nodoUtilizar
        variables importados, localesImportados
        fijar importados a NombresImportadosResueltos: nodoUtilizar
        fijar localesImportados a Arreglo#vacio
        importados#paraCadaPar: procedimiento: nombre, binding
            variable local
            fijar local a ImportadoLocalEnElProcedimiento#crear: nodoUtilizar, binding, nombre, (ObtenerDatosDeLocal: binding)
            localesImportados#agregarAlFinal: local
            AgregarLocal: local
        finprocedimiento
        nodoUtilizar#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesImportadas}, localesImportados
        devolver localesImportados
    finprocedimiento

    procedimiento AgregarLocalesBuiltins: nodoPrograma
        variable localesBuiltins
        fijar localesBuiltins a Arreglo#vacio
        builtins#paraCadaPar: procedimiento: nombre, datos
            si datos#esImportable
                variable local
                fijar local a LocalBuiltinDelPrograma#crear: nodoPrograma, datos#binding, nombre, datos
                localesBuiltins#agregarAlFinal: local
                AgregarLocal: local
            finsi
        finprocedimiento
        nodoPrograma#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesBuiltins}, localesBuiltins
        devolver localesBuiltins
    finprocedimiento

    procedimiento CreaAgregador: nodo, metadato
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato, Arreglo#vacio
        devolver procedimiento: local
            (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato)#agregarAlFinal: local
        finprocedimiento
    finprocedimiento

    ámbitosLocales#apilar: ámbitoContenedor
    nodosLocales#apilar: (CreaAgregador: ast, {localesDelNodo'})

    funcion filtro: nodo
        devolver (DebeIgnorarElNodo: nodo)
              || (EsIdentificadorDeVariable: nodo)
              || (EsInstancia: nodo, AST#NodoFunción)
              || (EsInstancia: nodo, AST#NodoMétodo)
              || (EsInstancia: nodo, AST#NodoFunciónAnónima)
              || (EsInstancia: nodo, AST#NodoSi)
              || (EsInstancia: nodo, AST#NodoMientras)
              || (EsInstancia: nodo, AST#NodoPrograma)
              || (EsInstancia: nodo, AST#NodoUtilizar)
              || (ContieneYoImplícito: nodo)
    finfuncion

    procedimiento interno: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si EsIdentificadorDeVariable: nodo
            si Defun#EsLocalEntre: ámbitoContenedor, ámbitosLocales#últimoValorApilado, nodo
                AgregarIdentificadorLocal: nodo
            sino
                FijarMetadatoConIdentificadorLocal: nodo
            finsi
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            %recur: nodo#condicional
            ámbitosLocales#apilar: (RN#ObtenerNombresDefinídos: nodo)
            nodosLocales#apilar: (CreaAgregador: nodo, {localesDelNodo})
            ParaCadaElemento: nodo#cuerpo, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            %recur: nodo#condicional
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiVerdadero})
            ParaCadaElemento: nodo#siVerdadero, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiFalso})
            ParaCadaElemento: nodo#siFalso, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoUtilizar
            si no EsNulo: nodo#espacioDeNombres
                %recur: nodo#espacioDeNombres
            finsi
            si no EsNulo: nodo#nombresEspecíficos
                ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: nombreORenombre
                    si EsInstancia: nombreORenombre, AST#NodoIdentificador
                        %recur: nombreORenombre
                    sino
                        %recur: (nombreORenombre#en: 1)
                    finsi
                finprocedimiento
            finsi
            AgregarLocalesImportadas: nodo
            devolver NULO
        finsi

        si (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoMétodo)
        || (EsInstancia: nodo, AST#NodoPrograma)
        || (EsInstancia: nodo, AST#NodoFunción)
            si EsInstancia: nodo, AST#NodoMétodo
                %recur: nodo#deClase
            finsi
            si EsInstancia: nodo, AST#NodoFunción
                %recur: nodo#nombre
            finsi
            devolver EnumeraciónDeLocalesDeProcedimiento: nodo, (RN#ObtenerNombresDefinídos: nodo), builtins
        finsi

        necesitas no ContieneYoImplícito: nodo
    finprocedimiento

    si (EsInstancia: ast, AST#NodoFunción)
    || (EsInstancia: ast, AST#NodoFunciónAnónima)
    || (EsInstancia: ast, AST#NodoMétodo)
        ParaCadaElemento: ast#parámetros, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
        ParaCadaElemento: ast#cuerpo, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
    finsi
    si ContieneYoImplícito: ast
        AgregarYoLocal: ast
    finsi
    si EsInstancia: ast, AST#NodoPrograma
        AgregarLocalesBuiltins: ast
        ParaCadaElemento: ast#instrucciones, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
    finsi

    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento},
        (Conjunto#desdeArreglo: (Mapear: locales, (MétodoComoFunción: {binding})))
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}, locales
finprocedimiento

[DOCUMENTA
@brief{Anota todas las variables locales que estan en el ámbito en el que
fueron declaradas.}

Cuando una variable es usada en el mismo ámbito en el que fue declarada decimos
que este uso es @italic{inmediato}. Los usos inmediatos son importantes porque
si todos los usos de una variable son usos inmediatos entonces esta puede estar
fuera de cualquier entorno.

Agrega el metadato (con la llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS})
@code{localesInmediatas} a cada nodo que pueda tener un ámbito
(@pd{AST#NodoPrograma}, @pd{AST#NodoMientras}, @pd{AST#NodoFunción},
@pd{AST#NodoFunciónAnónima}). @pd{AST#NodoSi} tiene sus propios metadatos
@code{localesInmediatasSiVerdadero} y @code{localesInmediatasSiFalso}. En todos
los casos el valor del metadato es un arreglo con las locales del ámbito
(devueltas tal y como @pd{EnumeraciónDeLocalesDeProcedimiento}) que son locales
inmediatas.

Además, anota cada @pd{AST#NodoIdentificador} con @code{esLocalInmediata}, un
metadato que es @pd{VERDADERO} o @pd{FALSO} dependiendo de si el identificador
es una local inmediata o no.
DOCUMENTA]
procedimiento AnotarLocalesInmediatas: ast
    variable NODOS_CON_ÁMBITO
    fijar NODOS_CON_ÁMBITO a Arreglo#crearCon: AST#NodoPrograma, AST#NodoSi, AST#NodoMientras,
                                               AST#NodoFunción, AST#NodoFunciónAnónima, AST#NodoMétodo

    funcion esBloqueConÁmbito: ast
        devolver (Algún: (Mapear: NODOS_CON_ÁMBITO, (Parcial: &EsInstancia, ast)))
    finfuncion

    procedimiento marcarInmediatas: ast, ámbito, recurBloque
        variable todasLasLocales
        fijar todasLasLocales a Arreglo#vacio
        Caminar: ast, funcion: ast
            devolver (DebeIgnorarElNodo: ast)
                  || (EsIdentificadorDeVariable: ast)
                  || (esBloqueConÁmbito: ast)
        finfuncion, procedimiento: ast, recur
            si DebeIgnorarElNodo: ast
                devolver NULO
            finsi
            si EsIdentificadorDeVariable: ast
                variables nr, inmediata
                fijar nr a RN#NombreResueltoDe: ast
                fijar inmediata a Contiene: ámbito#todosLosBindingsLocales, nr
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalInmediata}, inmediata
                si inmediata
                    todasLasLocales#agregarAlFinal: ast
                finsi
                devolver NULO
            finsi
            si EsInstancia: ast, AST#NodoMétodo
                %recur: ast#deClase
                devolver %recurBloque: ast
            finsi
            si EsInstancia: ast, AST#NodoFunción
                %recur: ast#nombre
                devolver %recurBloque: ast
            finsi
            devolver %recurBloque: ast
        finprocedimiento
        devolver todasLasLocales
    finprocedimiento

    procedimiento recursión: ast, K
        si DebeIgnorarElNodo: ast
            devolver NULO
        finsi
        si esBloqueConÁmbito: ast
            procedimiento marcarConÁmbito: ast, ámbito
                variable locales
                fijar locales a Arreglo#vacio
                K#llamarConRecursión: ast, funcion: nodo, K'
                    variable nuevasLocales
                    fijar nuevasLocales a marcarInmediatas: nodo, ámbito, funcion: bloque
                        devolver recursión: bloque, K
                    finfuncion
                    fijar locales a Concatenar: locales, nuevasLocales
                finfuncion
                devolver locales
            finprocedimiento

            si EsInstancia: ast, AST#NodoSi
                variables siVerdadero, siFalso, localesSiVerdadero, localesSiFalso
                fijar siVerdadero a ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero}
                fijar siFalso a ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso}
                fijar localesSiVerdadero a marcarConÁmbito: ast, siVerdadero
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiVerdadero}, localesSiVerdadero
                fijar localesSiFalso a marcarConÁmbito: ast, siFalso
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiFalso}, localesSiFalso
            sino
                variable locales
                si EsInstancia: ast, AST#NodoFunción
                    variables ámbito, localInmediata
                    fijar ámbito a RN#ObtenerNombresDefinídos: ast
                    fijar localInmediata a ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalInmediata}
                    fijar locales a marcarConÁmbito: ast, ámbito
                    ast#nombre#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalInmediata}, localInmediata
                    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}, locales
                sino
                    variable ámbito
                    fijar ámbito a RN#ObtenerNombresDefinídos: ast
                    fijar locales a marcarConÁmbito: ast, ámbito
                    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}, locales
                finsi

                si ContieneYoImplícito: ast
                    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalInmediata}, VERDADERO
                finsi
            finsi
        sino
            Escribir: ast
            Inalcanzable
        finsi
    finprocedimiento

    Caminar': ast, &recursión
finprocedimiento


clase EstadoDeEnumeraciónDeCapturas
    [ asoc: Diccionario de los bindings a sus informaciones de capturas. ]
    [ acc: Número de capturas. ]
    atributos asoc, acc, estadoSuperior

    metodo estatico inicial
    metodo estatico desdeEstado: estado

    metodo marcarÍndiceCapturaEnDeclaración: nid
    metodo marcarÍndiceCapturaEnDeclaraciónDeYo: nid
    metodo marcarÍndiceCapturaEnUso: nid
    metodo marcarÍndiceCapturaEnImportación: nodoUtilizar, binding
    metodo marcarÍndiceCapturaEnBuiltin: nodoPrograma, binding
    metodo informaciónDeLaCaptura: nid

    metodo profundidad
finclase

metodo estatico EstadoDeEnumeraciónDeCapturas#inicial
    devolver yo#crear
finmetodo

metodo estatico EstadoDeEnumeraciónDeCapturas#desdeBuiltins: builtins
    variables estado, acc
    fijar estado a yo#crear
    fijar acc a 0
    builtins#paraCadaPar: procedimiento: nombre, binding
        estado#asoc#fijarEn: binding, acc
        fijar acc a acc + 1
    finprocedimiento
    fijar estado#acc a acc
    devolver estado
finmetodo

metodo estatico EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
    devolver clonar yo#crear con
        estadoSuperior: estado
    finclonar
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#inicializar
    fijar yo#asoc a Diccionario#vacío
    fijar yo#acc a 0
    fijar yo#estadoSuperior a NULO
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnDeclaración: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, 0
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, yo#acc
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, yo#profundidad
    yo#asoc#fijarEn: (RN#NombreResueltoDe: nid), yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnDeclaraciónDeYo: nodo
    nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeYo}, 0
    nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeYo}, yo#acc
    nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeYo}, yo#profundidad
    yo#asoc#fijarEn: (NombreResueltoDelYoImplícito: nodo), yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnImportación: nodoUtilizar, binding
    nodoUtilizar#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeImportaciones}, 0
    si no nodoUtilizar#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeImportaciones}
        nodoUtilizar#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeImportaciones}, Diccionario#vacío
    finsi
    (nodoUtilizar#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeImportaciones})#fijarEn: binding, yo#acc
    nodoUtilizar#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeImportaciones}, yo#profundidad
    yo#asoc#fijarEn: binding, yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnBuiltin: nodoPrograma, binding
    nodoPrograma#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeBuiltins}, 0
    si no nodoPrograma#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeBuiltins}
        nodoPrograma#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeBuiltins}, Diccionario#vacío
    finsi
    (nodoPrograma#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeBuiltins})#fijarEn: binding, yo#acc
    nodoPrograma#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeBuiltins}, yo#profundidad
    yo#asoc#fijarEn: binding, yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#informaciónDeLaCaptura: nid
    si yo#asoc#contiene: (RN#NombreResueltoDe: nid)
        devolver ObjetoAdHoc: {altura}, 0,
                              {índiceDeCaptura}, (yo#asoc#en: (RN#NombreResueltoDe: nid)),
                              {profundidad}, yo#profundidad
    sino
        variable dt
        si EsNulo: yo#estadoSuperior
            Escribir: {No existe?}, nid
        finsi
        necesitas no EsNulo: yo#estadoSuperior
        fijar dt a yo#estadoSuperior#informaciónDeLaCaptura: nid
        devolver clonar dt con
            altura: dt#altura + 1
        finclonar
    finsi
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnUso: nid
    variable dt
    fijar dt a yo#informaciónDeLaCaptura: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, dt#altura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, dt#índiceDeCaptura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, dt#profundidad
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#profundidad
    si EsNulo: yo#estadoSuperior
        devolver 0
    sino
        devolver 1 + yo#estadoSuperior#profundidad
    finsi
finmetodo

[DOCUMENTA
@brief{Anota los identificadores del programa con su información de captura.}

Cada identificador es anotado con los metadatos @code{altura},
@code{profundidad} e @code{índiceDeCaptura} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}).

@code{altura} es el número de entornos que se debe "saltar".

@code{índiceDeCaptura} es el índice dentro del entorno seleccionado. Asume que
cada ámbito es compilado a un entorno en el IR.

@code{profundidad} es un número que indica la profundidad dentro del programa
en la que se declaró la variable
DOCUMENTA]
procedimiento EnumeraciónDeCapturas: ast, estado, callbacks, builtins
    variable DECLARACIONES
    fijar DECLARACIONES a Arreglo#crearCon: AST#NodoVariable, AST#NodoFunción, AST#NodoMétodo,
                                            AST#NodoFunciónAnónima, AST#NodoIdentificador,
                                            AST#NodoSi, AST#NodoMientras, AST#NodoPrograma,
                                            AST#NodoClase, AST#NodoUtilizar

    Caminar: ast, funcion: nodo
        devolver (DebeIgnorarElNodo: nodo)
              || (Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo)))
    finfuncion, procedimiento: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoPrograma
            variable subcallbacks
            fijar subcallbacks a Arreglo#vacio

            builtins#paraCadaPar: procedimiento: llave, datos
                estado#marcarÍndiceCapturaEnBuiltin: nodo, datos#binding
            finprocedimiento

            ParaCadaElemento: nodo#instrucciones, procedimiento: nodo
                EnumeraciónDeCapturas: nodo, estado, subcallbacks, builtins
            finprocedimiento
            ParaCadaElemento: subcallbacks, (MétodoComoFunción: {llamar})
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, estado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoClase
            estado#marcarÍndiceCapturaEnDeclaración: nodo#nombre
            si no EsNulo: nodo#claseBase
                %recur: nodo#claseBase
            finsi
            ParaCadaElemento: nodo#extiendeClases, recur
            ParaCadaElemento: nodo#implementaClases, recur
            ParaCadaElemento: nodo#declaraciones, recur
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            ParaCadaElemento: nodo#nombres, &(estado#marcarÍndiceCapturaEnDeclaración)
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoUtilizar
            si no EsNulo: nodo#espacioDeNombres
                estado#marcarÍndiceCapturaEnDeclaración: nodo#espacioDeNombres
            finsi
            si no EsNulo: nodo#nombresEspecíficos
                ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: nombreORenombre
                    si EsInstancia: nombreORenombre, AST#NodoIdentificador
                        estado#marcarÍndiceCapturaEnDeclaración: nombreORenombre
                    sino
                        estado#marcarÍndiceCapturaEnDeclaración: (nombreORenombre#en: 1)
                    finsi
                finprocedimiento
            finsi

            variable importados
            fijar importados a NombresImportadosResueltos: nodo
            importados#paraCadaPar: procedimiento: nombre, binding
                estado#marcarÍndiceCapturaEnImportación: nodo, binding
            finprocedimiento

            devolver NULO
        finsi
        si (EsInstancia: nodo, AST#NodoFunción)
        || (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoMétodo)
            variables subestado, subcallbacks
            fijar subcallbacks a Arreglo#vacio

            si EsInstancia: nodo, AST#NodoFunción
                estado#marcarÍndiceCapturaEnDeclaración: nodo#nombre
            finsi
            si EsInstancia: nodo, AST#NodoMétodo
                estado#marcarÍndiceCapturaEnUso: nodo#deClase
            finsi
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            si ContieneYoImplícito: nodo
                subestado#marcarÍndiceCapturaEnDeclaraciónDeYo: nodo
            finsi
            ParaCadaElemento: nodo#parámetros, procedimiento: param
                si EsInstancia: param, AST#NodoVariadic
                    subestado#marcarÍndiceCapturaEnDeclaración: param#interno
                sino
                    subestado#marcarÍndiceCapturaEnDeclaración: param
                finsi
            finprocedimiento

            callbacks#agregarAlFinal: procedimiento
                ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                    EnumeraciónDeCapturas: instr, subestado, subcallbacks, builtins
                finprocedimiento

                ParaCadaElemento: subcallbacks, (MétodoComoFunción: {llamar})
            finprocedimiento

            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            variables subestado, subcallbacks
            fijar subcallbacks a Arreglo#vacio

            %recur: nodo#condicional
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado, subcallbacks, builtins
            finprocedimiento

            ParaCadaElemento: subcallbacks, (MétodoComoFunción: {llamar})
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            variables subestadoSiVerdadero, subestadoSiFalso, subcallbacksSiVerdadero, subcallbacksSiFalso
            fijar subcallbacksSiVerdadero a Arreglo#vacio
            fijar subcallbacksSiFalso a Arreglo#vacio

            %recur: nodo#condicional
            fijar subestadoSiVerdadero a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siVerdadero, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestadoSiVerdadero, subcallbacksSiVerdadero, builtins
            finprocedimiento
            ParaCadaElemento: subcallbacksSiVerdadero, (MétodoComoFunción: {llamar})

            fijar subestadoSiFalso a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siFalso, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestadoSiFalso, subcallbacksSiFalso, builtins
            finprocedimiento
            ParaCadaElemento: subcallbacksSiFalso, (MétodoComoFunción: {llamar})

            necesitas subestadoSiVerdadero#profundidad = subestadoSiFalso#profundidad
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestadoSiFalso#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            si EsIdentificadorDeVariable: nodo
                estado#marcarÍndiceCapturaEnUso: nodo
            finsi
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Anota los bindings locales de un ámbito.}

Agrega a cada nodo identificador un metadato @code{esLocal} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un @pd{Boole} indicando si el
identificador es "local" a su posición: es decir, si fue declarado en la
función en la que se encuentra.
DOCUMENTA]
procedimiento AnotarBindingsLocales: ast
    necesitas (EsInstancia: ast, AST#NodoFunción)
           || (EsInstancia: ast, AST#NodoMétodo)
           || (EsInstancia: ast, AST#NodoFunciónAnónima)
           || (EsInstancia: ast, AST#NodoPrograma)
    variables bindings, nombre, deClase
    fijar bindings a BindingsLocalesDelBloque: ast
    si EsInstancia: ast, AST#NodoFunción
        fijar nombre a ast#nombre
    sino
        fijar nombre a NULO
    finsi
    si EsInstancia: ast, AST#NodoMétodo
        fijar deClase a ast#deClase
    sino
        fijar deClase a NULO
    finsi
    Caminar: ast, funcion: nodo
        devolver (DebeIgnorarElNodo: nodo)
              || (   (no Defun#SonElMismoObjeto: nodo, ast)
                  && (no Defun#SonElMismoObjeto: nodo, nombre)
                  && (no Defun#SonElMismoObjeto: nodo, deClase)
                  && (   (EsInstancia: nodo, AST#NodoIdentificador)
                      || (EsInstancia: nodo, AST#NodoFunción)
                      || (EsInstancia: nodo, AST#NodoMétodo)
                      || (EsInstancia: nodo, AST#NodoFunciónAnónima)
                      || (EsInstancia: nodo, AST#NodoPrograma)))
    finfuncion, procedimiento: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            si EsIdentificadorDeVariable: nodo
                nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}, (bindings#contiene: (RN#NombreResueltoDe: nodo))
            finsi
            devolver NULO
        finsi
        si ContieneYoImplícito: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocal}, (bindings#contiene: (NombreResueltoDelYoImplícito: nodo))
        finsi
        si (EsInstancia: nodo, AST#NodoFunciónAnónima) || (EsInstancia: nodo, AST#NodoPrograma)
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            %recur: nodo#nombre
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMétodo
            %recur: nodo#deClase
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Marca todas las variables que son locales directas.}

Un uso de una variable cuenta como "uso local directo" si sucede dentro de la
misma función en la que la variable fue declarada. Este procedimiento marca
todos los @pd{AST#NodoIdentificador} con el metadato @code{esLocalDirecta}
(llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un @pd{Boole} indicando si este
identificador es un uso local directo.
DOCUMENTA]
procedimiento MarcaVariablesLocalesEnSubámbitos: ast
    Caminar': ast, procedimiento: nodo, K
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si (EsInstancia: nodo, AST#NodoFunción)
        || (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoMétodo)
        || (EsInstancia: nodo, AST#NodoPrograma)
        || (ContieneYoImplícito: nodo)
            variables bindings, locales, localesReales, nombre, deClase
            fijar bindings a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}
            fijar locales a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
            fijar localesReales a Filtrar: (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelNodo'}),
                                           funcion: local
                                               devolver local#profundidad = (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad})
                                           finfuncion

            [ localesReales contiene las variables declaradas directamente en
              `nodo`, mientras que `locales` y `bindings` contienen las locales
              y bindings de `nodo` y todos sus subámbitos excepto
              funciones/métodos/procedimientos. ]

            si EsInstancia: nodo, AST#NodoFunción
                fijar nombre a nodo#nombre
            sino
                fijar nombre a NULO
            finsi
            si EsInstancia: nodo, AST#NodoMétodo
                fijar deClase a nodo#deClase
            sino
                fijar deClase a NULO
            finsi

            variables bindingsDeEsteÁmbito, localesDeEsteÁmbito
            fijar bindingsDeEsteÁmbito a Conjunto#desdeArreglo: (Mapear: localesReales, (MétodoComoFunción: {binding}))
            fijar localesDeEsteÁmbito a Filtrar: locales, funcion: local
                devolver bindingsDeEsteÁmbito#contiene: local#binding
            finfuncion

            si ContieneYoImplícito: nodo
                nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalDirecta}, (bindingsDeEsteÁmbito#contiene: (NombreResueltoDelYoImplícito: nodo))
            finsi

            procedimiento marcarSubidentificadores: nodo
                Caminar: nodo, funcion: nodo
                    devolver (DebeIgnorarElNodo: nodo)
                          || (   (no Defun#SonElMismoObjeto: nodo, nombre)
                              && (no Defun#SonElMismoObjeto: nodo, deClase)
                              && (   (EsInstancia: nodo, AST#NodoIdentificador)
                                  || (EsInstancia: nodo, AST#NodoFunción)
                                  || (EsInstancia: nodo, AST#NodoMétodo)
                                  || (EsInstancia: nodo, AST#NodoFunciónAnónima)
                                  || (EsInstancia: nodo, AST#NodoPrograma)))
                finfuncion, procedimiento: nodo, subrecur
                    si DebeIgnorarElNodo: nodo
                        devolver NULO
                    finsi
                    si EsInstancia: nodo, AST#NodoFunción
                        %subrecur: nodo#nombre
                        MarcaVariablesLocalesEnSubámbitos: nodo
                        devolver NULO
                    finsi
                    si EsInstancia: nodo, AST#NodoMétodo
                        %subrecur: nodo#deClase
                        MarcaVariablesLocalesEnSubámbitos: nodo
                        devolver NULO
                    finsi
                    si (EsInstancia: nodo, AST#NodoPrograma) || (EsInstancia: nodo, AST#NodoFunciónAnónima)
                        devolver MarcaVariablesLocalesEnSubámbitos: nodo
                    finsi
                    si EsInstancia: nodo, AST#NodoIdentificador
                        si EsIdentificadorDeVariable: nodo
                            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta},
                                (bindingsDeEsteÁmbito#contiene: (RN#NombreResueltoDe: nodo))
                        finsi
                    finsi
                finprocedimiento
            finprocedimiento

            devolver K#llamarConRecursión: nodo, &marcarSubidentificadores
        sino
            devolver %K: nodo
        finsi
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Marca todos los identificadores con un metadato indicando si deben
estar en el entorno o no.}

Le agrega el metadato @code{estáEnElEntorno} (llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) a todos los @pd{AST#NodoIdentificador}. Este
metadato es un @pd{Boole} que indica si este uso del identificador debe estar
en el entorno de la función o no.
DOCUMENTA]
procedimiento MarcaVariablesQueEstánEnElEntorno: ast
    funcion vaEnElEntorno: local
        devolver local#esCapturado || (no local#esLocal) || (no local#esLocalDirecta)
    finfuncion
    Caminar': ast, procedimiento: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si EsIdentificadorDeVariable: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno},
                ((EsImportado: nodo) || (vaEnElEntorno: (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {local})))
            devolver NULO
        finsi
        si ContieneYoImplícito: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEstáEnElEntorno},
                (vaEnElEntorno: (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localYo}))
        finsi
        devolver %recur: nodo
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Devuelve un boole indicando si @pd{nid} está en el entorno.}

Obtiene el metadato @code{estáEnElEntorno}.
DOCUMENTA]
funcion EstáEnElEntorno: nid
    devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}
finfuncion


[ Fin de los minipases. Ahora comienza el backend "real": ]


[ Nombre código del backend. Véase también la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Tupla (IR) Bootstrap}

[ El IR:

  El IR esta compuesto de 4 "partes": las instrucciones, las declaraciones, las
  constantes y la tabla de módulos. Se asume que el órden de las instrucciones
  importa pero el de las constantes y las declaraciones no.

  Las instrucciones consisten de un arreglo de "tuplas": cada tupla es como un
  arreglo de tamaño mayor a 1, donde el primer elemento es la instrucción u
  opcode y los demás elementos son los argumentos. Cada opcode requiere sus
  propios argumentos con tipos específicos.

  Las constantes son un diccionario de un CID ("constant-ID") a la constante
  dada. El IR solo puede representar constantes numéricas (como instancias de
  números), textuales (como instancias de textos) y "prototipos" (véase más
  abajo).

  Las declaraciones actualmente solo incluyen la declaración de función, la
  cual consiste del ID de la función, sus parámetros (normales y el parámetro
  variadic), sus pragmas y las instrucciones de su cuerpo.

  Estas 3 partes están agrupadas en una estructura llamada `Compilado`. La
  operación más fundamental de un compilado es secuenciar (`A >> B`) pero
  también tienen otras.

  Para poder compilar un programa que use varios módulos, es necesario generar
  la tabla de módulos. Esta contiene un mapeo de cada nombre de módulo a la
  función que contiene el código de dicho. Esta tabla *no* es mantenida junto
  al `Compilado` ya que siempre puede ser regenerada desde las 3 partes
  anteriores.

Prototipos:

  Los prototipos son usados para realizar llamadas a funciones variadic. Son un
  tipo especial de constantes que indican la estructura de la pila al momento
  de llamar a una función.

  Cuando llamas a un procedimiento variadic, algunos elementos en la pila son
  argumentos posicionales normales y otros tienen que ser expandidos. Por
  ejemplo, en la llamada `Hola: 1, ...2, 3, 4, ...5` los argumentos `1`, `3` y
  `4` son normales y `2` y `5` tienen que ser expandidos.

  Debido a que la pila siempre debe tener una estructura estática (más abajo
  explico por qué) no podemos simplemente "expandir" los argumentos variadic
  directamente en la pila. En cambio, mantenemos todos los argumentos como si
  ninguno fuese variadic (de forma que la pila contendrá los valores `1 2 3 4
  5`) y creamos un *prototipo* `0 1 0 0 1` que indica cuales argumentos son
  variadic (en este caso, solo el segundo y el último).

  Los prototipos son un tipo de constante: esto permite al backend-del-backend
  (el que compila el IR, llamado *lowerer* en inglés ya que "baja" el IR de su
  nivel intermedio al código final de bajo nivel) compilar y analizar de forma
  estática y eficiente estas llamadas variadic.

Semanticas:

  El IR tiene un número ilimitado de registros o variables locales (o solo
  "locales") por cada marco de activación de cada función. También tiene una
  pila que es compartida entre marcos de activación: cada función debe tener
  cuidado de mantener la pila en un estado apropiado (las funciones no pueden
  leer los elementos de la pila que fueron agregados antes de entrar a
  esta). Finalmente, una última pila, la pila de ámbitos, es usada para
  compilar `si`-`finsi` y `mientras`-`finmientras`. A diferencia de la pila
  general, esta segunda pila no es compartida por los marcos de activación lo
  que significa que no es importante asegurarse de que esté en un estado válido
  al final de la función.

  Todo esto hace que el IR sea bastante fácil de usar: variables e
  instrucciones pueden usar directamente los registros mientras que las
  expresiones utilizan la pila para guardar los valores intermediarios. Nota
  que la pila no es completamente dinámica: debido a que todas las operaciones
  tienen un "efecto" estático en la pila y el compilador tiene cuidado de que
  las partes dinámicas (como los condicionales o bucles) siempre tengan la pila
  en un estado determinado al principio y final de estos, es posible (en
  teoría) determinar estáticamente el número de elementos en la pila. Esto es
  importante porque es posible que los pases posteriores del compilador
  "desapilen" el código eliminando la pila y convirtiendo todo el código a
  registros. (Nada de esto esta implementado, pero es fundamental para que la
  máquina virtual tenga un buen rendimiento en un futuro. Creo que también
  tendré que agregar algunas anotaciones en los puntos de control de flujo para
  hacer este proceso más fácil.)

  La regla más importante al usar la pila es que al principio de todos los
  bloques básicos la pila siempre debe estar en el mismo estado
  irrelevantemente de cual salto llevó a dicho bloque.

  Finalmente: exísten algunos opcodes para saltar tanto como incondicional como
  condicionalmente. Todos están intencionalmente hechos para que los únicos
  objetivos de un salto sean etiquetas. Por ejemplo, en vez de una instrucción
  "salta si es falso" `BR <etiqueta>` hay una "salta de acuerdo a una
  condición" `CHOOSE <siVerdadero>, <siFalso>`. Gracias a esto es posible
  convertir el IR a un grafo de bloques básicos y todos los bloques con bordes
  entrantes comenzarán con una etiqueta.

  Los tipos de objetos manejados por el IR son, en su mayoría, los mismos que
  los builtins de PseudoD: números, textos, booleanos y el tipo nulo. Además, 2
  tipos adicionales (objetos y closures) son utilizados para implementar los
  demás. Tal como el intérprete, todos los objetos en la VM son "reales":
  puedes enviar mensajes a números o closures sin problemas.

  Sin embargo, para facilitar la implementación del runtime algunos tipos que
  normalmente serían implementados como alguno de los anteriores es en cambio
  su propio tipo: los arreglos y espacios de nombres son tipos distintos a
  nivel del runtime, y también lo son los enteros y los reales. Un tipo
  especial, llamado *voidptr*, almacena un puntero genérico; este tipo es usado
  para manipular valores externos a PseudoD.

  Solo existe un objeto que es especial: la marca de pila. Este objeto es
  interno al runtime y bajo condiciones normales jamás puede ser observado.

  Las closures están implementadas como un puntero a una función y un
  entorno. Los objetos son como funciones pero su puntero a función apunta a la
  función que recibirá los mensajes y su entorno contiene los atributos del
  objeto.

  Un entorno consiste de un puntero a un entorno "superior" y una lista de
  registros almacenados. Los entornos son usados para implementar closures y
  objetos. Puedes crear un entorno con las instrucciones del "marco" (*frame
  instructions*, se llaman así porque siempre aparecen al principio de las
  funciones, "reificando" los marcos de activación). Para acceder a un valor en
  un entorno necesitas una altura (el número de entornos a "saltar" desde el
  actual) y un índice (el objeto dentro del entorno seleccionado a acceder).

  Los registros especiales `ESUP` y `EACT` representan el entorno "superior" al
  actual y el entorno actual, respectivamente. `EACT` tiene que ser
  inicializado manualmente. `ESUP` es el entorno pasado a esta función de forma
  implícita.

  Como durante la compilación cada ámbito pasa a ser un entorno, es necesario
  un sistema para prevenir que las variables `EACT` y `ESUP` se confundan (por
  ejemplo, si tienes un `si` dentro de un `mientras`, el `EACT` del mientras
  debe ser distinto del `EACT` del `si`). Para esto existe la pila de ámbitos:
  cada ámbito guarda sus entornos (`EACT`) en la pila de ámbitos usando las
  instrucciones `SPUSH` y `SPOP`.

Instrucciones:

  Los prefijos significan:

  1. `C`: Índice de una constante de la lista de constantes.
  2. `N`: Constante numérica.
  3. `F`: Constante real.
  4. `B`: Un booleano. 0 es falso, 1 es verdadero.
  5. `L`: Índice de registro local.
  6. `E`: Entorno: un registro local o alguna de las variables especiales
     `EACT` o `ESUP`.
  7. `U`: Número positivo (mayor o igual a 0).
  8. `T`: Etiqueta.
  9. `P`: ID de un procedimiento.
  10. `?`: Combinado con `E` o `L` indica que el argumento puede ser el valor
      especial `NIL`.

  SUM    {a b -- c}
  SUB    {a b -- c}
  MUL    {a b -- c}
  DIV    {a b -- c}
    Operaciones aritméticas básicas. Operan en la pila. Equivalentes a enviar
    los mensajes `operador_+`, `operador_-`, `operador_*` y `operador_/`.

  DUP {a -- a a}
    Duplica el valor en la cima de la pila.

  DROP {a --}
    Saca un valor de la pila.

  LT     {a b -- c}
  GT     {a b -- c}
  LE     {a b -- c}
  GE     {a b -- c}
  OPEQ   {a b -- c}
    Menor/mayor que, mayor/menor o igual a e igual a. Operan en la
    pila. Equivalentes a enviar los mensajes `operador_<`, `operador_>`,
    `operador_=<`, `operador_>=` y `operador_=`.

  OBJATTR       {obj n -- x}
    Obtiene el atributo #`n` del objeto `obj`.

  OBJATTRSET    {obj n val --}
    Fija el atributo #`n` del objeto `obj` al valor `val`.

  OBJSZ         {obj -- n}
    Obtiene el número de atributos de un objeto.

  Las instrucciones `OBJATTR`, `OBJATTRSET` y `OBJSZ` también se pueden usar en
  closures. En ese caso manipulan las capturas del entorno del closure.

  OBJ2CLZ       {clz -- obj}
  CLZ2OBJ       {obj -- clz}
    Convierte un closure a un objeto y viceversa.

  POP    {a --}
    Saca e ignora el elemento en la cima de la pila.

  LCONST Cx    {-- a}
    Carga la constante con el índice `Cx` y la empuja en la pila.

    No puedes cargar cualquier constante, solo las numéricas y textuales.

  ICONST Na    {-- a}
  FCONST Fa    {-- a}
    Empuja una constante numérica.

  BCONST Na    {-- a}
    Empuja una constante booleana. Si `Na` es 1, empuja `VERDADERO`. Si es
    0 empuja `FALSO`.

  LOCAL Lx
    Declara un registro local. Solo puede estár al principio de una
    lista de instrucciones.

    Como un caso especial, si una función tiene un parámetro variadic este debe
    ser declarado con `LOCAL` al inicio de esta. Los demás parámetros no deben
    ser declarados.

  MKCLZ Ex, Px    {-- c}
  MK0CLZ Px       {-- c}
    Crea una closure mezclando un procedimiento (`Px`) y un entorno
    (`Ex`). `MK0CLZ` es como `MKCLZ` pero utiliza un entorno vacío.

  LSET Lx    {v --}
    Saca un elemento de la pila y lo asigna a la local `Lx`.

  LGET Lx    {-- v}
    Obtiene y empuja en la pila el valor de la local `Lx`.

  LSETC Ex, Ua, Ub    {v --}
    Saca un elemento de la pila y lo asigna a la variable dada del
    entorno. `Ex` es el entorno, `Ua` es la altura de la variable y `Ub` es el
    índice de la variable.

  LGETC Ex, Ua, Ub    {-- v}
    Obtiene la variable dada del entorno y empuja su valor en la pila. `Ex` es
    el entorno, `Ua` es la altura de la variable y `Ub` es el índice de la
    variable.

  ROT Ua
    Rota los primeros `Ua + 1` elementos en la cima de la pila. Por ejemplo si
    la pila tenía 4 elementos:

      <-----T
      A B C D

    (La flecha apunta a la base de la pila.)
    Entonces ejecutar `ROT 3` dejará la pila como:

      <-----T
      B C D A

    Esto es muy útil, por ejemplo, al compilar `obj#mensaje: 1, 2, 3`: el orden
    en el que compilan las partes de la expresión anterior es:

      <-------T
      obj 1 2 3

    Pero necesitamos `1 2 3 obj` para poder invocar el mensaje con `MSG`.

    (Puedes imaginar a este opcode como un "prepara para llamar a una
    función/método con `Ua` argumentos".)

  ROTM Ua
    Rota la pila como `ROT`, pero mueve 2 elementos en vez de 1. Su uso
    principal es cuando se va a usar una de las instrucciones `DYN*`.

    Por ejemplo, si la pila es:

      <-----T
      A B C D

    Entonces `ROTM 2` la dejaría como:

      <-----T
      C D A B

    Nota como movió `A` y `B` en vez de solo `B`.

  MSG Cx, Ua, Ub   {... obj -- ...}
    Saca un elemento, el objeto que recibirá el mensaje. Luego le envía a este
    el mensaje indicado por la constante `Cx`. Este mensaje es llamado con `Ua`
    argumentos y se espera que devuelva `Ub` resultados.

  DYNMSG Ua, Ub    {... obj msj -- ...}
    Como MSG, pero también saca el mensaje a enviar de la pila. El mensaje debe
    estár arriba del objeto.

  MSGV Cx, Cy, Ua  {... obj -- ...}
  DYNMSGV Cy, Ua   {... obj msj -- ...}
    Como `MSG` y `DYNMSG`, pero aceptan sus argumentos en su forma
    variadic. `Cx` es la constante con el mensaje a enviar. `Cy` es el índice
    de la constante que contiene el prototipo de la llamada. `Ua` es el número
    de valores devueltos.

  TMSG Cx, Ua, Ub
  TMSGV Cx, Cy, Ua
  TDYNMSG Ua, Ub
  TDYNMSGV Cy, Ua
    `MSG`, `MSGV`, `DYNMSG` y `DYNMSGV` tienen variantes *tail* que comienzan
    con `T`: `TMSG`, `TMSGV`, `TDYNMSG` y `TDYNMSGV`. La única diferencia entre
    estas variantes y las originales es que estas realizan un *tail call*.

  RETN Ua
    Devuelve `Ua` objetos (que deben estar en la pila) del procedimiento
    actual.

  OPNFRM Ex, ?Ey, Ua    {--}
    Inicializa un entorno. El nuevo entorno es guardado en `Ex`. Si `Ey` es
    especificado será el entorno superior. `Ua` es el tamaño del entorno (es
    decir, el número de variables que contiene).

  ENEW Ex, Ua    {--}
    Inicializa una variable dentro del entorno. La variable en el índice `Ua`
    del entorno `Ex` será fijada a `NULO`.

  EINIT Ex, Ua, Ly    {--}
    Inicializa una variable dentro del entorno. La variable en el índice `Ua`
    del entorno `Ex` será fijada al valor del registro `Ly`.

  CLSFRM Ex    {--}
    "Cierra" un entorno. Luego de cerrarlo, no puedes usar `EINIT` o `ENEW` con
    `Ex`. En cambio, cualquier cambio al entorno tendrá que pasar por `LSETC`.

  Entre las instrucciones `OPNFRM` y `CLSFRM` solo pueden haber instrucciones
  `ENEW` y `EINIT`.

  NAME Tx
    Declara `Tx` como una etiqueta. `Tx` debe ser único en el procedimiento
    actual.

  CHOOSE Tx, Ty    {x --}
    Saca un elemento de la pila, si es verdadero salta a `Tx`, si no salta a
    `Ty`.

  JMP Tx    {--}
    Salta incondicionalmente a `Tx`.

  MTRUE    {x --}
    Saca un objeto de la pila y falla con un error si no es verdadero. Este
    opcode implementa la instrucción `necesitas`.

  CMPEQ     {a b -- c}
  CMPNEQ    {a b -- c}
    Compara si dos objetos de la pila son iguales/diferentes, empujando
    verdadero o falso. `CMPEQ` es equivalente al opcode `OPEQ`. `CMPNEQ` es
    equivalente a enviar el mensaje `operador_no=`.

  CMPREFEQ  {a b -- c}
    Compara si dos valores son el mismo objeto, empujando verdadero o falso en
    la pila.

  NOT    {a -- b}
    Invierte el boole en la cima de la pila.

  PRN    {a --}
    Escribe el texto en la cima de la pila.

  NL    {--}
    Escribe el fin de línea.

  TODO: Documenta como SPUSH debe estar seguido de OPNFRM.

  SPUSH EACT, ESUP
  SPOP EACT, ESUP
    Empuja/saca y reorganiza `EACT`/`ESUP` en la pila de ámbitos. Luego de
    `SPUSH EACT, ESUP`, `EACT` estará en la pila de ámbitos y `EACT`/`ESUP`
    serán "rotados".

    TODO: Documenta estos opcodes.

    `SPOP EACT, ESUP` revierte esto, sacando y rotando de nuevo las variables.

  OPNEXP Un
  CLSEXP      {-- a}
    Estos opcodes abren y cierran la sección de exportación. `Un` es el número
    de valores exportados por el módulo actual.

    `CLSEXP` empuja en la pila el espacio de nombres creado.

  EXP Cn, Bn   {a --}
    Saca 1 valor de la pila y exportalo desde el módulo actual bajo el nombre
    referenciado por `Cn` (una constante textual). Este opcode solo se puede
    usar entre los opcodes `OPNEXP` y `CLSEXP`. `Bn` indica si el valor
    exportado es autoejecutable o no.

  IMPORT Cn
  SAVEIMPORT Cn    {-- a}
    Estos opcodes importan el módulo identificado por la constante textual `Cn`.

    Por limitaciones de la implementación, el proceso de importar un módulo
    requiere dos opcodes en vez de uno. Estos dos opcodes siempre deben estar
    seguidos uno del otro, sin ningún otro opcode de por medio.

    `SAVEIMPORT` empuja en la pila el espacio de nombres del módulo importado.

  NSLOOKUP Cx  {ns -- v}
    Saca el valor con el nombre `Cx` del espacio de nombres `ns`.

    Este opcode ignora si el campo `Cx` es autoejecutable o no: siempre saca su
    valor sin ejecutarlo.

  GETCLSOBJ  {-- a}
    Obtiene la clase `Objeto` del runtime.

  MODULE Cx
    Este opcode actúa como una declaración de que la función actual es un
    módulo. `Cx` es la constante textual con el nombre del módulo.

    Solo puede aparecer dentro de funciones/procedimientos. No tiene ningún
    efecto al ejecutarse.

  OBJTAG  {a -- b}
    Obtiene la «etiqueta» de `a`: un entero que determina el tipo del
    objeto. Empuja este entero en la pila (`b`).

    Que etiquetas corresponden a que tipos depende de la implementación del
    runtime. Véase los archivos `backend/tupla/bootstrap.pd` y `src/pdcrt.h` y
    el tipo `pdcrt_tipo_de_objeto` (en el repositorio del runtime) para más
    información.

  PRAGMA <nombre>, ...

    La instrucción pragma es especial: no es un opcode y no genera una
    instrucción. En cambio, actúa como una declaración para el *lowerer*. El
    primer argumento es un texto que indica la declaración que se está
    realizando, mientras que los demás argumentos contienen más información
    para la pragma.

    Las pragmas solo pueden estar dentro de funciones, y solo pueden aparecer
    al inicio, antes que cualquier otro opcode (incluyendo `LOCAL`).

    Las pragmas soportadas son:

      PRAGMA CNAME, <cname>
        <cname> es una literal textual que contiene el nombre en C de esta
        función. Normalmente, el lowerer les asigna nombres internos a las
        distintas funciones del programa, generalmente consisten de un prefijo
        y un número único. Esta pragma te deja cambiar dicho nombre. Esto solo
        es útil si deseas exportar la función desde PseudoD o importar una
        función escrita en C.

      PRAGMA IMPORT
        Importa esta función desde C. En algún archivo objeto enlazado con el
        programa debe haber una función con el nombre especificado en el
        CNAME. Dicha función será llamada cuando PseudoD llame a la actual.

        PRAGMA IMPORT solo tiene efecto si también hay una PRAGMA CNAME.

Ejemplo:

  En PseudoD:

    variable X
    funcion Y: v
        devolver (v + 4) * X
    finfuncion
    fijar X a 5
    escribir Y: 3
    nl

  En bytecode (más o menos):

    Instrucciones:
      LOCAL 3
      LOCAL 4
      OPNFRM EACT, NIL, 1
      EINIT EACT, 0, 3
      CLSFRM EACT
      MKCLZ EACT, 1
      LSET 4
      ICONST 5
      LSETC EACT, 0, 0
      LGET 4
      ICONST 3
      ROT 1
      MSG 0, 1, 1
      PRN
      NL

    Procedimientos:
      PROC 1
        PARAM 2
        OPNFRM EACT, ESUP, 0
        CLSFRM EACT
        LGET 2
        ICONST 4
        SUM
        LGETC EACT, 1, 0
        MUL
        RETN 1
      ENDPROC

    Constantes:
      #0 STRING "llamar"

]

[DOCUMENTA
@brief{Variable local que contiene al entorno superior.}

Es la constante @code{ESUP} del bytecode.
DOCUMENTA]
funcion LocalDelEntornoSuperior
    devolver {ESUP}
finfuncion

[DOCUMENTA
@brief{Variable local que contiene al entorno actual.}

Es la constante @code{EACT} del bytecode.
DOCUMENTA]
funcion LocalDelEntornoActual
    devolver {EACT}
finfuncion


[DOCUMENTA
@brief{Una tupla de opcode y los argumentos.}

La tupla tiene más de un elemento: el primero siempre es el opcode, mientras
que los demás son los argumentos.
DOCUMENTA]
clase Tupla
    [DOCUMENTA
    @brief{El opcode de esta tupla.}
    DOCUMENTA]
    atributo opcode

    [DOCUMENTA
    @brief{Los argumentos de esta tupla.}

    Es un arreglo.
    DOCUMENTA]
    atributo argumentos

    [DOCUMENTA
    @brief{Crea una nueva tupla.}
    DOCUMENTA]
    metodo estatico crear: op, ...args

    [DOCUMENTA
    @brief{Determina si es o no un opcode específico.}

    Devuelve @pd{VERDADERO} o @pd{FALSO} dependiendo de si el opcode de esta
    tupla es @pd{op}.
    DOCUMENTA]
    metodo es: op

    [DOCUMENTA
    @brief{Obtiene un argumento de la tupla.}

    Devuelve el argumento número @pd{n} de esta tupla, contando desde 0.
    DOCUMENTA]
    metodo en: n

    [DOCUMENTA
    @brief{Devuelve una representación textual de la tupla.}
    DOCUMENTA]
    metodo comoTexto

    [DOCUMENTA
    @brief{Escribe la representación textual de la tupla en el IR.}

    @pd{puertoDeEscritura} es el puerto en el que la representación textual de
    la tupla será escrita.
    DOCUMENTA]
    metodo emitirComoIR: puertoDeEscritura

    metodo comoSExpr
    metodo estatico desdeSExpr: sexpr
finclase

metodo estatico Tupla#crear: op, ...args
    variable inst
    fijar inst a yo#_crear
    fijar inst#opcode a op
    fijar inst#argumentos a args
    devolver inst
finmetodo

metodo Tupla#es: op
    devolver yo#opcode = op
finmetodo

metodo Tupla#en: n
    devolver yo#argumentos#en: n
finmetodo

metodo Tupla#comoTexto
    devolver {(Tupla ~t ~t)}#formatear:
        yo#opcode#nombre,
        (Unir:
         (Mapear: yo#argumentos, funcion: x
              devolver x#comoTexto
          finfuncion),
         {, })
finmetodo

metodo Tupla#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: yo#opcode#nombre
    ParaCadaElementoConÍndice: yo#argumentos, procedimiento: argumento, i
        si i > 0
            puertoDeEscritura#escribirTexto: {,}
        finsi
        puertoDeEscritura#escribirTexto: { }
        puertoDeEscritura#escribirTexto: argumento#comoTexto
    finprocedimiento
    puertoDeEscritura#escribirTexto: {~%}#formatear
finmetodo

metodo Tupla#comoSExpr
    devolver Arreglo#crearCon: (Símbolo#desdeTexto: yo#opcode#nombre), ...(yo#argumentos)
finmetodo

metodo estatico Tupla#desdeSExpr: sexpr
    devolver yo#crear: (Opcode#desdeNombre: (sexpr#en: 0)#valor), ...(PedazoDeArreglo: sexpr, 1, -1)
finmetodo

[DOCUMENTA
@brief{Crea una enumeración con valores incrementales.}

Como @pd{Enum} pero los valores de las enumeraciones no son su nombre si no un
número que se va incrementando de 1 en 1. Por ejemplo:

@ejemplo|{
variable X
fijar X a EnumConValoresIncrementales: {X},
    {A}, {B}, {C}, {D}
necesitas X#A#valor = 0
necesitas X#B#valor = 1
necesitas X#C#valor = 2
necesitas X#D#valor = 3
}|
DOCUMENTA]
funcion EnumConValoresIncrementales: nombre, ...valores
    variable pares
    fijar pares a Diccionario#vacío
    ParaCadaElementoConÍndice: valores, procedimiento: valor, i
        pares#fijarEn: valor, i
    finprocedimiento
    devolver EnumConValores: nombre, ...(Aplanar: pares#comoArreglo)
finfuncion

[DOCUMENTA
@brief{Todos los opcodes del IR.}

Esta enumeración contiene todos los opcodes del bytecode. El valor de cada
enumerado es el "código" del opcode.

Como una conveniencia, los enumerados también tienen un método @code{bytecode}
como un alias de @code{valor} (por ejemplo, @pd{Opcode#SUM#bytecode} es igual
a @pd{Opcode#SUM#valor}).
DOCUMENTA]
variable Opcode
fijar Opcode a EnumConValoresIncrementales: {Opcode},
    {LOCAL},      [ LOCAL Lx  (Solo al principio de un procedimiento) ]
    {LCONST},     [ LCONST Cx ]
    {ICONST},     [ ICONST Ia ]
    {FCONST},     [ FCONST Fa ]
    {BCONST},     [ BCONST Ia ]
    {SUM},        [ SUM ]
    {SUB},        [ SUB ]
    {MUL},        [ MUL ]
    {DIV},        [ DIV ]
    {DUP},        [ DUP ]
    {DROP},       [ DROP ]
    {RETN},       [ RETN Ux ]
    {MKCLZ},      [ MKCLZ Ex, Px ]
    {MK0CLZ},     [ MK0CLZ Px ]
    {OPNFRM},     [ OPNFRM Ex, ?Ey, Ua ]
    {EINIT},      [ EINIT Ex, Ua, Lx ]
    {ENEW},       [ ENEW  ]
    {CLSFRM},     [ CLSFRM Ex ]
    {LSETC},      [ LSETC Ex, Ua, Ub ]
    {LGETC},      [ LGETC Ex, Ua, Ub ]
    {LSET},       [ LSET Lx ]
    {LGET},       [ LGET Lx ]
    {POP},        [ POP ]
    {CHOOSE},     [ CHOOSE Tx, Ty ]
    {JMP},        [ JMP Tx ]
    {NAME},       [ NAME Tx ]
    {MTRUE},      [ MTRUE ]
    {CMPEQ},      [ CMPEQ ]
    {CMPNEQ},     [ CMPNEQ ]
    {CMPREFEQ},   [ CMPREFEQ ]
    {NOT},        [ NOT ]
    {ROT},        [ ROT Ua ]
    {ROTM},       [ ROTM Ua ]
    {GT},         [ GT ]
    {LT},         [ LT ]
    {GE},         [ GE ]
    {LE},         [ LE ]
    {OPEQ},       [ OPEQ ]
    {CLZ2OBJ},    [ CLZ2OBJ ]
    {OBJ2CLZ},    [ OBJ2CLZ ]
    {TMSG},       [ TMSG Cx, Ua, Ub ]
    {MSG},        [ MSG Cx, Ua, Ub ]
    {TMSGV},      [ TMSGV Cx, Cy, Ub ]
    {MSGV},       [ MSGV Cx, Cy, Ub ]
    {TDYNMSG},    [ TDYNMSG Ua, Ub ]
    {DYNMSG},     [ DYNMSG Ua, Ub ]
    {TDYNMSGV},   [ TDYNMSGV Cx, Ub ]
    {DYNMSGV},    [ DYNMSGV Cx, Ub ]
    {PRN},        [ PRN ]
    {NL},         [ NL ]
    {OPNEXP},     [ OPNEXP Ua ]
    {CLSEXP},     [ CLSEXP ]
    {EXP},        [ EXP Ux, Bx ]
    {IMPORT},     [ IMPORT Cx ]
    {SAVEIMPORT}, [ SAVEIMPORT Cx ]
    {MODULE},     [ MODULE Cx ]
    {SPUSH},      [ SPUSH EACT, ESUP ]
    {SPOP},       [ SPOP EACT, ESUP ]
    {OBJTAG},     [ OBJTAG ]
    {OBJATTR},    [ OBJATTR ]
    {OBJATTRSET}, [ OBJATTRSET ]
    {OBJSZ},      [ OBJSZ ]
    {NSLOOKUP},   [ NSLOOKUP Cx ]
    {GETCLSOBJ},  [ GETCLSOBJ ]
    {PRAGMA}      [ PRAGMA (Texto:Nombre de la pragma), argumentos... ]

metodo Opcode#bytecode
    devolver yo#valor
finmetodo

[ El objeto `OP` es un pequeño DSL para construir tuplas. `OP#SUM: 1, 2` es lo
  mismo que `Tupla#crear: Opcode#SUM, 1, 2` ]

variable OP
si VERDADERO
    clase I
        metodo metodoNoEncontrado: mensaje, argumentos
    finclase

    metodo I#metodoNoEncontrado: mensaje, argumentos
        devolver Tupla#crear: (Opcode#desdeNombre: mensaje), ...argumentos
    finmetodo

    fijar OP a I#crear
finsi

[DOCUMENTA
@brief{Compila los argumentos de una pragma al IR.}

Devuelve un texto que contiene a los argumentos de la pragma compilados. Cada
argumento puede ser un @pd{Texto}, en cuyo caso será escapado mediante
@pd{EscaparParaPDVM}, o un número, en cuyo caso será emitido tal cual.
DOCUMENTA]
funcion CompilarArgumentosParaPragmaDirectamente: argumentos
    funcion escapar: valor
        si EsInstancia: valor, Texto
            devolver {"~t"}#formatear: (EscaparParaPDVM: valor)
        sino
            devolver valor#comoTexto
        finsi
    finfuncion
    devolver Unir: (Mapear: argumentos, &escapar), {, }
finfuncion

[DOCUMENTA
@brief{Una pragma del IR.}

Cada pragma controla un aspecto especial sobre el código
compilado.
DOCUMENTA]
clase Pragma
    atributo nombre
    atributo argumentos

    metodo estatico desdeTupla: tupla
    metodo estatico crear: nombre, ...argumentos

    metodo comoTupla

    metodo emitirComoIR: puertoDeEscritura
    metodo comoSExpr
    metodo estatico desdeSExpr: sexpr
finclase

metodo estatico Pragma#desdeTupla: tupla
    devolver yo#crear: (tupla#en: 0), ...(PedazoDeArreglo: tupla#argumentos, 1, -1)
finmetodo

metodo Pragma#inicializar: nombre, ...argumentos
    fijar yo#nombre a nombre
    fijar yo#argumentos a argumentos
finmetodo

metodo Pragma#comoTupla
    devolver Tupla#crear: Opcode#PRAGMA, yo#nombre, ...(yo#argumentos)
finmetodo

metodo Pragma#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {PRAGMA }
    puertoDeEscritura#escribirTexto: yo#nombre
    puertoDeEscritura#escribirTexto: { }
    puertoDeEscritura#escribirTexto: (CompilarArgumentosParaPragmaDirectamente: yo#argumentos)
    puertoDeEscritura#escribirTexto: {~%}#formatear
finmetodo

metodo Pragma#comoSExpr
    devolver Arreglo#crearCon:
        (Símbolo#desdeTexto: {PRAGMA}),
        (Símbolo#desdeTexto: yo#nombre),
        ...(yo#argumentos)
finmetodo

metodo estatico Pragma#desdeSExpr: sexpr
    devolver yo#crear: (sexpr#en: 1)#valor, ...(PedazoDeArreglo: sexpr, 2, -1)
finmetodo

[DOCUMENTA
@brief{Declaración de función o procedimiento dentro del bytecode.}
DOCUMENTA]
clase DeclrFunción
    [DOCUMENTA
    @brief{Nombre de la función.}

    Debe ser un número único en el programa.
    DOCUMENTA]
    atributo nombre

    [DOCUMENTA
    @brief{Los parámetros de la función.}

    Un arreglo de números: cada número es el ID de un registro local que será
    un parámetro en la función.
    DOCUMENTA]
    atributo parámetros

    [DOCUMENTA
    @brief{El parámetro variadic de la función, o @pd{NULO}.}

    Si es @pd{NULO} entonces la función no es variadic. Si no es nulo entonces
    debe ser el ID del parámetro que será variadic.

    Recuerda que, a diferencia de los demás parámetros, el parámetro variadic
    debe ser declarado con @code{LOCAL} en el cuerpo de la función.
    DOCUMENTA]
    atributo parámetroVariadic

    [DOCUMENTA
    @brief{Pragmas de la función.}

    Un arreglo de @pd{Pragma}s.
    DOCUMENTA]
    atributo pragmas

    [DOCUMENTA
    @brief{Cuerpo de la función.}

    Un arreglo de tuplas.
    DOCUMENTA]
    atributo cuerpo

    [DOCUMENTA
    @brief{Crea una nueva declaración de función.}
    DOCUMENTA]
    metodo estatico crear: nombre, parámetros, parámVariadic, cuerpo

    [DOCUMENTA
    @brief{Devuelve una representación textual de la declaración.}
    DOCUMENTA]
    metodo comoTexto

    [DOCUMENTA
    @brief{Escribe la representación textual de la declaración en el IR.}

    @pd{puertoDeEscritura} es el puerto en el que la representación textual de
    la función será escrita.
    DOCUMENTA]
    metodo emitirComoIR: puertoDeEscritura

    metodo comoSExpr
    metodo estatico desdeSExpr: sexpr
finclase

metodo estatico DeclrFunción#crear: nombre, parámetros, parámVariadic, cuerpo
    variable pragmasYCuerpo
    fijar pragmasYCuerpo a SepararArreglo: cuerpo, funcion: tupla devolver tupla#es: Opcode#PRAGMA finfuncion, cuerpo
    devolver clonar yo#_crear con
        nombre: nombre
        parámetros: parámetros
        parámetroVariadic: parámVariadic
        pragmas: (Mapear: pragmasYCuerpo#parteVerdadera, &(Pragma#desdeTupla))
        cuerpo: pragmasYCuerpo#parteFalsa
    finclonar
finmetodo

metodo DeclrFunción#comoTexto
    devolver {(DeclrFunción ~t con ~t (~t) es ~t / ~t)}#formatear:
        yo#nombre, yo#parámetros, yo#parámetroVariadic, yo#pragmas, yo#cuerpo
finmetodo

metodo DeclrFunción#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: ({PROC ~t~%}#formatear: yo#nombre)
    ParaCadaElemento: yo#pragmas, procedimiento: pragma
        pragma#emitirComoIR: puertoDeEscritura
    finprocedimiento
    ParaCadaElemento: yo#parámetros, procedimiento: param
        puertoDeEscritura#escribirTexto: ({PARAM ~t~%}#formatear: param)
    finprocedimiento
    si no EsNulo: yo#parámetroVariadic
        puertoDeEscritura#escribirTexto: ({VARIADIC ~t~%}#formatear: yo#parámetroVariadic)
    finsi
    ParaCadaElemento: yo#cuerpo, procedimiento: tupla
        tupla#emitirComoIR: puertoDeEscritura
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDPROC~%}#formatear
finmetodo

metodo DeclrFunción#comoSExpr
    variable variadic
    si no EsNulo: yo#parámetroVariadic
        fijar variadic a Arreglo#crearCon: (Arreglo#crearCon: (Símbolo#desdeTexto: {variadic}), yo#parámetroVariadic)
    sino
        fijar variadic a Arreglo#vacio
    finsi
    devolver Arreglo#crearCon:
        (Símbolo#desdeTexto: {proc}),
        yo#nombre,
        (Arreglo#crearCon: (Símbolo#desdeTexto: {pragmas}),
            ...(Mapear: yo#pragmas, (MétodoComoFunción: {comoSExpr}))),
        (Arreglo#crearCon: (Símbolo#desdeTexto: {params}), ...(yo#parámetros)),
        ...(variadic),
        (Arreglo#crearCon: (Símbolo#desdeTexto: {body}),
            ...(Mapear: yo#cuerpo, (MétodoComoFunción: {comoSExpr})))
finmetodo

metodo estatico DeclrFunción#desdeSExpr: sexpr
    variables nombre, pragmas, params, variadic, variadicS, cuerpo, cuerpoS
    fijar nombre a sexpr#en: 1
    fijar pragmas a Mapear: (PedazoDeArreglo: (sexpr#en: 2), 1, -1), &(Pragma#desdeSExpr)
    fijar params a PedazoDeArreglo: (sexpr#en: 3), 1, -1
    fijar variadicS a sexpr#en: 4
    si (variadicS#en: 0)#valor = {variadic}
        fijar variadic a variadicS#en: 1
        fijar cuerpoS a sexpr#en: 5
    sino
        fijar variadic a NULO
        fijar cuerpoS a variadicS
    finsi
    fijar cuerpo a Mapear: (PedazoDeArreglo: cuerpoS, 1, -1), &(Tupla#desdeSExpr)
    devolver yo#crear: nombre, params, variadic, (Concatenar: (Mapear: pragmas, (MétodoComoFunción: {comoTupla})), cuerpo)
finmetodo

[DOCUMENTA
@brief{Un prototipo para una llamada variadic.}

Indica cuales valores en la pila deben ser "expandidos" antes de ser usados
como argumentos.
DOCUMENTA]
clase PrototipoDeLlamada
    [DOCUMENTA
    @brief{El prototipo.}

    Es un arreglo de valores booleanos. Si un valor es @pd{VERDADERO} entonces
    su argumento correspondiente en la pila es variadic y debe ser
    expandido. Si es @pd{FALSO} entonces es un argumento normal.
    DOCUMENTA]
    atributo prototipo

    [DOCUMENTA
    @brief{Crea un nuevo prototipo.}
    DOCUMENTA]
    metodo estatico crear: prototipo

    [DOCUMENTA
    @brief{Devuelve una representación textual del prototipo.}
    DOCUMENTA]
    metodo comoTexto

    metodo emitirComoIR: puertoDeEscritura
    metodo comoSExpr
    metodo estatico desdeSExpr: sexpr
finclase

metodo PrototipoDeLlamada#inicializar: proto
    fijar yo#prototipo a proto
finmetodo

metodo PrototipoDeLlamada#comoTexto
    devolver {(PrototipoDeLlamada ~t)}#formatear: yo#prototipo
finmetodo

metodo PrototipoDeLlamada#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {PROTOTYPE }
    ParaCadaElementoConÍndice: yo#prototipo, procedimiento: x, i
        si i > 0
            puertoDeEscritura#escribirTexto: {, }
        finsi
        puertoDeEscritura#escribirTexto: (x#escojer: {1}, {0})
    finprocedimiento
    puertoDeEscritura#escribirTexto: {~%}#formatear
finmetodo

metodo PrototipoDeLlamada#comoSExpr
    devolver Arreglo#crearCon: (Símbolo#desdeTexto: {prototype}), ...(yo#prototipo)
finmetodo

metodo estatico PrototipoDeLlamada#desdeSExpr: sexpr
    devolver yo#crear: (PedazoDeArreglo: sexpr, 1, -1)
finmetodo

clase TextoDelIR
    atributo valor
    metodo emitirComoIR: puertoDeEscritura
    metodo comoSExpr
    metodo estatico desdeSExpr: sexpr
finclase

metodo TextoDelIR#inicializar: valor
    fijar yo#valor a valor
finmetodo

metodo TextoDelIR#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {STRING "}
    puertoDeEscritura#escribirTexto: (EscaparParaPDVM: yo#valor)
    puertoDeEscritura#escribirTexto: {"~%}#formatear
finmetodo

metodo TextoDelIR#comoTexto
    devolver {(TextoDelIR "~t")}#formatear: (EscaparParaPDVM: yo#valor)
finmetodo

metodo TextoDelIR#comoSExpr
    devolver Arreglo#crearCon: (Símbolo#desdeTexto: {string}), yo#valor
finmetodo

metodo estatico TextoDelIR#desdeSExpr: sexpr
    devolver yo#crear: (sexpr#en: 1)
finmetodo


[DOCUMENTA
@brief{Una constante en el IR.}

Representa un mapeo de un ID de constante a la constante.

Aunque nada te lo prohibe, no deberías usar constantes para representar números
"pequeños" (menores a 2^32). Para estos usa el opcode @code{ICONST}.
DOCUMENTA]
clase Constante
    [DOCUMENTA
    @brief{Id de la constante.}
    DOCUMENTA]
    atributo id

    [DOCUMENTA
    @brief{Valor de la constante.}

    Puede ser un número, un texto o un @pd{PrototipoDeLlamada}.
    DOCUMENTA]
    atributo valor

    [DOCUMENTA
    @brief{Crea una nueva constante y la devuelve.}
    DOCUMENTA]
    metodo estatico crear: id, valor

    [DOCUMENTA
    @brief{Devuelve una representación textual del mapeo de la constante.}
    DOCUMENTA]
    metodo comoTexto

    metodo emitirComoIR: puertoDeEscritura

    metodo comoSExpr
    metodo estatico desdeSExpr: sexpr
finclase

metodo estatico Constante#crear: id, valor
    devolver clonar yo#_crear con
        id: id
        valor: valor
    finclonar
finmetodo

metodo Constante#comoTexto
    devolver {(Constante#crear: ~t, ~t)}#formatear: yo#id, yo#valor
finmetodo

metodo Constante#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {#}
    puertoDeEscritura#escribirTexto: yo#id#comoTexto
    puertoDeEscritura#escribirTexto: { }
    yo#valor#emitirComoIR: puertoDeEscritura
finmetodo

metodo Constante#comoSExpr
    devolver Arreglo#crearCon: (Símbolo#desdeTexto: {constant}), yo#id, yo#valor#comoSExpr
finmetodo

metodo estatico Constante#desdeSExpr: sexpr
    variables valor, el
    fijar el a sexpr#en: 2
    si (el#en: 0)#valor = {string}
        fijar valor a TextoDelIR#desdeSExpr: el
    sino
        necesitas (el#en: 0)#valor = {prototype}
        fijar valor a PrototipoDeLlamada#desdeSExpr: el
    finsi
    devolver yo#crear: (sexpr#en: 1), valor
finmetodo


[DOCUMENTA
@brief{Un fragmento de compilación.}

Un compilado representa un fragmento de la compilación. Contiene un arreglo de
instrucciones, una secuencia de declaraciones y una secuencia de constantes. El
orden de las declaraciones y constantes no importa, pero el de las
instrucciones sí.
DOCUMENTA]
clase Compilado
    [DOCUMENTA
    @brief{Arreglo de tuplas, que son las instrucciones de este compilado.}
    DOCUMENTA]
    atributo instrucciones

    [DOCUMENTA
    @brief{Arreglo de declaraciones.}

    Actualmente la única declaración válida es @pd{DeclrFunción}.
    DOCUMENTA]
    atributo declaraciones

    [DOCUMENTA
    @brief{Constantes de este compilado.}

    Arreglo de @pd{Constante}s.
    DOCUMENTA]
    atributo constantes

    [DOCUMENTA
    @brief{Crea un compilado con los datos dados.}
    DOCUMENTA]
    metodo estatico crear: instrucciones, declaraciones, constantes

    [DOCUMENTA
    @brief{Crea un compilado sin constantes ni declaraciones.}
    DOCUMENTA]
    metodo estatico deInstrucciónes: instrucciones

    [DOCUMENTA
    @brief{Crea un compilado sin instrucciones ni constantes.}
    DOCUMENTA]
    metodo estatico deDeclaraciones: declaraciones

    [DOCUMENTA
    @brief{Crea un compilado sin instrucciones ni declaraciones.}
    DOCUMENTA]
    metodo estatico deConstantes: constantes

    [DOCUMENTA
    @brief{Secuencia dos compilados.}

    Mezcla las declaraciones y constantes de los compilados @pd{yo} y
    @pd{otro}. Además, las instrucciones de @pd{yo} son concatenadas
    @bold{antes} que las de @pd{otro}.

    El resultado de esto es un nuevo compilado cuyas instrucciones son primero
    las de @pd{yo} y después las de @pd{otro}, con todo lo demás en un orden no
    especificado.
    DOCUMENTA]
    metodo \operador_>>\: otro

    [DOCUMENTA
    @brief{Devuelve el valor de la constante con ID @pd{idDeConstante}.}
    DOCUMENTA]
    metodo valorDeLaConstante: idDeConstante

    [DOCUMENTA
    @brief{Devuelve una representación textual del compilado.}
    DOCUMENTA]
    metodo comoTexto

    metodo emitirComoIR: puertoDeEscritura
    metodo comoSExpr
    metodo estatico desdeSExpr: sexpr
finclase

metodo estatico Compilado#crear: i, d, c
    devolver clonar yo#_crear con
        instrucciones: i
        declaraciones: d
        constantes: c
    finclonar
finmetodo

metodo estatico Compilado#deInstrucciónes: i
    devolver Compilado#crear: i, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo estatico Compilado#deDeclaraciones: d
    devolver Compilado#crear: Arreglo#vacio, d, Arreglo#vacio
finmetodo

metodo estatico Compilado#deConstantes: c
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, c
finmetodo

metodo estatico Compilado#vacío
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo Compilado#operador_>>: otro
    devolver Compilado#crear:
        (Concatenar: yo#instrucciones, otro#instrucciones),
        (Concatenar: yo#declaraciones, otro#declaraciones),
        (Concatenar: yo#constantes, otro#constantes)
finmetodo

metodo Compilado#valorDeLaConstante: idDeConstante
    variable encontrados
    fijar encontrados a Filtrar: yo#constantes, funcion: const
        devolver const#id = idDeConstante
    finfuncion
    si no (encontrados#longitud = 1)
        Escribir: {%%%%%%}, encontrados, idDeConstante, yo#constantes
    finsi
    necesitas encontrados#longitud = 1
    devolver (encontrados#en: 0)#valor
finmetodo

metodo Compilado#comoTexto
    devolver {(Compilado ds = ~t, is = ~t, cs = ~t)}#formatear: yo#declaraciones, yo#instrucciones, yo#constantes
finmetodo

metodo Compilado#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {PDVM 1.0~%}#formatear
    puertoDeEscritura#escribirTexto: {PLATFORM "pdcrt"~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "code"~%}#formatear
    ParaCadaElemento: yo#instrucciones, procedimiento: instr
        instr#emitirComoIR: puertoDeEscritura
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "procedures"~%}#formatear
    ParaCadaElemento: yo#declaraciones, procedimiento: declr
        declr#emitirComoIR: puertoDeEscritura
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "constant pool"~%}#formatear
    ParaCadaElemento: yo#constantes, procedimiento: constante
        constante#emitirComoIR: puertoDeEscritura
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%}#formatear
finmetodo

metodo Compilado#comoSExpr
    devolver Arreglo#crearCon:
        (Símbolo#desdeTexto: {compiled}),
        (Arreglo#crearCon:
            (Símbolo#desdeTexto: {code}),
            ...(Mapear: yo#instrucciones, (MétodoComoFunción: {comoSExpr}))),
        (Arreglo#crearCon:
            (Símbolo#desdeTexto: {procedures}),
            ...(Mapear: yo#declaraciones, (MétodoComoFunción: {comoSExpr}))),
        (Arreglo#crearCon:
            (Símbolo#desdeTexto: {constants}),
            ...(Mapear: yo#constantes, (MétodoComoFunción: {comoSExpr})))
finmetodo

metodo estatico Compilado#desdeSExpr: sexpr
    devolver yo#crear:
        (Mapear: (PedazoDeArreglo: (sexpr#en: 1), 1, -1), &(Tupla#desdeSExpr)),
        (Mapear: (PedazoDeArreglo: (sexpr#en: 2), 1, -1), &(DeclrFunción#desdeSExpr)),
        (Mapear: (PedazoDeArreglo: (sexpr#en: 3), 1, -1), &(Constante#desdeSExpr))
finmetodo

[DOCUMENTA
@brief{Secuencia todos los compilados.}

@pd{partes} debe ser un arreglo de compilados que serán secuenciados con
@code{>>} en orden. Devuelve el resultado de secuenciarlos.
DOCUMENTA]
funcion UnirCompilados: partes
    devolver Reducir: Compilado#vacío, (OperadorBinario: {>>}), partes
finfuncion

[DOCUMENTA
@brief{Devuelve un compilado con las instrucciones dadas.}

El compilado no tendrá ni constantes ni declaraciones.
DOCUMENTA]
funcion Instrucciones: ...Is
    devolver Compilado#deInstrucciónes: Is
finfuncion


[DOCUMENTA
@brief{Obtiene los nombres definídos sin parámetros de una
función/método/procedimiento.}

Devuelve el valor del metadato @code{nombresDefinídosSinParámetros} (con llave
@pd{RN#LLAVE_RESOLUCIÓN_DE_NOMBRES}).
DOCUMENTA]
funcion NombresDefinídosSinParámetros: ast
    devolver ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSinParámetros}
finfuncion

[DOCUMENTA
@brief{Obtiene los nombres resueltos de los parámetros de un
método/función/procedimiento.}

@pd{ast} debe ser un @pd{AST#NodoFunción}, @pd{AST#NodoFunciónAnónima},
@pd{AST#NodoMétodo} o @pd{AST#NodoDefineMétodoEnClase}. Devuelve un arreglo con
los nombres resueltos de los parámetros (en orden), excluyendo el parámetro
variadic, si existe.
DOCUMENTA]
funcion NombresDeLosParámetrosNoVariadic: ast
    devolver Mapear:
        (Filtrar: ast#parámetros,
                  funcion: param
                      devolver no EsInstancia: param, AST#NodoVariadic
                  finfuncion),
        &(RN#NombreResueltoDe)
finfuncion

[DOCUMENTA
@brief{Devuelve el parámetro variadic, o @pd{NULO} si no hay ninguno.}

@pd{ast} debe ser un @pd{AST#NodoFunción}, @pd{AST#NodoFunciónAnónima},
@pd{AST#NodoMétodo} o @pd{AST#NodoDefineMétodoEnClase}. Devuelve el
@pd{AST#NodoVariadic} o @pd{NULO}.
DOCUMENTA]
funcion ParámetroVariadic: ast
    variable variadics
    fijar variadics a Filtrar: ast#parámetros, funcion: param
        devolver EsInstancia: param, AST#NodoVariadic
    finfuncion
    si variadics#longitud = 0
        devolver NULO
    sino
        necesitas variadics#longitud = 1
        devolver variadics#en: 0
    finsi
finfuncion


[DOCUMENTA
@brief{Obtiene las locales del procedimiento.}

A pesar de lo que su nombre indica, solo funciona con nodos con el metadato
@code{localesDelProcedimiento} (funciones, métodos, procedimientos y
@pd{AST#NodoPrograma}).
DOCUMENTA]
funcion LocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
finfuncion

[DOCUMENTA
@brief{Obtiene los bindings locales del procedimiento.}

Solo funciona con los mismos nodos que @pd{LocalesDelBloque}.
DOCUMENTA]
funcion BindingsLocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}
finfuncion

variable ContadorDeEtiquetas
fijar ContadorDeEtiquetas a 0
[DOCUMENTA
@brief{Devuelve una nueva etiqueta.}

Devuelve un número único que sirve como etiqueta para las instrucciones de
control de flujo (@code{JMP} y @code{CHOOSE}).
DOCUMENTA]
procedimiento GenerarEtiqueta
    fijar ContadorDeEtiquetas a ContadorDeEtiquetas + 1
    devolver ContadorDeEtiquetas
finprocedimiento

variable ContadorDeConstantes
fijar ContadorDeConstantes a 0
[DOCUMENTA
@brief{Devuelve un nuevo ID de constante.}

Devuelve un número único que sirve como ID de constante.
DOCUMENTA]
procedimiento GenerarIdDeConstante
    fijar ContadorDeConstantes a ContadorDeConstantes + 1
    devolver ContadorDeConstantes
finprocedimiento

variable ContadorDeProcedimientos
fijar ContadorDeProcedimientos a 0
[DOCUMENTA
@brief{Devuelve un nuevo ID para un procedimiento.}

Devuelve un número único que sirve como ID de un procedimiento.
DOCUMENTA]
procedimiento GenerarIdDeProcedimiento
    fijar ContadorDeProcedimientos a ContadorDeProcedimientos + 1
    devolver ContadorDeProcedimientos
finprocedimiento

[ TODO: Renombra todas las funciones de compilación de "WASM" a "Tuplas". ]

[DOCUMENTA
@brief{Compila un arreglo de instrucciones a un compilado.}

@pd{instrucciones} debe ser un arreglo de @pd{AST#NodoInstrucción}. Esta
función automaticamente se encarga de dejar la pila en un estado apropiado
cuando se encuentra a una expresión en una posición de instrucción.

@pd{builtins} debe ser un diccionario mapeando los nombres de los builtins de
este backend a sus nombres resueltos.
DOCUMENTA]
funcion CompilarBloqueAWasm: instrucciones, builtins
    variable res
    fijar res a Compilado#vacío
    ParaCadaElemento: instrucciones, procedimiento: instr
        fijar res a res >> (CompilarAWasm: instr, builtins)
        si EsInstancia: instr, AST#NodoExpresion
            fijar res a res >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#POP))
        finsi
    finprocedimiento
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila un identificador.}

@pd{ast} debe ser el @pd{AST#NodoIdentificador} o el @pd{LocalDelProcedimiento}
que se obtendrá.

Devuelve un compilado que obtiene la variable @pd{ast} y la empuja en la pila.
DOCUMENTA]
funcion CompilarIdentificador: ast
    variables altura, índiceDeCaptura, estáEnElEntorno, op, binding
    si EsInstancia: ast, AST#NodoIdentificador
        fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        fijar estáEnElEntorno a EstáEnElEntorno: ast
        fijar binding a RN#NombreResueltoDe: ast
    sino
        necesitas EsInstancia: ast, LocalDelProcedimiento
        fijar altura a ast#altura
        fijar índiceDeCaptura a ast#índiceDeCaptura
        fijar estáEnElEntorno a ast#estáEnElEntorno
        fijar binding a ast#binding
    finsi

    si estáEnElEntorno
        fijar op a OP#LGETC: LocalDelEntornoActual, altura, índiceDeCaptura
    sino
        fijar op a OP#LGET: binding
    finsi
    devolver Compilado#deInstrucciónes: (Arreglo#crearCon: op)
finfuncion

[DOCUMENTA
@brief{Compila el fijar un identificador.}

@pd{ast} debe ser el @pd{AST#NodoIdentificador} o el @pd{LocalDelProcedimiento}
que se fijará.

Devuelve un compilado que saca un valor de la pila y fija la variable @pd{ast}
a dicho valor.
DOCUMENTA]
funcion CompilarFijarIdentificador: ast
    variables altura, índiceDeCaptura, estáEnElEntorno, op, binding
    si EsInstancia: ast, AST#NodoIdentificador
        fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        fijar estáEnElEntorno a EstáEnElEntorno: ast
        fijar binding a RN#NombreResueltoDe: ast
    sino
        necesitas EsInstancia: ast, LocalDelProcedimiento
        fijar altura a ast#altura
        fijar índiceDeCaptura a ast#índiceDeCaptura
        fijar estáEnElEntorno a ast#estáEnElEntorno
        fijar binding a ast#binding
    finsi

    si estáEnElEntorno
        fijar op a OP#LSETC: LocalDelEntornoActual, altura, índiceDeCaptura
    sino
        fijar op a OP#LSET: binding
    finsi
    devolver Compilado#deInstrucciónes: (Arreglo#crearCon: op)
finfuncion

[DOCUMENTA
@brief{Compila las declaraciones de las locales de un procedimiento.}

Devuelve un arreglo con todas las declaraciones @code{LOCAL} necesarias.

@params(
@defparam(locales){Arreglo de las variables locales (generado con
@pd{EnumeraciónDeLocalesDeProcedimiento}) del bloque.}

@defparam(parámetros){Los parámetros del método, función o procedimiento como
un arreglo de bindings. Si se esta compilando un bloque que no es uno de estos,
@pd{parámetros} debería ser un arreglo vacío. Este parámetro es necesario
porque los parámetros son locales pero no deberían estar declarados con
@code{LOCAL} (excepto el parámetro variadic que si debe ser declarado con
@code{LOCAL}).}

@defparam(localYo){El local de la declaración de la variable @pd{yo} implícita
en este método. Si no se esta compilando un método, debe ser @pd{NULO}.}
)
DOCUMENTA]
funcion CompilarLocales: locales, parámetros, localYo
    variable variadics
    fijar variadics a Filtrar: parámetros, funcion: param
        devolver EsInstancia: param, AST#NodoVariadic
    finfuncion
    necesitas (variadics#longitud = 0) || (variadics#longitud = 1)
    funcion índiceDeCaptura: nodo
        variable nid
        si EsInstancia: nodo, AST#NodoVariadic
            fijar nid a nodo#interno
        sino
            fijar nid a nodo
        finsi
        devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    finfuncion
    variables índices, bindingYo
    fijar índices a (Mapear: parámetros, &índiceDeCaptura)
    si no EsNulo: localYo
        fijar bindingYo a localYo#binding
    sino
        fijar bindingYo a NULO
    finsi
    devolver
        Mapear:
            (Concatenar:
                (Únicos:
                    (Mapear: (Filtrar: locales,
                                    funcion: meta
                                        devolver (no meta#estáEnElEntorno) && (no Contiene: índices, meta#índiceDeCaptura) && (no meta#binding = bindingYo)
                                    finfuncion),
                             funcion: local
                                 devolver local#binding
                             finfuncion)),
                (Mapear: variadics, funcion: variadic
                    devolver RN#NombreResueltoDe: variadic#interno
                finfuncion)),
            funcion: registro
                devolver OP#LOCAL: registro
            finfuncion
finfuncion

[DOCUMENTA
@brief{Mapea un arreglo, manteniendo solo los valores únicos de una llave
dada.}

Mapea cada elemento de @pd{arr} con @pd{func}, pero solo mantiene elementos
para los que @pd{unicos} (una función de la forma @pd{%unicos: elemento})
devuelva un valor único. Por ejemplo:

@ejemplo|{
utilizar bepd/x/adhoc (ObjetoAdHoc)

funcion Usuario: nombre, id
    devolver ObjetoAdHoc: {nombre}, nombre, {id}, id
finfuncion

variable A
fijar A a Arreglo#crearCon:
    (Usuario: {Miguel}, 1),
    (Usuario: {María}, 2),
    (Usuario: {Miguel (otra cuenta)}, 1)
necesitas (MapearÚnicos: A,
                         funcion: usuario
                             devolver usuario#id
                         finfuncion,
                         funcion: usuario
                             devolver usuario#nombre
                         finfuncion)
          =
          (Arreglo#crearCon: {Miguel}, {María})
}|

DOCUMENTA]
funcion MapearÚnicos: arr, unicos, func
    variables res, llaves
    fijar res a Arreglo#vacio
    fijar llaves a Conjunto#vacío
    ParaCadaElemento: arr, procedimiento: el
        variable llave
        fijar llave a %unicos: el
        si no (llaves#contiene: llave)
            fijar llaves a llaves#unión: (Conjunto#conValores: llave)
            res#agregarAlFinal: (%func: el)
        finsi
    finprocedimiento
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila las instrucciones @code{OPNFRM}...@code{CLSFRM} de un bloque.}

Devuelve un arreglo de instrucciones que crea e inicializa el entorno del
bloque actual, asignándolo a @code{EACT} apropiadamente.

@params(
@defparam(capturas){Un arreglo con las variables locales (producidas por
@pd{EnumeraciónDeLocalesDeProcedimiento}) que son capturadas (su atributo
@code{#esCapturado} debe ser verdadero). Puedes obtener este arreglo con
@pd{VariablesLocalesCapturadas}.}

@defparam(localesEnElEntorno){Las locales del entorno, tal como fueron
devueltas por @pd{LocalesDelBloque}.}

@defparam(localesInmediatas){Arreglo con las locales inmediatas del bloque.}

@defparam(exísteMarcoSuperior){@pd{Boole} que indica si exíste
@code{ESUP}. Determina si el entorno tendrá marco superior.}

@defparam(profundidad){Profundidad en el programa en la que el ámbito se
encuentra.}

@defparam(localYo){Local con el parámetro @code{yo} (si es un método).}
)
DOCUMENTA]
funcion CompilarEntornoDelÁmbito: parámetros, localesEnElEntorno, localesInmediatas, exísteMarcoSuperior, profundidad, localYo
    variables ops, máximoÍndiceDeLocalEnElEntorno, localesSiSonParámetros, nrsParámetros
    fijar ops a Arreglo#vacio
    fijar máximoÍndiceDeLocalEnElEntorno a Reducir: -1, &Max,
        (Mapear: (Filtrar: localesInmediatas, (MétodoComoFunción: {estáEnElEntorno})), (MétodoComoFunción: {índiceDeCaptura}))
    [ máximoÍndiceDeLocalEnElEntorno es el máximo ind. de los locales
      capturados, o -1 si no hay ninguno. De esta forma,
      máximoÍndiceDeLocalCapturado + 1 es el tamaño mínimo necesario para el
      marco de activación ("marco de llamada" o "call-frame") ]
    ops#agregarAlFinal: (OP#OPNFRM: LocalDelEntornoActual, (exísteMarcoSuperior#escojer: LocalDelEntornoSuperior, {NIL}), (máximoÍndiceDeLocalEnElEntorno + 1))
    fijar nrsParámetros a Mapear: parámetros, funcion: param
        si EsInstancia: param, AST#NodoVariadic
            devolver RN#NombreResueltoDe: param#interno
        sino
            devolver RN#NombreResueltoDe: param
        finsi
    finfuncion
    si no EsNulo: localYo
        nrsParámetros#agregarAlFinal: localYo#binding
    finsi
    fijar localesSiSonParámetros a SepararArreglo: localesInmediatas, funcion: local
        devolver Contiene: nrsParámetros, local#binding
    finfuncion
    ops#agregarAlFinal: (MapearÚnicos: (Filtrar: localesSiSonParámetros#parteVerdadera, (MétodoComoFunción: {estáEnElEntorno})),
                                       funcion: local
                                           devolver local#índiceDeCaptura
                                       finfuncion,
                                       funcion: local
                                           devolver OP#EINIT: LocalDelEntornoActual, local#índiceDeCaptura, local#binding
                                       finfuncion)
    ops#agregarAlFinal: (MapearÚnicos: (Filtrar: localesSiSonParámetros#parteFalsa, (MétodoComoFunción: {estáEnElEntorno})),
                                       funcion: local
                                           devolver local#índiceDeCaptura
                                       finfuncion,
                                       funcion: local
                                           devolver OP#ENEW: LocalDelEntornoActual, local#índiceDeCaptura
                                       finfuncion)
    ops#agregarAlFinal: (OP#CLSFRM: LocalDelEntornoActual)
    devolver ops
finfuncion

[DOCUMENTA
@brief{Filtra un arreglo de locales para obtener las capturas de un bloque.}

Devuelve un arreglo con las variables locales capturadas.
DOCUMENTA]
funcion VariablesLocalesCapturadas: locales
    devolver Únicos: (Filtrar: locales, (MétodoComoFunción: {esCapturado}))
finfuncion

[DOCUMENTA
@brief{Filtra un arreglo de locales para obtener las que están en el entorno.}

Devuelve un arreglo con las locales que están en el entorno de la
función/método/procedimiento.
DOCUMENTA]
funcion VariablesEnElEntorno: locales
    devolver Únicos: (Filtrar: locales, (MétodoComoFunción: {estáEnElEntorno}))
finfuncion

[DOCUMENTA
@brief{Compila los locales y el entorno de un bloque.}

Llama a @pd{CompilarLocales} y @pd{CompilarEntornoDelÁmbito}, acumulando sus
resultados. Devuelve un arreglo de instrucciones que sirve como "inicio" o
"preludio" de un bloque.
DOCUMENTA]
funcion CompilarLocalesYClosure: locales, localesEnElEntorno, localesInmediatas, parámetros, exísteMarcoSuperior, profundidad, localYo
    devolver Concatenar:
        (CompilarLocales: locales, parámetros, localYo),
        (CompilarEntornoDelÁmbito: parámetros, localesEnElEntorno, localesInmediatas, exísteMarcoSuperior, profundidad, localYo)
finfuncion

[DOCUMENTA
@brief{Escribe dos valores pero devuelve uno.}

Escribe tanto @pd{A} como @pd{B} y devuelve @pd{B}.
DOCUMENTA]
funcion Inspeccionar: A, B
    Escribir: A, B
    devolver B
finfuncion

[DOCUMENTA
@brief{Compila los argumentos de una llamada a función.}

@pd{argumentos} es el arreglo con los @pd{AST#NodoExpresion}s a
compilar. @pd{compilarExpr} es una función que se llamará sobre cada argumento
para compilarlo.

Devuelve un objeto con los siguientes atributos:

@itemlist(

@item{@code{compilado}: el compilado del código que prepara la pila para la
llamada a la función.}

@item{@code{numValoresEnLaPila}: el número de valores que está en la pila antes
de llamar a la función. Dicho de otra forma: el número de valores que el
compilado devuelto empujo a la pila.}

@item{@code{variadics}: un booleano indicando si se debe realizar una llamada
variadic o no. Si es @pd{VERDADERO} debes usar los opcodes
@code{MSGV}/@code{DYNMSGV}/etc. Si es @pd{FALSO} debes usar los opcodes
@code{MSG}/@code{DYNMSG}/etc.}

@item{@code{prototipo}: Este atributo solo existe si @code{variadics} es
@pd{VERDADERO}. Es el índice de la constante que contiene al prototipo de la
llamada.}

)
DOCUMENTA]
funcion CompilarArgumentos: argumentos, compilarExpr
    variable bloques
    fijar bloques a Mapear: argumentos, funcion: arg
        si EsInstancia: arg, AST#NodoVariadic
            devolver ObjetoAdHoc: {variadic}, VERDADERO,
                                  {compilado}, (%compilarExpr: arg#interno)
        sino
            devolver ObjetoAdHoc: {variadic}, FALSO,
                                  {compilado}, (%compilarExpr: arg)
        finsi
    finfuncion

    variables compilado, prototipo, variadics
    fijar prototipo a PrototipoDeLlamada#crear: (Mapear: bloques, funcion: bloque
        devolver bloque#variadic
    finfuncion)
    fijar compilado a Reducir: Compilado#vacío, funcion: acc, bloque
        devolver acc >> bloque#compilado
    finfuncion, bloques
    fijar compilado a compilado >> (Instrucciones: (OP#ROT: argumentos#longitud))
    fijar variadics a Filtrar: argumentos, funcion: arg
        devolver EsInstancia: arg, AST#NodoVariadic
    finfuncion

    si variadics#longitud = 0
        devolver ObjetoAdHoc: {compilado}, compilado,
                              {variadics}, FALSO,
                              {numValoresEnLaPila}, argumentos#longitud
    sino
        devolver ObjetoAdHoc: {compilado}, compilado,
                              {variadics}, VERDADERO,
                              {numValoresEnLaPila}, argumentos#longitud,
                              {prototipo}, prototipo
    finsi
finfuncion

funcion CompilarLlamadaAFunción: argumentos, opLlamar, opLlamarVrd, numResultados, builtins
    variables argumentosCompilados, op
    fijar argumentosCompilados a CompilarArgumentos: argumentos, funcion: expr
        devolver CompilarAWasm: expr, builtins
    finfuncion
    si argumentosCompilados#variadics
        variable constPrototipo
        fijar constPrototipo a GenerarIdDeConstante
        fijar op a (%opLlamarVrd: argumentosCompilados#numValoresEnLaPila, constPrototipo, argumentosCompilados#prototipo, numResultados)
                >> (Compilado#deConstantes:
                        (Arreglo#crearCon:
                            (Constante#crear: constPrototipo, argumentosCompilados#prototipo)))
    sino
        fijar op a %opLlamar: argumentosCompilados#numValoresEnLaPila, numResultados
    finsi
    devolver argumentosCompilados#compilado >> op
finfuncion

[DOCUMENTA
@brief{Crea un compilado que agrega un atributo a una clase.}

@pd{compiladoParaObtenerClase} debe ser el compilado que empuja en la pila la
clase a la que se le agregará el atributo. @pd{nombreDelAtributo} es un
@pd{Texto} que es el nombre del atributo a agregar.
DOCUMENTA]
funcion CompilarAgregarAtributo: compiladoParaObtenerClase, nombreDelAtributo
    variables constAtributo, constAgregarAtributo
    fijar constAtributo a GenerarIdDeConstante
    fijar constAgregarAtributo a GenerarIdDeConstante
    devolver (Compilado#deConstantes:
                 (Arreglo#crearCon:
                     (Constante#crear: constAtributo, (TextoDelIR#crear: nombreDelAtributo)),
                     (Constante#crear: constAgregarAtributo, (TextoDelIR#crear: {agregarAtributo}))))
          >> compiladoParaObtenerClase
          >> (Instrucciones: (OP#LCONST: constAtributo),
                             (OP#ROT: 1),
                             (OP#MSG: constAgregarAtributo, 1, 0))
finfuncion


[DOCUMENTA
@brief{Obtiene todas las declaraciones de una lista de nodos.}

@devuelve{Aquellos nodos de @pd{nodos} que declaren algún nombre.}
DOCUMENTA]
funcion DeclaracionesEn: nodos
    variable DECLARACIONES
    fijar DECLARACIONES a Arreglo#crearCon:
        AST#NodoVariable, AST#NodoFunción, AST#NodoClase, AST#NodoUtilizar
    funcion esDeclaración: nodo
        devolver Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo))
    finfuncion
    devolver Filtrar: nodos, funcion: nodo devolver esDeclaración: nodo finfuncion
finfuncion

funcion ObtenerLocal: nid
    devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {local}
finfuncion

[DOCUMENTA
@brief{Obtiene los nombres declarados en todos los @pd{nodos}.}

@devuelve{Un arreglo con todos los datos de las locales
(@pd{LocalDelProcedimiento}) que fueron declarados en @pd{nodos}.}
DOCUMENTA]
funcion NombresDeclaradosEn: nodos
    variable declrs
    fijar declrs a DeclaracionesEn: nodos
    devolver Aplanar: (Mapear: declrs, funcion: nodo
        si EsInstancia: nodo, AST#NodoVariable
            devolver Mapear: nodo#nombres, &ObtenerLocal
        finsi
        si (EsInstancia: nodo, AST#NodoFunción) || (EsInstancia: nodo, AST#NodoClase)
            devolver Arreglo#crearCon: (ObtenerLocal: nodo#nombre)
        finsi
        si EsInstancia: nodo, AST#NodoUtilizar
            variable locales
            fijar locales a Arreglo#vacio
            si no EsNulo: nodo#espacioDeNombres
                locales#agregarAlFinal: (ObtenerLocal: nodo#espacioDeNombres)
            finsi
            si no EsNulo: nodo#nombresEspecíficos
                ParaCadaElemento: nodo#nombresEspecíficos, procedimiento: nombreORenombre
                    si EsInstancia: nombreORenombre, AST#NodoIdentificador
                        locales#agregarAlFinal: (ObtenerLocal: nombreORenombre)
                    sino
                        locales#agregarAlFinal: (ObtenerLocal: (nombreORenombre#en: 1))
                    finsi
                finprocedimiento
            finsi
            devolver Concatenar: locales, (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesImportadas})
        finsi
        Escribir: {###}, nodo
        Inalcanzable
    finfuncion)
finfuncion

funcion LocalesInmediatas: locales, ámbito
    variable bindingsLocales
    fijar bindingsLocales a Conjunto#desdeArreglo: ámbito#todosLosBindingsLocales
    devolver Filtrar: locales, funcion: local
        devolver bindingsLocales#contiene: local#binding
    finfuncion
finfuncion

procedimiento MarcaSiHayQueImportarBuiltins: ast, hayQueImportarBuiltins
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {hayQueImportarBuiltins}, hayQueImportarBuiltins
finprocedimiento

funcion NombreDelMarco: nombre, área
    si no EsNulo: área
        fijar nombre a {~t: ~t}#formatear: área, nombre
    finsi
    devolver Instrucciones: (OP#PRAGMA: {FRAME_NAME}, nombre)
finfuncion

[DOCUMENTA
@brief{Compila una instrucción o expresión a un compilado.}

Devuelve un @pd{Compilado} con el resultado de compilar @pd{ast}. Si @pd{ast}
es un @pd{AST#NodoExpresion} entonces el compilado dejará en la pila el
resultado de la expresión. Si es un @pd{AST#NodoInstrucción} entonces no dejará
valores en la pila.
DOCUMENTA]
funcion CompilarAWasm: ast, builtins
    si EsInstancia: ast, AST#NodoPrograma
        variables locales, localesEnElEntorno, profundidad, localesInmediatas,
                  exportaciones, importaciones, identificadoresDefinídos,
                  ámbito, constNombreDelMódulo, constBootstrap, nombreDelMódulo,
                  índicesDeBuiltins, alturaDeBuiltins, hayQueImportarBuiltins
        fijar locales a LocalesDelBloque: ast
        fijar localesEnElEntorno a VariablesEnElEntorno: locales
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar exportaciones a Compilado#vacío
        fijar importaciones a Compilado#vacío
        fijar ámbito a RN#ObtenerNombresDefinídos: ast
        fijar localesInmediatas a LocalesInmediatas: locales, ámbito
        fijar identificadoresDefinídos a NombresDeclaradosEn: ast#instrucciones
        fijar constNombreDelMódulo a GenerarIdDeConstante
        fijar nombreDelMódulo a (ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {llaveDelMódulo})#nombreCompletoDelArchivo
        fijar índicesDeBuiltins a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeBuiltins}
        fijar alturaDeBuiltins a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeBuiltins}
        fijar constBootstrap a GenerarIdDeConstante
        fijar hayQueImportarBuiltins a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {hayQueImportarBuiltins}

        fijar importaciones a importaciones
                           >> (Instrucciones: (OP#IMPORT: constBootstrap),
                                              (OP#SAVEIMPORT: constBootstrap))
                           >> (Compilado#deConstantes:
                                  (Arreglo#crearCon:
                                      (Constante#crear: constBootstrap, (TextoDelIR#crear: {./backends/tupla/bootstrap.pd}))))
        builtins#paraCadaPar: procedimiento: nombre, datos
            si datos#esImportable
                variable const
                fijar const a GenerarIdDeConstante
                fijar importaciones a importaciones
                                   >> (Instrucciones: OP#DUP,
                                                      (OP#NSLOOKUP: const),
                                                      (OP#LSETC: LocalDelEntornoActual, alturaDeBuiltins, (índicesDeBuiltins#en: datos#binding)))
                                   >> (Compilado#deConstantes:
                                          (Arreglo#crearCon:
                                              (Constante#crear: const, (TextoDelIR#crear: nombre))))
            finsi
        finprocedimiento
        fijar importaciones a importaciones >> (Instrucciones: OP#DROP)

        ParaCadaElemento: identificadoresDefinídos, procedimiento: local
            variable constNombre
            fijar constNombre a GenerarIdDeConstante
            fijar exportaciones a exportaciones
                               >> (CompilarIdentificador: local)
                               >> (Instrucciones: (OP#EXP: constNombre, (local#datosDeVariable#esAutoejecutable#escojer: 1, 0)))
                               >> (Compilado#deConstantes:
                                      (Arreglo#crearCon:
                                          (Constante#crear: constNombre, (TextoDelIR#crear: local#nombre))))
        finprocedimiento

        devolver (NombreDelMarco: nombreDelMódulo, ast#areaTextual)
              >> (Compilado#deInstrucciónes:
                     (Aplanar:
                         (CompilarLocalesYClosure: locales,
                                                   localesEnElEntorno,
                                                   localesInmediatas,
                                                   Arreglo#vacio,
                                                   FALSO,
                                                   profundidad,
                                                   NULO)))
              >> (Instrucciones: (OP#MODULE: constNombreDelMódulo))
              >> (hayQueImportarBuiltins#escojer: importaciones, Compilado#vacío)
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: constNombreDelMódulo, (TextoDelIR#crear: nombreDelMódulo))))
              >> (CompilarBloqueAWasm: ast#instrucciones, builtins)
              >> (Instrucciones: (OP#OPNEXP: identificadoresDefinídos#longitud))
              >> exportaciones
              >> (Instrucciones: OP#CLSEXP,
                                 (OP#RETN: 1))
    finsi
    si EsInstancia: ast, AST#NodoNumeroLiteral
        si EsNúmeroEntero: ast#valor
            devolver Instrucciones: (OP#ICONST: ast#valor)
        sino
            devolver Instrucciones: (OP#FCONST: ast#valor)
        finsi
    finsi
    si EsInstancia: ast, AST#NodoTextoLiteral
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (Instrucciones: (OP#LCONST: cid))
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: cid, (TextoDelIR#crear: ast#valor))))
    finsi
    si EsInstancia: ast, AST#NodoOperador
        variables lhs, rhs
        fijar lhs a CompilarAWasm: ast#lhs, builtins
        fijar rhs a CompilarAWasm: ast#rhs, builtins
        si ast#op#op = {+}
            devolver lhs >> rhs >> (Instrucciones: OP#SUM)
        finsi
        si ast#op#op = {-}
            devolver lhs >> rhs >> (Instrucciones: OP#SUB)
        finsi
        si ast#op#op = {*}
            devolver lhs >> rhs >> (Instrucciones: OP#MUL)
        finsi
        si ast#op#op = {/}
            devolver lhs >> rhs >> (Instrucciones: OP#DIV)
        finsi
        si ast#op#op = {=}
            devolver lhs >> rhs >> (Instrucciones: OP#OPEQ)
        finsi
        si ast#op#op = {<}
            devolver lhs >> rhs >> (Instrucciones: OP#LT)
        finsi
        si ast#op#op = {=<}
            devolver lhs >> rhs >> (Instrucciones: OP#LE)
        finsi
        si ast#op#op = {>}
            devolver lhs >> rhs >> (Instrucciones: OP#GT)
        finsi
        si ast#op#op = {>=}
            devolver lhs >> rhs >> (Instrucciones: OP#GE)
        finsi
        variables cid, optxt
        fijar cid a GenerarIdDeConstante
        fijar optxt a {operador_}#concatenar: ast#op#op
        devolver (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: cid, (TextoDelIR#crear: optxt))))
              >> lhs >> rhs
              >> (Instrucciones: (OP#ROT: 1),
                                 (OP#MSG: cid, 2, 1))
    finsi
    si EsInstancia: ast, AST#NodoIdentificador
        si (RN#NombreResueltoDe: ast) = (builtins#en: {__EACT})#binding
            devolver Instrucciones: (OP#LGET: LocalDelEntornoActual)
        finsi
        si (RN#NombreResueltoDe: ast) = (builtins#en: {__ESUP})#binding
            devolver Instrucciones: (OP#LGET: LocalDelEntornoSuperior)
        finsi

        variable res
        fijar res a CompilarIdentificador: ast
        si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
            variable constLlamar
            fijar constLlamar a GenerarIdDeConstante
            fijar res a res >> (Instrucciones: (OP#MSG: constLlamar, 0, 1))
                            >> (Compilado#deConstantes:
                                    (Arreglo#crearCon:
                                        (Constante#crear: constLlamar, (TextoDelIR#crear: {llamar}))))
        finsi
        devolver res
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        si ast#mensajes#longitud = 0
            devolver CompilarIdentificador: ast#base
        sino
            variables cuerpo, constProto, procId
            fijar constProto a GenerarIdDeConstante
            fijar procId a GenerarIdDeProcedimiento
            fijar cuerpo a (NombreDelMarco: {<no llamar>}, ast#areaTextual)
                        >> (Instrucciones: (OP#LOCAL: 0),
                                           (OP#OPNFRM: LocalDelEntornoActual, LocalDelEntornoSuperior, 0),
                                           (OP#CLSFRM: LocalDelEntornoActual),
                                           (OP#LGETC: LocalDelEntornoActual, 1, 0))
            necesitas ast#mensajes#longitud > 0
            ParaCadaElementoConÍndice: ast#mensajes, procedimiento: mensaje, i
                variable constMsj
                fijar constMsj a GenerarIdDeConstante
                si i = (ast#mensajes#longitud - 1)
                    fijar cuerpo a cuerpo
                                >> (Instrucciones: (OP#LGET: 0),
                                                   (OP#ROT: 1),
                                                   (OP#MSGV: constMsj, constProto, 1),
                                                   (OP#RETN: 1))
                sino
                    fijar cuerpo a cuerpo
                                >> (Instrucciones: (OP#ROT: 0),
                                                   (OP#MSG: constMsj, 0, 1))
                finsi

                fijar cuerpo a cuerpo
                            >> (Compilado#deConstantes:
                                   (Arreglo#crearCon:
                                       (Constante#crear: constMsj, (TextoDelIR#crear: mensaje#texto))))
            finprocedimiento
            devolver (CompilarIdentificador: ast#base)
                  >> (Instrucciones: (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                     (OP#OPNFRM: LocalDelEntornoActual, LocalDelEntornoSuperior, 1),
                                     (OP#ENEW: LocalDelEntornoActual, 0),
                                     (OP#CLSFRM: LocalDelEntornoActual),
                                     (OP#LSETC: LocalDelEntornoActual, 0, 0),
                                     (OP#MKCLZ: LocalDelEntornoActual, procId),
                                     (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior))
                  >> (Compilado#deConstantes: cuerpo#constantes)
                  >> (Compilado#deDeclaraciones: cuerpo#declaraciones)
                  >> (Compilado#deDeclaraciones:
                         (Arreglo#crearCon:
                             (DeclrFunción#crear: procId, Arreglo#vacio, 0, cuerpo#instrucciones)))
                  >> (Compilado#deConstantes:
                         (Arreglo#crearCon:
                             (Constante#crear: constProto,
                                 (PrototipoDeLlamada#crear: (Arreglo#crearCon: VERDADERO)))))
        finsi
    finsi
    si EsInstancia: ast, AST#NodoEnviarMensaje
        si EsInstancia: ast#objeto, AST#NodoIdentificador
            si (RN#NombreResueltoDe: ast#objeto) = (builtins#en: {__Tupla})#binding
                si ast#mensaje = {obtener}
                    necesitas ast#argumentos#longitud = 1
                    devolver (CompilarIdentificador: (ast#argumentos#en: 0))
                          >> (Instrucciones: (OP#BCONST: 0))
                finsi
                si ast#mensaje = {fijar}
                    necesitas ast#argumentos#longitud = 1
                    devolver (CompilarFijarIdentificador: (ast#argumentos#en: 0))
                          >> (Instrucciones: (OP#BCONST: 0))
                finsi
                [ Si el mensaje comienza con `i`, es un opcode que no empuja nada
                  (`iPOP`, `iLSET`). Si por el contrario comienza con `e`, entonces
                  si empuja algo (`eLGET`, `eMKARR`). ]
                variable argumentos
                fijar argumentos a Mapear: ast#argumentos, funcion: arg
                    necesitas (EsInstancia: arg, AST#NodoTextoLiteral) || (EsInstancia: arg, AST#NodoNumeroLiteral)
                    devolver arg#valor
                finfuncion
                si (ast#mensaje#longitud > 1) && ((ast#mensaje#subTexto: 0, 1) = {i})
                    variable opcode
                    fijar opcode a ast#mensaje#subTexto: 1, (ast#mensaje#longitud - 1)
                    devolver Instrucciones: (__EnviarMensaje: OP, opcode, argumentos),
                                            [ Empujamos un valor cualquiera. Recuerda que todas
                                              las expresiones deben dejar un valor en la pila,
                                              pero este opcode no empuja nada. ]
                                            (OP#BCONST: 0)
                finsi
                si (ast#mensaje#longitud > 1) && ((ast#mensaje#subTexto: 0, 1) = {e})
                    variable opcode
                    fijar opcode a ast#mensaje#subTexto: 1, (ast#mensaje#longitud - 1)
                    devolver Instrucciones: (__EnviarMensaje: OP, opcode, argumentos)
                finsi
                si (ast#mensaje#longitud > {PRAGMA_}#longitud) && ((ast#mensaje#subTexto: 0, {PRAGMA_}#longitud) = {PRAGMA_})
                    variable pragma
                    fijar pragma a ast#mensaje#subTexto: {PRAGMA_}#longitud, (ast#mensaje#longitud - {PRAGMA_}#longitud)
                    devolver Instrucciones: (OP#PRAGMA: pragma, ...argumentos),
                                            (OP#BCONST: 0)
                finsi
                __FallarConMensaje: ({No se esperaba el mensaje a __Tupla: ~t}#formatear: ast#mensaje)
            finsi
        finsi
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (CompilarAWasm: ast#objeto, builtins)
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: cid, (TextoDelIR#crear: ast#mensaje))))
              >> (CompilarLlamadaAFunción:
                      ast#argumentos,
                      funcion: numValoresEnLaPila, numResultados
                          devolver Instrucciones: (OP#MSG: cid, numValoresEnLaPila, numResultados)
                      finfuncion,
                      funcion: numValoresEnLaPila, constPrototipo, prototipo, numResultados
                          devolver Instrucciones: (OP#MSGV: cid, constPrototipo, numResultados)
                      finfuncion,
                      1,
                      builtins)
    finsi
    si EsInstancia: ast, AST#NodoLlamarProcedimiento
        variable procnr
        fijar procnr a RN#NombreResueltoDe: ast#proc
        funcion ArgumentosCompilados
            devolver UnirCompilados: (Mapear: ast#argumentos, funcion: nodo
                         necesitas no EsInstancia: nodo, AST#NodoVariadic
                         devolver CompilarAWasm: nodo, builtins
                     finfuncion)
        finfuncion

        si procnr = (builtins#en: {__EM})#binding
            necesitas ast#argumentos#longitud = 3
            variables constPrototipo, prototipo
            fijar constPrototipo a GenerarIdDeConstante
            fijar prototipo a PrototipoDeLlamada#crear: (Arreglo#crearCon: VERDADERO)
            devolver ArgumentosCompilados
                  >> (Instrucciones: (OP#ROTM: 1),
                                     (OP#DYNMSGV: constPrototipo, 1))
                  >> (Compilado#deConstantes:
                         (Arreglo#crearCon:
                             (Constante#crear: constPrototipo, prototipo)))
        finsi
        si procnr = (builtins#en: {__Lua})#binding
            necesitas ast#argumentos#longitud >= 1
            [ __Lua siempre falla en el backend de tuplas. ]
            devolver ArgumentosCompilados
                  >> (Instrucciones: (OP#BCONST: 0), OP#MTRUE)
        finsi

        variable constLlamar
        fijar constLlamar a GenerarIdDeConstante
        devolver (CompilarIdentificador: ast#proc)
              >> (CompilarLlamadaAFunción:
                     ast#argumentos,
                     funcion: numValoresEnLaPila, numResultados
                         devolver Instrucciones: (OP#MSG: constLlamar, numValoresEnLaPila, numResultados)
                     finfuncion,
                     funcion: numValoresEnLaPila, constPrototipo, prototipo, numResultados
                         devolver Instrucciones: (OP#MSGV: constLlamar, constPrototipo, numResultados)
                     finfuncion,
                     1,
                     builtins)
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: constLlamar, (TextoDelIR#crear: {llamar}))))
    finsi
    si EsInstancia: ast, AST#NodoAutoejecutar
        variable constLlamar
        fijar constLlamar a GenerarIdDeConstante
        devolver (CompilarAWasm: ast#expr, builtins)
              >> (CompilarLlamadaAFunción:
                     ast#argumentos,
                     funcion: numValoresEnLaPila, numResultados
                         devolver Instrucciones: (OP#MSG: constLlamar, numValoresEnLaPila, numResultados)
                     finfuncion,
                     funcion: numValoresEnLaPila, constPrototipo, prototipo, numResultados
                         devolver Instrucciones: (OP#MSGV: constLlamar, constPrototipo, numResultados)
                     finfuncion,
                     1,
                     builtins)
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: constLlamar, (TextoDelIR#crear: {llamar}))))
    finsi
    si EsInstancia: ast, AST#NodoVariable
        devolver Compilado#vacío
    finsi
    si EsInstancia: ast, AST#NodoFijar
        si EsInstancia: ast#objetivo, AST#NodoEnviarMensaje
            necesitas ast#objetivo#argumentos#longitud = 0
            variable cid
            fijar cid a GenerarIdDeConstante
            devolver (CompilarAWasm: ast#objetivo#objeto, builtins)
                  >> (CompilarAWasm: ast#valor, builtins)
                  >> (Instrucciones: (OP#ROT: 1),
                                     (OP#MSG: cid, 1, 0))
                  >> (Compilado#deConstantes:
                         (Arreglo#crearCon:
                             (Constante#crear: cid, (TextoDelIR#crear: ({fijar_}#concatenar: ast#objetivo#mensaje)))))
        sino
            devolver (CompilarAWasm: ast#valor, builtins)
                  >> (CompilarFijarIdentificador: ast#objetivo)
        finsi
    finsi
    si EsInstancia: ast, AST#NodoSi
        variables etiqSi, etiqSino, etiqFinsi, localesEnElEntornoSiVerdadero,
                  localesEnElEntornoSiFalso, localesSiVerdadero, localesSiFalso,
                  localesInmediatasSiVerdadero, localesInmediatasSiFalso, profundidad,
                  ámbitoSiVerdadero, ámbitoSiFalso
        fijar etiqSi a GenerarEtiqueta
        fijar etiqSino a GenerarEtiqueta
        fijar etiqFinsi a GenerarEtiqueta

        fijar ámbitoSiVerdadero a ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero}
        fijar localesSiVerdadero a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiVerdadero}
        fijar localesEnElEntornoSiVerdadero a VariablesEnElEntorno: localesSiVerdadero
        fijar localesInmediatasSiVerdadero a LocalesInmediatas: localesSiVerdadero, ámbitoSiVerdadero

        fijar ámbitoSiFalso a ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso}
        fijar localesSiFalso a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiFalso}
        fijar localesEnElEntornoSiFalso a VariablesEnElEntorno: localesSiFalso
        fijar localesInmediatasSiFalso a LocalesInmediatas: localesSiFalso, ámbitoSiFalso

        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}

        devolver (CompilarAWasm: ast#condicional, builtins)
              >> (Instrucciones: (OP#CHOOSE: etiqSi, etiqSino),
                                 (OP#NAME: etiqSi),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntornoSiVerdadero, localesInmediatasSiVerdadero, VERDADERO, profundidad, NULO)))
              >> (CompilarBloqueAWasm: ast#siVerdadero, builtins)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqFinsi),
                                 (OP#NAME: etiqSino),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntornoSiFalso, localesInmediatasSiFalso, VERDADERO, profundidad, NULO)))
              >> (CompilarBloqueAWasm: ast#siFalso, builtins)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#NAME: etiqFinsi))
    finsi
    si EsInstancia: ast, AST#NodoMientras
        variables etiqInicio, etiqCont, etiqFinmientras, locales,
                  localesEnElEntorno, localesInmediatas, nombresLibres, profundidad, ámbito
        fijar etiqInicio a GenerarEtiqueta
        fijar etiqCont a GenerarEtiqueta
        fijar etiqFinmientras a GenerarEtiqueta

        fijar ámbito a RN#ObtenerNombresDefinídos: ast
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar locales a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelNodo}
        fijar localesInmediatas a LocalesInmediatas: locales, ámbito
        fijar localesEnElEntorno a VariablesEnElEntorno: locales

        devolver (Instrucciones: (OP#NAME: etiqInicio))
              >> (CompilarAWasm: ast#condicional, builtins)
              >> (Instrucciones: (OP#CHOOSE: etiqCont, etiqFinmientras),
                                 (OP#NAME: etiqCont),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntorno, localesInmediatas, VERDADERO, profundidad, NULO)))
              >> (CompilarBloqueAWasm: ast#cuerpo, builtins)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqInicio),
                                 (OP#NAME: etiqFinmientras))
    finsi
    si EsInstancia: ast, AST#NodoNecesitas
        devolver (CompilarAWasm: ast#expresión, builtins)
              >> (Instrucciones: OP#MTRUE)
    finsi
    si EsInstancia: ast, AST#NodoDevolver
        devolver (CompilarAWasm: ast#expresión, builtins)
              >> (Instrucciones: (OP#RETN: 1))
    finsi
    si (EsInstancia: ast, AST#NodoFunción) || (EsInstancia: ast, AST#NodoFunciónAnónima) || (EsInstancia: ast, AST#NodoMétodo)
        variables nrsParámetros, parámetroVrd, preludio, cuerpo, fn,
                  nombresLibres, inicDeClosure, locales, localesEnElEntorno,
                  profundidad, localesInmediatas, procid, localYo, pragmas,
                  ámbito, nombre

        fijar preludio a Arreglo#vacio
        [ params ]
        fijar nrsParámetros a NombresDeLosParámetrosNoVariadic: ast
        fijar parámetroVrd a ParámetroVariadic: ast
        si no EsNulo: parámetroVrd
            fijar parámetroVrd a RN#NombreResueltoDe: parámetroVrd#interno
        finsi
        [ locales ]
        fijar ámbito a RN#ObtenerNombresDefinídos: ast
        fijar locales a LocalesDelBloque: ast
        fijar localesEnElEntorno a VariablesEnElEntorno: locales
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar localesInmediatas a LocalesInmediatas: locales, ámbito
        fijar nombresLibres a NombresLibres: ast

        si ContieneYoImplícito: ast
            variable yos
            fijar yos a Filtrar: locales, funcion: local
                devolver (local#binding = NombreResueltoDelYoImplícito: ast) && (EsInstancia: local, YoLocalDelProcedimiento)
            finfuncion
            necesitas yos#longitud = 1
            fijar localYo a yos#en: 0
            fijar nrsParámetros a Concatenar: (Arreglo#crearCon: localYo#binding), nrsParámetros
        sino
            fijar localYo a NULO
        finsi

        fijar preludio a Concatenar: preludio, (CompilarLocalesYClosure: locales, localesEnElEntorno, localesInmediatas, ast#parámetros, VERDADERO, profundidad, localYo)

        fijar procid a GenerarIdDeProcedimiento
        fijar inicDeClosure a (Instrucciones: (OP#MKCLZ: LocalDelEntornoActual, procid))
        si EsInstancia: ast, AST#NodoFunción
            fijar inicDeClosure a inicDeClosure >> (CompilarFijarIdentificador: ast#nombre)
        finsi
        si EsInstancia: ast, AST#NodoMétodo
            variables constAgregarMétodo, constMétodo, agregarMétodo
            fijar constAgregarMétodo a GenerarIdDeConstante
            fijar agregarMétodo a ast#esEstático#escojer: {agregarMétodoEstático}, {agregarMétodo}
            fijar constMétodo a GenerarIdDeConstante
            fijar inicDeClosure a (CompilarIdentificador: ast#deClase)
                               >> (Instrucciones: (OP#LCONST: constMétodo))
                               >> inicDeClosure
                               >> (Instrucciones: (OP#ROT: 2),
                                                  (OP#MSG: constAgregarMétodo, 2, 0))
                               >> (Compilado#deConstantes:
                                      (Arreglo#crearCon:
                                          (Constante#crear: constAgregarMétodo, (TextoDelIR#crear: agregarMétodo)),
                                          (Constante#crear: constMétodo, (TextoDelIR#crear: ast#nombre#nombre))))
        finsi

        si (EsInstancia: ast, AST#NodoMétodo) || (EsInstancia: ast, AST#NodoFunción)
            fijar nombre a ast#nombre#nombre
        sino
            fijar nombre a {<procedimiento>}
        finsi

        fijar cuerpo a (NombreDelMarco: nombre, ast#areaTextual)
                    >> (Compilado#deInstrucciónes: (Aplanar: preludio))
                    >> (CompilarBloqueAWasm: ast#cuerpo, builtins)

        fijar fn a DeclrFunción#crear: procid, nrsParámetros, parámetroVrd, cuerpo#instrucciones
        devolver inicDeClosure
             >> (Compilado#deDeclaraciones: cuerpo#declaraciones)
             >> (Compilado#deDeclaraciones: (Arreglo#crearCon: fn))
             >> (Compilado#deConstantes: cuerpo#constantes)
    finsi
    si EsInstancia: ast, AST#NodoSonIguales
        variable cmp
        si ast#tipoIgualdad = AST#TipoIgualdad#IGUALES
            fijar cmp a Instrucciones: OP#CMPEQ
        sino
            si ast#tipoIgualdad = AST#TipoIgualdad#IDÉNTICOS
                fijar cmp a Instrucciones: OP#CMPREFEQ
            sino
                fijar cmp a Instrucciones: OP#CMPNEQ
            finsi
        finsi
        devolver (CompilarAWasm: ast#lhs, builtins)
              >> (CompilarAWasm: ast#rhs, builtins)
              >> cmp
    finsi
    si EsInstancia: ast, AST#NodoNo
        devolver (CompilarAWasm: ast#expresión, builtins)
              >> (Instrucciones: OP#NOT)
    finsi
    si EsInstancia: ast, AST#NodoEscribir
        devolver (CompilarAWasm: ast#valor, builtins)
              >> (Instrucciones: OP#PRN)
    finsi
    si EsInstancia: ast, AST#NodoNl
        devolver Instrucciones: OP#NL
    finsi
    si EsInstancia: ast, AST#NodoClonar
        variables constClonar, compFijarCampos
        fijar constClonar a GenerarIdDeConstante
        fijar compFijarCampos a Compilado#vacío
        ParaCadaElemento: ast#campos, procedimiento: par
            variable constCampo
            fijar constCampo a GenerarIdDeConstante
            fijar compFijarCampos a compFijarCampos
                >> (Instrucciones: OP#DUP)
                >> (CompilarAWasm: (par#en: 1), builtins)
                >> (Instrucciones: (OP#ROT: 1),
                                   (OP#MSG: constCampo, 1, 0))
                >> (Compilado#deConstantes:
                       (Arreglo#crearCon:
                           (Constante#crear: constCampo,
                               (TextoDelIR#crear: ({fijar_}#concatenar: (par#en: 0))))))
        finprocedimiento
        devolver (CompilarAWasm: ast#expresiónAClonar, builtins)
              >> (Instrucciones: (OP#MSG: constClonar, 0, 1))
              >> compFijarCampos
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: constClonar, (TextoDelIR#crear: {clonar}))))
    finsi
    si EsInstancia: ast, AST#NodoUtilizar
        variable constMod, llave, fijarEspacioDeNombres, fijarNombresImportados
        fijar constMod a GenerarIdDeConstante
        fijar llave a RN#LlaveDelMóduloImportado: ast

        si no EsNulo: ast#espacioDeNombres
            fijar fijarEspacioDeNombres a CompilarFijarIdentificador: ast#espacioDeNombres
        sino
            fijar fijarEspacioDeNombres a Instrucciones: OP#DROP
        finsi

        fijar fijarNombresImportados a Compilado#vacío
        si no EsNulo: ast#nombresEspecíficos
            ParaCadaElemento: ast#nombresEspecíficos, procedimiento: nombreORenombre
                variables constMsj, msj, var
                si EsInstancia: nombreORenombre, Arreglo
                    fijar msj a (nombreORenombre#en: 0)#nombre
                    fijar var a nombreORenombre#en: 1
                sino
                    fijar msj a nombreORenombre#nombre
                    fijar var a nombreORenombre
                finsi
                fijar constMsj a GenerarIdDeConstante
                fijar fijarNombresImportados a fijarNombresImportados
                    >> (Instrucciones: OP#DUP,
                                       (OP#NSLOOKUP: constMsj))
                    >> (CompilarFijarIdentificador: var)
                    >> (Compilado#deConstantes:
                        (Arreglo#crearCon:
                            (Constante#crear: constMsj, (TextoDelIR#crear: msj))))
            finprocedimiento
        finsi

        si (EsNulo: ast#espacioDeNombres) && (EsNulo: ast#nombresEspecíficos)
            variables bindingsImportados, altura, índices, localesImportadas
            fijar bindingsImportados a NombresImportadosResueltos: ast
            fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeImportaciones}
            fijar índices a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeImportaciones}
            fijar localesImportadas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesImportadas}
            ParaCadaElemento: localesImportadas, procedimiento: local
                variables constMsj, var
                fijar constMsj a GenerarIdDeConstante
                fijar fijarNombresImportados a fijarNombresImportados
                    >> (Instrucciones: OP#DUP,
                                       (OP#NSLOOKUP: constMsj))
                    >> (CompilarFijarIdentificador: local)
                    >> (Compilado#deConstantes:
                        (Arreglo#crearCon:
                            (Constante#crear: constMsj, (TextoDelIR#crear: local#nombre))))
            finprocedimiento
        finsi

        devolver (Instrucciones: (OP#IMPORT: constMod),
                                 (OP#SAVEIMPORT: constMod),
                                 OP#DUP)
              >> fijarEspacioDeNombres
              >> fijarNombresImportados
              >> (Instrucciones: OP#DROP)
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: constMod, (TextoDelIR#crear: llave#nombreCompletoDelArchivo))))
    finsi
    si EsInstancia: ast, AST#NodoClase
        variables constSubclase, constNombre, constFijarNombre, constantes, agregarAtributos, claseBase
        fijar constSubclase a GenerarIdDeConstante
        fijar constNombre a GenerarIdDeConstante
        fijar constFijarNombre a GenerarIdDeConstante
        fijar constantes a Compilado#deConstantes:
            (Arreglo#crearCon:
                (Constante#crear: constSubclase, (TextoDelIR#crear: {subclase})),
                (Constante#crear: constNombre, (TextoDelIR#crear: ast#nombre#nombre)),
                (Constante#crear: constFijarNombre, (TextoDelIR#crear: {fijar_nombre})))

        si EsNulo: ast#claseBase
            fijar claseBase a Instrucciones: OP#GETCLSOBJ
        sino
            fijar claseBase a CompilarAWasm: ast#claseBase, builtins
        finsi

        fijar agregarAtributos a
            UnirCompilados:
                (Mapear: (Filtrar: ast#declaraciones,
                                   funcion: D
                                       devolver EsInstancia: D, AST#NodoDeclaraciónDeAtributosEnClase
                                   finfuncion),
                         funcion: nodo
                             devolver UnirCompilados:
                                 (Mapear: nodo#nombres,
                                          funcion: nombre
                                              devolver CompilarAgregarAtributo: (CompilarIdentificador: ast#nombre), nombre#nombre
                                          finfuncion)
                         finfuncion)
        devolver constantes
              >> claseBase
              >> (Instrucciones: (OP#MSG: constSubclase, 0, 1))
              >> (CompilarFijarIdentificador: ast#nombre)
              >> (CompilarIdentificador: ast#nombre)
              >> (Instrucciones: (OP#LCONST: constNombre),
                                 (OP#ROT: 1),
                                 (OP#MSG: constFijarNombre, 1, 0))
              >> agregarAtributos
    finsi
    si EsInstancia: ast, AST#NodoAtributos
        variable deClase
        fijar deClase a CompilarAWasm: ast#deClase, builtins
        devolver (UnirCompilados:
                     (Mapear: ast#nombres,
                              funcion: nombre
                                  devolver CompilarAgregarAtributo: deClase, nombre#nombre
                              finfuncion))
    finsi

    Inalcanzable
finfuncion

[DOCUMENTA
@brief{Normaliza los IDs de las constantes de un compilado.}

El proceso de compilación puede generar muchas constantes duplicadas, esto pone
estrés en el backend que asume que las constantes son únicas. Esta función
devuelve un nuevo @pd{Compilado} que es como @pd{compilado}, pero no solo no
tiene constantes duplicadas, si no que también tiene "parches" que arreglan
todas las referencias ya existentes a constantes. El resultado es un compilado
que es semánticamente identico al original pero con menos constantes.
DOCUMENTA]
funcion NormalizaLosIdsDeConstantes: compilado
    variables constantes, índiceDeConstantes
    fijar constantes a Diccionario#vacío
    fijar índiceDeConstantes a 0

    procedimiento normalizarConstante: tupla, índice
        variables cid, cv, cidReal
        fijar cid a tupla#en: índice
        fijar cv a compilado#valorDeLaConstante: cid
        si no (constantes#contiene: cv)
            fijar cidReal a índiceDeConstantes
            constantes#fijarEn: cv, cidReal
            fijar índiceDeConstantes a índiceDeConstantes + 1
        sino
            fijar cidReal a constantes#en: cv
        finsi
        tupla#argumentos#fijarEn: índice, cidReal
    finprocedimiento

    procedimiento normalizarInstrucciones: instrs
        devolver Mapear: instrs, procedimiento: tupla
            si (tupla#es: Opcode#LCONST)
                || (tupla#es: Opcode#MODULE)
                || (tupla#es: Opcode#IMPORT) || (tupla#es: Opcode#SAVEIMPORT)
                || (tupla#es: Opcode#MSG) || (tupla#es: Opcode#TMSG)
                || (tupla#es: Opcode#DYNMSGV) || (tupla#es: Opcode#TDYNMSGV)
                || (tupla#es: Opcode#EXP) || (tupla#es: Opcode#NSLOOKUP)
                [ El primer argumento es una constante. ]
                variable clon
                fijar clon a clonar tupla con finclonar
                normalizarConstante: clon, 0
                devolver clon
            sino
                si (tupla#es: Opcode#MSGV) || (tupla#es: Opcode#TMSGV)
                    [ Tanto el primer como el segundo argumento son constantes ]
                    variable clon
                    fijar clon a clonar tupla con finclonar
                    normalizarConstante: clon, 0
                    normalizarConstante: clon, 1
                    devolver clon
                sino
                    [ Ningun otro opcode tiene un CID. ]
                    devolver tupla
                finsi
            finsi
        finprocedimiento
    finprocedimiento

    variables nuevasInstrs, nuevasConstantes, nuevasDeclrs
    fijar nuevasInstrs a normalizarInstrucciones: compilado#instrucciones
    fijar nuevasDeclrs a Mapear: compilado#declaraciones, funcion: declr
        devolver clonar declr con
            cuerpo: normalizarInstrucciones: declr#cuerpo
        finclonar
    finfuncion
    fijar nuevasConstantes a Arreglo#vacio
    constantes#paraCadaPar: procedimiento: constv, cid
        nuevasConstantes#agregarAlFinal: (Constante#crear: cid, constv)
    finprocedimiento
    devolver Compilado#crear: nuevasInstrs, nuevasDeclrs, nuevasConstantes
finfuncion

[DOCUMENTA
@brief{Extráe los primeros elementos de @pd{arr} que satisfagan @pd{pred}.}

Por ejemplo:

@ejemplo|{
variable arr, res
funcion MenorA5: X
    devolver X < 5
finfuncion
fijar arr a Arreglo#crearCon: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -2, -3, -4
fijar res a ExtráeInicioMientras: arr, &MenorA5
necesitas res = (Arreglo#crearCon: 0, 1, 2, 3, 4)
}|
DOCUMENTA]
funcion ExtráeInicioMientras: arr, pred
    variable últimoÍndiceVálido
    fijar últimoÍndiceVálido a LlamarConEC: procedimiento: salir
        ParaCadaElementoConÍndice: arr, procedimiento: el, i
            si no %pred: el
                %salir: i
            finsi
        finprocedimiento
        %salir: arr#longitud
    finprocedimiento
    devolver PedazoDeArreglo: arr, 0, (últimoÍndiceVálido + 1)
finfuncion

[DOCUMENTA
@brief{Normaliza los IDs de las variables locales.}

Los índices de los registros locales en el IR deben ser "lineales": deben
comenzar en 0 y avanzar ascendentemente sin "huecos". Esta funcion toma
@pd{compilado} y normaliza todos los IDs de las variables locales para que
cumplan con esta condición.

Devuelve el nuevo compilado normalizado.
DOCUMENTA]
funcion NormalizaLosIdsDeLocales: compilado
    funcion normalizaLasLocales: parámetros, parámetroVariadic, instrucciones
        variables nuevasLocales, locales, nuevasInstrucciones, nuevosParámetros, nuevoParámetroVariadic, índiceLocal
        fijar nuevasLocales a Diccionario#vacío

        fijar índiceLocal a 0
        procedimiento generarÍndiceLocal
            variable res
            fijar res a índiceLocal
            fijar índiceLocal a índiceLocal + 1
            devolver res
        finprocedimiento

        fijar locales a Filtrar: instrucciones, funcion: tupla
            devolver tupla#es: Opcode#LOCAL
        finfuncion
        ParaCadaElementoConÍndice: parámetros, procedimiento: param, i
            nuevasLocales#fijarEn: param, generarÍndiceLocal
        finprocedimiento
        ParaCadaElementoConÍndice: locales, procedimiento: tupla, i
            nuevasLocales#fijarEn: (tupla#en: 0), generarÍndiceLocal
        finprocedimiento
        si no EsNulo: parámetroVariadic
            fijar nuevoParámetroVariadic a nuevasLocales#en: parámetroVariadic
        sino
            fijar nuevoParámetroVariadic a NULO
        finsi

        [ Estas locales nunca cambian, podría tener tres condicionales abajo
          pero creo que es más fácil simplemente agregarlas al diccionario. ]
        nuevasLocales#fijarEn: LocalDelEntornoActual, LocalDelEntornoActual
        nuevasLocales#fijarEn: LocalDelEntornoSuperior, LocalDelEntornoSuperior
        nuevasLocales#fijarEn: {NIL}, {NIL}

        fijar nuevasInstrucciones a Mapear: instrucciones, funcion: tupla
            [ Todos estos opcodes tienen su única referencia a una variable
              local en su primer argumento ]
            si (tupla#es: Opcode#LOCAL)
            || (tupla#es: Opcode#LSET)  || (tupla#es: Opcode#LGET)
            || (tupla#es: Opcode#LSETC) || (tupla#es: Opcode#LGETC)
            || (tupla#es: Opcode#MKCLZ) || (tupla#es: Opcode#CLSFRM)
            || (tupla#es: Opcode#ENEW)
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                devolver clon
            finsi
            si tupla#es: Opcode#OPNFRM
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                clon#argumentos#fijarEn: 1, (nuevasLocales#en: (clon#argumentos#en: 1))
                devolver clon
            finsi
            si tupla#es: Opcode#EINIT
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                clon#argumentos#fijarEn: 2, (nuevasLocales#en: (clon#argumentos#en: 2))
                devolver clon
            finsi
            [ Los demás opcodes no tienen referencias a locales ]
            devolver tupla
        finfuncion
        fijar nuevosParámetros a Mapear: parámetros, &(nuevasLocales#en)

        devolver ObjetoAdHoc: {parámetros}, nuevosParámetros,
                              {parámetroVariadic}, nuevoParámetroVariadic,
                              {instrucciones}, nuevasInstrucciones
    finfuncion

    devolver Compilado#crear:
        (normalizaLasLocales: Arreglo#vacio, NULO, compilado#instrucciones)#instrucciones,
        (Mapear: compilado#declaraciones, funcion: declr
            variable parámetrosYCuerpo
            fijar parámetrosYCuerpo a normalizaLasLocales: declr#parámetros, declr#parámetroVariadic, declr#cuerpo
            devolver clonar declr con
                parámetros: parámetrosYCuerpo#parámetros
                parámetroVariadic: parámetrosYCuerpo#parámetroVariadic
                cuerpo: parámetrosYCuerpo#instrucciones
            finclonar
        finfuncion),
        compilado#constantes
finfuncion

[DOCUMENTA
@brief{Escapa un texto para que sea válido en la representación textual del
IR.}

El texto devuelto puede ser rodeado por comillas @code{""} y será una literal
textual válida del IR.
DOCUMENTA]
funcion EscaparParaPDVM: texto
    devolver MapearTexto: texto, funcion: car
        si car = {\}
            devolver {\\}
        finsi
        si car = {	}
            devolver {\t}
        finsi
        si car = {~q}#formatear
            devolver {\q}
        finsi
        si car = {~%}#formatear
            devolver {\n}
        finsi
        devolver car
    finfuncion
finfuncion

[DOCUMENTA
@brief{Emite la representación textual de un compilado.}

@pd{puertoDeEscritura} es el puerto de escritura en el cual se escribirá el
compilado.
DOCUMENTA]
procedimiento EmitirCompilado: compilado, puertoDeEscritura
    DesparsearDato: puertoDeEscritura, compilado#comoSExpr
finprocedimiento

procedimiento EmitirTablaDeMódulos: tabla, puertoDeEscritura
    DesparsearDato: puertoDeEscritura, tabla#comoSExpr
finprocedimiento

funcion ParsearYDefunc: programa
    variables ast, builtins, autoejecutables
    fijar ast a Parser#CrearAST: programa, {}

    fijar builtins a Diccionario#desdePares:
        {__EACT}, RN#GenerarIdDeNombre,
        {__ESUP}, RN#GenerarIdDeNombre,
        {__RT}, RN#GenerarIdDeNombre,
        {__Tupla}, RN#GenerarIdDeNombre,
        {__SonElMismoObjeto}, RN#GenerarIdDeNombre,
        {__ObtenerAtributo}, RN#GenerarIdDeNombre,
        {__FijarAtributo}, RN#GenerarIdDeNombre,
        {__NúmeroDeAtributos}, RN#GenerarIdDeNombre,
        {__EM}, RN#GenerarIdDeNombre,
        {__CódigoDeObjeto}, RN#GenerarIdDeNombre
    fijar autoejecutables a Arreglo#crearCon:
        {__SonElMismoObjeto}, {__ObtenerAtributo}, {__FijarAtributo},
        {__NúmeroDeAtributos}, {__CódigoDeObjeto}, {__EM}

    variable ámbitoPrincipal
    fijar ámbitoPrincipal a RN#ResolverNombres:
        ast,
        procedimiento: nombreDelMódulo
            Inalcanzable
        finprocedimiento,
        procedimiento: ámbito
            builtins#paraCadaPar: procedimiento: nombre, binding
                ámbito#agregar: nombre, binding
            finprocedimiento
            ParaCadaElemento: autoejecutables, procedimiento: nombre
                ámbito#marcarComoAutoejecutable: nombre
            finprocedimiento
        finprocedimiento,
        procedimiento: ámbito finprocedimiento
    Defun#Defuncionalizar: ast

    devolver ObjetoAdHoc: {ast}, ast,
                          {builtins}, builtins
finfuncion

[DOCUMENTA
@brief{Anota el @pd{AST#NodoPrograma} con la llave del módulo.}

@pd{llave} debe ser la llave del módulo a usar. Este procedimiento anota
@bold{todos} los @pd{AST#NodoPrograma}s en el @pd{ast}, pero no anota aquellos
que estén dentro de otros @pd{AST#NodoPrograma}.
DOCUMENTA]
procedimiento AnotarElProgramaConSuLlaveDeMódulo: ast, llave
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoPrograma
    finfuncion, procedimiento: nodo
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {llaveDelMódulo}, llave
    finprocedimiento
finprocedimiento



clase CompiladorATuplas hereda Compilador#CompiladorBase
finclase

atributos CompiladorATuplas#_nombresBootstrap,
          CompiladorATuplas#_nombresBuiltins,
          CompiladorATuplas#_experimentos

metodo CompiladorATuplas#inicializar: db, experimentos
    fijar yo#baseDeDatos a db
    fijar yo#_experimentos a experimentos
    funcion datosDelBuiltin: binding, autoejecutable, importable
        devolver ObjetoAdHoc: {binding}, binding,
                              {esAutoejecutable}, autoejecutable,
                              {esImportable}, importable
    finfuncion

    fijar yo#_nombresBootstrap a Diccionario#desdePares:
        {__EACT},  (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     FALSO),
        {__ESUP},  (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     FALSO),
        {__RT},    (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     FALSO),
        {__Tupla}, (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     FALSO),
        {__Lua},   (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, FALSO),
        {__EM},    (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, FALSO)

    fijar yo#_nombresBuiltins a Diccionario#desdePares:
        {Objeto},               (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {VERDADERO},            (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {FALSO},                (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {NULO},                 (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {Aplicar},              (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {ProcedimientoVarargs}, (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {TipoDe},               (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__EnviarMensaje},      (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__FallarConMensaje},   (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__ClonarObjeto},       (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__CompararObjeto},     (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__AbrirArchivo},       (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__ByteATexto},         (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__TextoAByte},         (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__ByteEof},            (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {__Capturar},           (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__Argv},               (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {__LeerCaracter},       (datosDelBuiltin: RN#GenerarIdDeNombre, VERDADERO, VERDADERO),
        {__Impl},               (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),

        {Boole},                (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {Numero},               (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {Arreglo},              (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {Procedimiento},        (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {Texto},                (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {EspacioDeNombres},     (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {Referencia},           (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO),
        {TipoNulo},             (datosDelBuiltin: RN#GenerarIdDeNombre, FALSO,     VERDADERO)
finmetodo

metodo CompiladorATuplas#hayQueImportarBuiltins
    devolver no Contiene: yo#_experimentos, {interno}
finmetodo

metodo CompiladorATuplas#builtins
    variable res
    fijar res a Diccionario#vacío
    yo#_nombresBootstrap#paraCadaPar: procedimiento: llave, valor
        res#fijarEn: llave, valor
    finprocedimiento
    si yo#hayQueImportarBuiltins
        yo#_nombresBuiltins#paraCadaPar: procedimiento: llave, valor
            res#fijarEn: llave, valor
        finprocedimiento
    finsi
    devolver res
finmetodo

metodo CompiladorATuplas#compilarAST: llaveDeMódulo, ast, ámbito
    variable builtins, cc, ncc, ptesc
    fijar builtins a yo#builtins#mapear: funcion: nombre, datos
        devolver Arreglo#crearCon: nombre, datos#binding
    finfuncion

    Escribir: {---: Defuncionalizar}
    Defun#Defuncionalizar: ast
    Escribir: {---: AnotarIdentificadoresTextuales}
    AnotarIdentificadoresTextuales: ast
    Escribir: {---: AnotaLosNombresImportadosImplícitamente}
    variable bindingsBuiltins
    fijar bindingsBuiltins a Arreglo#vacio
    builtins#paraCadaValor: &(bindingsBuiltins#agregarAlFinal)
    AnotaLosNombresImportadosImplícitamente: ast, bindingsBuiltins
    Escribir: {---: AnotaciónDeCapturas}
    AnotaciónDeCapturas: ast

    Escribir: {---: EnumeraciónDeCapturas}
    variable callbacksDeLaEnumeración
    fijar callbacksDeLaEnumeración a Arreglo#vacio
    EnumeraciónDeCapturas: ast, (EstadoDeEnumeraciónDeCapturas#desdeBuiltins: builtins), callbacksDeLaEnumeración, yo#builtins
    necesitas callbacksDeLaEnumeración#longitud = 0

    Escribir: {---: EnumeraciónDeLocalesDeProcedimiento}
    EnumeraciónDeLocalesDeProcedimiento: ast, (RN#ObtenerNombresDefinídos: ast), yo#builtins
    Escribir: {---: AnotarBindingsLocales}
    AnotarBindingsLocales: ast
    Escribir: {---: AnotarLocalesInmediatas}
    AnotarLocalesInmediatas: ast
    Escribir: {---: MarcaVariablesLocalesEnSubámbitos}
    MarcaVariablesLocalesEnSubámbitos: ast
    Escribir: {---: MarcaVariablesQueEstánEnElEntorno}
    MarcaVariablesQueEstánEnElEntorno: ast
    Escribir: {---: AnotarElProgramaConSuLlaveDeMódulo}
    AnotarElProgramaConSuLlaveDeMódulo: ast, llaveDeMódulo
    Escribir: {---: CompilarAWasm}
    MarcaSiHayQueImportarBuiltins: ast, yo#hayQueImportarBuiltins
    fijar cc a CompilarAWasm: ast, yo#builtins
    Escribir: {---: NormalizaLosIdsDeConstantes}
    fijar ncc a NormalizaLosIdsDeConstantes: cc
    Escribir: {---: NormalizaLosIdsDeLocales}
    fijar ncc a NormalizaLosIdsDeLocales: ncc

    Escribir: {---: EmitirCompilado}
    fijar ptesc a PuertoParaTexto
    DesparsearDato: ptesc, ncc#comoSExpr

    devolver clonar Compilador#ResultadoDeCompilación#crear con
        compilado: (TextoDePuertoDeEscritura: ptesc)
        compiladoAbstracto: NULO
        informaciónDeDepuración: {}
    finclonar
finmetodo

metodo CompiladorATuplas#importarMódulo: nombreDelMódulo
    variables móduloOLlave, móduloCompilado
    Escribir: ({---: Buscando: ~t}#formatear: nombreDelMódulo)
    fijar móduloOLlave a
        Módulos#ResolverMóduloPorNombre: yo#baseDeDatos, nombreDelMódulo, procedimiento: llave
            devolver llave
        finprocedimiento, procedimiento: mod
            devolver mod
        finprocedimiento, procedimiento
            __FallarConMensaje: ({Error: no se pudo encontrar el módulo ~t}#formatear: nombreDelMódulo)
        finprocedimiento
    si EsInstancia: móduloOLlave, Módulos#Módulo
        Escribir: {---: Encontrado}
        devolver móduloOLlave
    sino
        Escribir: {---: No encontrado, compilandolo}
        fijar móduloCompilado a yo#compilarTexto:
            móduloOLlave,
            (SistemaDeArchivos#LeerArchivo: móduloOLlave#nombreCompletoDelArchivo)
        yo#baseDeDatos#agregarMódulo: móduloCompilado
        devolver móduloCompilado
    finsi
finmetodo

metodo CompiladorATuplas#inyectarNombresEnÁmbito: ámbito
    yo#builtins#paraCadaPar: funcion: nombre, datos
        ámbito#agregar: nombre, datos#binding
        si datos#esAutoejecutable
            ámbito#marcarComoAutoejecutable: nombre
        finsi
    finfuncion
finmetodo

metodo CompiladorATuplas#removerNombresDeÁmbito: ámbito
    yo#builtins#paraCadaPar: funcion: nombre, datos
        ámbito#eliminarNombre: nombre
    finfuncion
finmetodo

metodo CompiladorATuplas#compilarTodo: llavePrincipal
    variables móduloPrincipal, salida, programa
    fijar móduloPrincipal a yo#baseDeDatos#buscarMóduloPorLlave: llavePrincipal
    fijar salida a PuertoParaTexto
    fijar programa a EnlazarMódulos: yo#baseDeDatos, llavePrincipal
    programa#compilado#emitirComoIR: salida
    salida#escribirTexto: {~%}#formatear
    programa#tablaDeMódulos#emitirComoIR: salida
    devolver TextoDePuertoDeEscritura: salida
finmetodo


funcion MáximoDe: ...args
    si args#longitud = 2
        variables min, seq
        fijar min a args#en: 0
        fijar seq a args#en: 1
        devolver Reducir: min, &Max, seq
    finsi
    si args#longitud = 1
        variable seq
        fijar seq a args#en: 0
        necesitas seq#longitud > 0
        devolver Reducir: (seq#en: 0), &Max, seq
    finsi
    __FallarConMensaje: ({MáximoDe necesita 1 o 2 argumentos, pero recibió ~t}#formatear: args#longitud)
finfuncion

funcion NormalizaLosIdsDeProcedimientos: compilado
    variables idsViejosAIdsNuevos, cuenta
    fijar idsViejosAIdsNuevos a Diccionario#vacío
    fijar cuenta a 0
    ParaCadaElemento: compilado#declaraciones, procedimiento: declr
        idsViejosAIdsNuevos#fijarEn: declr#nombre, cuenta
        fijar cuenta a cuenta + 1
    finprocedimiento

    funcion normalizaInstrucciones: instrucciones
        devolver Mapear: instrucciones, funcion: instr
            si (instr#es: Opcode#MKCLZ) || (instr#es: Opcode#MK0CLZ)
                variables clon, idx
                fijar clon a clonar instr con finclonar
                si instr#es: Opcode#MKCLZ
                    fijar idx a 1
                sino
                    fijar idx a 0
                finsi
                clon#argumentos#fijarEn: idx, (idsViejosAIdsNuevos#en: (clon#en: idx))
                devolver clon
            finsi
            devolver instr
        finfuncion
    finfuncion

    devolver Compilado#crear: (normalizaInstrucciones: compilado#instrucciones),
                              (Mapear: compilado#declaraciones, funcion: declr
                                  devolver clonar declr con
                                      nombre: (idsViejosAIdsNuevos#en: declr#nombre)
                                      cuerpo: (normalizaInstrucciones: declr#cuerpo)
                                  finclonar
                              finfuncion),
                              compilado#constantes
finfuncion

funcion Normalizar: compilado
    devolver NormalizaLosIdsDeConstantes:
        (NormalizaLosIdsDeLocales:
            (NormalizaLosIdsDeProcedimientos: compilado))
finfuncion

funcion MódulosDelPrograma: compilado
    variable tabla
    fijar tabla a Diccionario#vacío
    funcion esMódulo: op
        devolver op#es: Opcode#MODULE
    finfuncion
    ParaCadaElemento: compilado#declaraciones, procedimiento: declr
        si no EsInstancia: declr, DeclrFunción
            devolver NULO
        finsi
        variable mod
        fijar mod a Filtrar: declr#cuerpo, &esMódulo
        si mod#longitud > 0
            necesitas mod#longitud = 1
            variable op
            fijar op a mod#en: 0
            tabla#fijarEn: (op#en: 0), declr#nombre
        finsi
    finprocedimiento
    devolver tabla
finfuncion

funcion CompiladoDesdeTexto: texto
    devolver Compilado#desdeSExpr: (ParsearDato: (TextoComoPuerto: texto))
finfuncion

clase TablaDeMódulos
    atributo diccionarioDeMódulos
    metodo crear: diccionarioDeMódulos, compilado
    metodo emitirComoIR: puertoDeEscritura
    metodo comoSExpr
    metodo estatico desdeSExpr: sexpr
finclase

metodo TablaDeMódulos#inicializar: diccionarioDeMódulos
    fijar yo#diccionarioDeMódulos a diccionarioDeMódulos
finmetodo

metodo TablaDeMódulos#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {SECTION "module table"~%}#formatear
    yo#diccionarioDeMódulos#paraCadaPar: procedimiento: nombreDelMódulo, idDelProcedimiento
        puertoDeEscritura#escribirTexto: ({MODULE ~t PROC ~t~%}#formatear: nombreDelMódulo, idDelProcedimiento)
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%}#formatear
finmetodo

metodo TablaDeMódulos#comoSExpr
    devolver Arreglo#crearCon:
        (Símbolo#desdeTexto: {module-table}),
        ...(Mapear: yo#diccionarioDeMódulos#comoArreglo, funcion: par
                devolver Arreglo#crearCon:
                    (Símbolo#desdeTexto: {module}),
                    (par#en: 0),
                    (par#en: 1)
            finfuncion)
finmetodo

metodo estatico TablaDeMódulos#desdeSExpr: sexpr
    devolver yo#crear: (Diccionario#desdeArreglo:
        (Mapear: (PedazoDeArreglo: sexpr, 1, -1),
                 funcion: mod
                     devolver PedazoDeArreglo: mod, 1, -1
                 finfuncion))
finmetodo

procedimiento EnlazarMódulos: baseDeDatos, llaveDelMóduloPrincipal
    variables opcodesConConstantes
    fijar opcodesConConstantes a Arreglo#crearCon:
        Opcode#LCONST, Opcode#TMSG, Opcode#MSG, Opcode#TMSGV, Opcode#MSGV,
        Opcode#TDYNMSGV, Opcode#DYNMSGV, Opcode#IMPORT, Opcode#SAVEIMPORT, Opcode#MODULE,
        Opcode#EXP, Opcode#NSLOOKUP

    funcion parchearInstrucciones: instrucciones, incrementoDeConstante, incrementoDeProcedimiento
        variables mayorÍndiceDeConstante, mayorÍndiceDeProcedimiento, parcheadas
        fijar mayorÍndiceDeConstante a 0
        fijar mayorÍndiceDeProcedimiento a 0

        fijar parcheadas a Mapear: instrucciones, funcion: instr
            si Algún: (Mapear: opcodesConConstantes, &(instr#es))
                [ Todos los opcodes que piden una constante la aceptan en el primer argumento. ]
                variable clon
                fijar clon a clonar instr con finclonar
                clon#argumentos#fijarEn: 0, (incrementoDeConstante + (clon#en: 0))
                fijar mayorÍndiceDeConstante a Max: mayorÍndiceDeConstante, (clon#en: 0)
                si (instr#es: Opcode#MSGV) || (instr#es: Opcode#TMSGV)
                    [ Su segundo argumento también es una constante ]
                    clon#argumentos#fijarEn: 1, (incrementoDeConstante + (clon#en: 1))
                    fijar mayorÍndiceDeConstante a Max: mayorÍndiceDeConstante, (clon#en: 1)
                finsi
                devolver clon
            finsi
            [ Los siguientes dos casos manejan las referencias a procedimientos. ]
            si (instr#es: Opcode#MKCLZ) || (instr#es: Opcode#MK0CLZ)
                variables clon, idx
                fijar clon a clonar instr con finclonar
                si instr#es: Opcode#MKCLZ
                    fijar idx a 1
                sino
                    fijar idx a 0
                finsi
                clon#argumentos#fijarEn: idx, (incrementoDeProcedimiento + (clon#en: idx))
                fijar mayorÍndiceDeProcedimiento a Max: mayorÍndiceDeProcedimiento, (clon#en: idx)
                devolver clon
            finsi
            devolver instr
        finfuncion

        devolver ObjetoAdHoc: {instrucciones}, parcheadas,
                              {mayorÍndiceDeConstante}, mayorÍndiceDeConstante,
                              {mayorÍndiceDeProcedimiento}, mayorÍndiceDeProcedimiento
    finfuncion

    funcion parchearDeclaraciones: declaraciones, incrementoDeConstante, incrementoDeProcedimiento
        variable mayorÍndiceDeConstante, mayorÍndiceDeProcedimiento, declrs
        fijar mayorÍndiceDeConstante a 0
        fijar mayorÍndiceDeProcedimiento a 0
        fijar declrs a Mapear: declaraciones, funcion: declr
            variable cuerpoParcheado
            fijar cuerpoParcheado a parchearInstrucciones: declr#cuerpo,
                                                           incrementoDeConstante,
                                                           incrementoDeProcedimiento
            fijar mayorÍndiceDeConstante a Max: mayorÍndiceDeConstante,
                                                cuerpoParcheado#mayorÍndiceDeConstante
            fijar mayorÍndiceDeProcedimiento a Max: mayorÍndiceDeProcedimiento,
                                                    declr#nombre,
                                                    cuerpoParcheado#mayorÍndiceDeProcedimiento
            devolver clonar declr con
                nombre: (incrementoDeProcedimiento + declr#nombre)
                cuerpo: cuerpoParcheado#instrucciones
            finclonar
        finfuncion

        devolver ObjetoAdHoc: {declaraciones}, declrs,
                              {mayorÍndiceDeConstante}, mayorÍndiceDeConstante,
                              {mayorÍndiceDeProcedimiento}, mayorÍndiceDeProcedimiento
    finfuncion

    funcion parchearConstantes: constantes, incrementoDeConstante
        devolver Mapear: constantes, funcion: const
            devolver clonar const con
                id: (const#id + incrementoDeConstante)
            finclonar
        finfuncion
    finfuncion

    funcion parchearCompilado: compilado, incrementoDeConstante, incrementoDeProcedimiento
        variables instrs, declrs, consts, mayorÍndiceDeConstante, mayorÍndiceDeProcedimiento, comp
        Escribir: {----- Parcheando instrucciones...}
        fijar instrs a parchearInstrucciones: compilado#instrucciones,
                                              incrementoDeConstante,
                                              incrementoDeProcedimiento
        Escribir: {----- Parcheando declaraciones...}
        fijar declrs a parchearDeclaraciones: compilado#declaraciones,
                                              incrementoDeConstante,
                                              incrementoDeProcedimiento
        Escribir: {----- Parcheando constantes...}
        fijar consts a parchearConstantes: compilado#constantes,
                                           incrementoDeConstante
        Escribir: {----- Uniendo...}
        fijar mayorÍndiceDeConstante a Max: instrs#mayorÍndiceDeConstante,
                                            declrs#mayorÍndiceDeConstante,
                                            (MáximoDe: (Mapear: consts, (MétodoComoFunción: {id})))
        fijar mayorÍndiceDeProcedimiento a Max: instrs#mayorÍndiceDeProcedimiento,
                                                declrs#mayorÍndiceDeProcedimiento
        fijar comp a Compilado#crear: instrs#instrucciones,
                                      declrs#declaraciones,
                                      consts
        devolver ObjetoAdHoc: {compilado}, comp,
                              {mayorÍndiceDeConstante}, mayorÍndiceDeConstante,
                              {mayorÍndiceDeProcedimiento}, mayorÍndiceDeProcedimiento
    finfuncion

    funcion rotarCompilado: compilado, incrementoDeConstante, incrementoDeProcedimiento
        variables parcheado, idPrincipal, constLlamar, comp
        Escribir: {---- Parcheando}
        fijar parcheado a parchearCompilado: compilado, incrementoDeConstante, incrementoDeProcedimiento
        Escribir: {---- Listo}
        fijar idPrincipal a incrementoDeProcedimiento + parcheado#mayorÍndiceDeProcedimiento + 1
        fijar constLlamar a incrementoDeConstante + parcheado#mayorÍndiceDeConstante + 1
        fijar comp a (Instrucciones: (OP#MK0CLZ: idPrincipal),
                                     (OP#MSG: constLlamar, 0, 0))
                  >> (Compilado#deConstantes:
                         (Arreglo#crearCon:
                             (Constante#crear: constLlamar, (TextoDelIR#crear: {llamar}))))
                  >> (Compilado#deDeclaraciones:
                         (Arreglo#crearCon:
                             (DeclrFunción#crear: idPrincipal,
                                                  Arreglo#vacio,
                                                  NULO,
                                                  parcheado#compilado#instrucciones)))
                  >> (Compilado#deDeclaraciones: parcheado#compilado#declaraciones)
                  >> (Compilado#deConstantes: parcheado#compilado#constantes)
        devolver ObjetoAdHoc: {compilado}, comp,
                              {nombreDelProcedimientoPrincipal}, idPrincipal,
                              {mayorÍndiceDeConstante}, (parcheado#mayorÍndiceDeConstante + 2),
                              {mayorÍndiceDeProcedimiento}, (parcheado#mayorÍndiceDeProcedimiento + 2)
    finfuncion

    variables móduloPrincipal, compiladoFinal,
              incrementoDeConstante, incrementoDeProcedimiento,
              tablaDeMódulos
    fijar móduloPrincipal a baseDeDatos#buscarMóduloPorLlave: llaveDelMóduloPrincipal
    fijar compiladoFinal a Compilado#vacío
    fijar incrementoDeConstante a 0
    fijar incrementoDeProcedimiento a 0
    fijar tablaDeMódulos a Diccionario#vacío

    baseDeDatos#paraCadaMódulo: procedimiento: módulo
        variables rotado, compiladoDelMódulo
        Escribir: ({--- En el módulo ~t}#formatear: módulo#llave)
        Escribir: {---- Deserializando el compilado...}
        fijar compiladoDelMódulo a CompiladoDesdeTexto: módulo#compilado
        Escribir: {---- Rotando el compilado}
        fijar rotado a rotarCompilado: compiladoDelMódulo,
                                       incrementoDeConstante,
                                       incrementoDeProcedimiento
        fijar incrementoDeConstante a incrementoDeConstante + rotado#mayorÍndiceDeConstante + 1
        fijar incrementoDeProcedimiento a incrementoDeProcedimiento + rotado#mayorÍndiceDeProcedimiento + 1
        tablaDeMódulos#fijarEn: módulo#llave, rotado#nombreDelProcedimientoPrincipal

        si módulo#llave = llaveDelMóduloPrincipal
            fijar compiladoFinal a compiladoFinal >> rotado#compilado
        sino
            fijar compiladoFinal a compiladoFinal
                                >> (Compilado#crear: Arreglo#vacio,
                                                     rotado#compilado#declaraciones,
                                                     rotado#compilado#constantes)
        finsi
    finprocedimiento

    fijar compiladoFinal a Normalizar: compiladoFinal

    devolver ObjetoAdHoc: {compilado}, compiladoFinal,
                          {tablaDeMódulos}, (TablaDeMódulos#crear: (MódulosDelPrograma: compiladoFinal))
finprocedimiento
