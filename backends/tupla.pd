utilizar bepd/builtins
utilizar bepd/x/adhoc (ObjetoAdHoc)
utilizar bepd/datos/conjunto (Conjunto)
utilizar bepd/datos/diccionario (Diccionario)
utilizar bepd/x/puerto/conPosición (PosiciónTextual)
utilizar bepd/utilidades/texto
utilizar bepd/x/enum (Enum, EnumConValores)

utilizar tokens como Tokens
utilizar ast como AST
utilizar parser como Parser
utilizar resoluciónDeNombres como RN
utilizar defuncionalización como Defun



[ Pase de anotación de capturas

  Anota cada identificador en su punto de declaración con un metadato
  `capturado` (boole) que indica si el identificador fue capturado o no.

]

funcion Parcial: proc, ...argumentos
    devolver funcion: ...másArgumentos
        devolver %proc: ...argumentos, ...másArgumentos
    finfuncion
finfuncion

funcion MétodoComoFunción: ...args
    si args#longitud = 1
        devolver funcion: obj, ...resto
            devolver EnviarMensaje: obj, (args#en: 0), ...resto
        finfuncion
    sino
        necesitas args#longitud = 2
        devolver funcion: ...resto
            devolver EnviarMensaje: (args#en: 0), (args#en: 1), ...resto
        finfuncion
    finsi
finfuncion

funcion BinOp: op
    devolver funcion: lhs, rhs
        devolver EnviarMensaje: lhs, ({operador_}#concatenar: op), rhs
    finfuncion
finfuncion

funcion Únicos: arr
    devolver (Conjunto#desdeArreglo: arr)#comoArreglo
finfuncion


funcion Caminar: nodo, filtro, cuerpo
    si %filtro: nodo
        devolver %cuerpo: nodo, funcion: cont
            devolver Caminar: cont, filtro, cuerpo
        finfuncion
    finsi

    funcion recur: nodo
        devolver Caminar: nodo, filtro, cuerpo
    finfuncion

    si EsInstancia: nodo, AST#NodoPrograma
        devolver ParaCadaElemento: nodo#instrucciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoVariable
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFijar
        recur: nodo#objetivo
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoEscribir
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoNl
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoClase
        recur: nodo#nombre
        si no EsNulo: nodo#claseBase
            recur: nodo#claseBase
        finsi
        ParaCadaElemento: nodo#extiendeClases, &recur
        ParaCadaElemento: nodo#implementaClases, &recur
        devolver ParaCadaElemento: nodo#declaraciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#parámetros, &recur
    finsi
    si EsInstancia: nodo, AST#NodoImplementa
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#definiciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineMétodoEnClase
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunción
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoNecesitas
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoDevolver
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoSi
        recur: nodo#condicional
        ParaCadaElemento: nodo#siVerdadero, &recur
        devolver ParaCadaElemento: nodo#siFalso, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMientras
        recur: nodo#condicional
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMétodo
        si no EsNulo: nodo#deClase
            recur: nodo#deClase
        finsi
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoAtributos
        recur: nodo#deClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoUtilizar
        NoImplementado
    finsi

    si EsInstancia: nodo, AST#NodoIdentificador
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoNumeroLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoTextoLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoLlamarProcedimiento
        recur: nodo#proc
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoEnviarMensaje
        recur: nodo#objeto
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoOperador
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoNoLlamar
        devolver recur: nodo#base
    finsi
    si EsInstancia: nodo, AST#NodoAutoejecutar
        recur: nodo#expr
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunciónAnónima
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoSonIguales
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoReferenciar
        devolver recur: nodo#nombre
    finsi
    si EsInstancia: nodo, AST#NodoNo
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoClonar
        recur: nodo#expresiónAClonar
        devolver ParaCadaElemento: nodo#campos, funcion: campo
            devolver recur: (campo#en: 1)
        finfuncion
    finsi

    si EsInstancia: nodo, AST#NodoVariadic
        devolver recur: nodo#interno
    finsi

    [ Nunca se llega hasta aquí. ]
    Escribir: ({Caminar no implementado para ~t}#formatear: (TipoDe: nodo))
    Inalcanzable
finfuncion


clase LlaveAnotaciónDeCapturas
    metodo comoTexto
finclase

metodo LlaveAnotaciónDeCapturas#comoTexto
    devolver {LLAVE_ANOTACIÓN_DE_CAPTURAS}
finmetodo

variable LLAVE_ANOTACIÓN_DE_CAPTURAS
fijar LLAVE_ANOTACIÓN_DE_CAPTURAS a LlaveAnotaciónDeCapturas#crear

funcion NombresLibres: nodo
    si EsInstancia: nodo, AST#NodoPrograma
        devolver Arreglo#vacio
    sino
        devolver nodo#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres}
    finsi
finfuncion

procedimiento AnotaciónDeCapturas: ast
    variable nombresCapturadosAcc, nombresCapturados
    fijar nombresCapturadosAcc a Arreglo#vacio
    Caminar: ast, funcion: nodo
        variable declaraciones
        fijar declaraciones a Arreglo#crearCon:
            AST#NodoVariable, AST#NodoFunción, AST#NodoClase, AST#NodoMétodo, AST#NodoFunciónAnónima
        devolver Algún: (Mapear: declaraciones, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoFunción
            nombresCapturadosAcc#agregarAlFinal: (NombresLibres: nodo)
            ParaCadaElemento: nodo#cuerpo, procedimiento: cn
                devolver %recur: cn
            finprocedimiento
            devolver NULO
        finsi
    finprocedimiento
    fijar nombresCapturados a Reducir: Conjunto#vacío, (MétodoComoFunción: {unión}), nombresCapturadosAcc
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoIdentificador
    finfuncion, procedimiento: nodo, recur
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}, (nombresCapturados#contiene: (RN#NombreResueltoDe: nodo))
    finprocedimiento
finprocedimiento

procedimiento EnumeraciónDeLocalesDeProcedimiento: ast, obtenerMetadatosAdicionales
    variable locales
    fijar locales a Arreglo#vacio
    Caminar: ast, funcion: nodo
        devolver ((EsInstancia: nodo, AST#NodoIdentificador) || (EsInstancia: nodo, AST#NodoFunción))
    finfuncion, procedimiento: nodo, recur
        si (Defun#SonElMismoObjeto: nodo, ast) && (EsInstancia: nodo, AST#NodoFunción)
            ParaCadaElemento: nodo#parámetros, &(locales#agregarAlFinal)
            ParaCadaElemento: nodo#cuerpo, recur
            devolver NULO
        finsi
        si (no Defun#SonElMismoObjeto: nodo, ast) && (EsInstancia: nodo, AST#NodoFunción)
            locales#agregarAlFinal: nodo#nombre
            devolver EnumeraciónDeLocalesDeProcedimiento: nodo, obtenerMetadatosAdicionales
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            locales#agregarAlFinal: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}, (Conjunto#desdeArreglo: (Mapear: locales, &(RN#NombreResueltoDe)))
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}, (Mapear: locales, obtenerMetadatosAdicionales)
finprocedimiento

procedimiento EnumeraciónDeCapturas: ast, informaciónDeCapturas
    variables acc, DECLARACIONES, asoc
    fijar DECLARACIONES a Arreglo#crearCon: AST#NodoVariable, AST#NodoFunción, AST#NodoIdentificador
    fijar acc a 0
    fijar asoc a Diccionario#vacío

    procedimiento marcarÍndiceCapturaEnDeclaración: nid
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, 0
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, acc
        asoc#fijarEn: (RN#NombreResueltoDe: nid), acc
        fijar acc a acc + 1
    finprocedimiento

    funcion miInformaciónDeCapturas: nid
        si asoc#contiene: (RN#NombreResueltoDe: nid)
            devolver ObjetoAdHoc: {altura}, 0, {índiceDeCaptura}, (asoc#en: (RN#NombreResueltoDe: nid))
        sino
            variable dt
            fijar dt a %informaciónDeCapturas: nid
            devolver clonar dt con
                altura: dt#altura + 1
            finclonar
        finsi
    finfuncion

    funcion marcarÍndiceCapturaEnUso: nid
        variable dt
        fijar dt a miInformaciónDeCapturas: nid
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, dt#altura
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, dt#índiceDeCaptura
    finfuncion

    Caminar: ast, funcion: nodo
        devolver Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si (EsInstancia: nodo, AST#NodoFunción) && (Defun#SonElMismoObjeto: nodo, ast)
            ParaCadaElemento: nodo#parámetros, &marcarÍndiceCapturaEnDeclaración
            ParaCadaElemento: nodo#cuerpo, recur
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            ParaCadaElemento: nodo#nombres, &marcarÍndiceCapturaEnDeclaración
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            necesitas no Defun#SonElMismoObjeto: nodo, ast
            marcarÍndiceCapturaEnDeclaración: nodo#nombre
            EnumeraciónDeCapturas: nodo, &miInformaciónDeCapturas
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            marcarÍndiceCapturaEnUso: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento

    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {númeroDeCapturas}, acc
finprocedimiento

procedimiento AnotarÍndiceEnEntorno: ast, capturasAnteriores
    variables númeroDeCapturas, caps
    fijar númeroDeCapturas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {númeroDeCapturas}
    fijar caps a clonar capturasAnteriores con finclonar
    caps#agregarAlFinal: númeroDeCapturas
    funcion obtenerÍndiceEnEntorno: nid
        variables altura, índice
        fijar altura a nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índice a nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        devolver (Reducir: 0, (BinOp: {+}), (PedazoDeArreglo: caps, 0, ((caps#longitud - altura) - 1))) + índice
    finfuncion
    procedimiento marcarÍndice: nid
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceEnEntorno}, (obtenerÍndiceEnEntorno: nid)
    finprocedimiento
    Caminar: ast, funcion: nodo
        devolver (no Defun#SonElMismoObjeto: nodo, ast) && ((EsInstancia: nodo, AST#NodoIdentificador) || (EsInstancia: nodo, AST#NodoFunción))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoIdentificador
            marcarÍndice: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            marcarÍndice: nodo#nombre
            AnotarÍndiceEnEntorno: nodo, caps
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento


[ Nombre código del backend. Véase también la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Tupla (IR) Bootstrap}

funcion NombreEnIR: identOBinding
    si EsInstancia: identOBinding, AST#NodoIdentificador
        fijar identOBinding a RN#NombreResueltoDe: identOBinding
    finsi
    devolver identOBinding
finfuncion

funcion LocalDelEntornoSuperior
    devolver {ESUP}
finfuncion

funcion LocalDelEntornoActual
    devolver {EACT}
finfuncion


clase Tupla
    atributos opcode, argumentos

    metodo estatico crear: op, ...args
    metodo es: op
    metodo en: n
    metodo comoTexto
finclase

metodo estatico Tupla#crear: op, ...args
    variable inst
    fijar inst a yo#_crear
    fijar inst#opcode a op
    fijar inst#argumentos a args
    devolver inst
finmetodo

metodo Tupla#es: op
    devolver yo#op = op
finmetodo

metodo Tupla#en: n
    devolver yo#argumentos#en: n
finmetodo

metodo Tupla#comoTexto
    devolver {(Tupla ~t ~t)}#formatear:
        yo#opcode#nombre,
        (Unir:
         (Mapear: yo#argumentos, funcion: x
              devolver x#comoTexto
          finfuncion),
         {, })
finmetodo

funcion EnumConValoresIncrementales: nombre, ...valores
    variable pares
    fijar pares a Diccionario#vacío
    ParaCadaElementoConÍndice: valores, procedimiento: valor, i
        pares#fijarEn: valor, i
    finprocedimiento
    devolver EnumConValores: nombre, ...(Aplanar: pares#comoArreglo)
finfuncion

variable Opcode
fijar Opcode a EnumConValoresIncrementales: {Opcode},
    {SUM},     [ SUM ]
    {SUB},     [ SUB ]
    {MUL},     [ MUL ]
    {DIV},     [ DIV ]
    {LSET},    [ LSET Lx ]
    {LGET},    [ LGET Lx ]
    {LSETC},   [ LSETC Ua, Ub ]
    {LGETC},   [ LGETC Ua, Ub ]
    {CONST},   [ CONST Cx ]
    {ICONST},  [ ICONST Na ]
    {FCONST},  [ FCONST Fa ]
    {LOCAL},   [ LOCAL Lx  (Solo al principio de un procedimiento) ]
    {PARAM},   [ PARAM Lx  (Solo antes que LOCAL en un procedimiento) ]
    {CALL},    [ CALL Px, Ua, Ub ]
    {ECALL},   [ ECALL Lx, Ua, Ub, Uc ]
    {RT_LIT},  [ RT_LIT ]
    {PRINTT},  [ PRINTT ]
    {MKCLZ},   [ MKCLZ Px ]
    {EGET},    [ EGET Lx, Na ]
    {ESET},    [ ESET Lx, Na ]
    {EGETC},   [ EGETC Lx, Na, Nb ]
    {ESETC},   [ ESETC Lx, Na, Nb ]
    {EINIT},   [ EINIT Lx, Ua, Ly ]
    {EINITC},  [ EINITC Lx, Ua, Ub ]
    {ECALLC},  [ ECALLC Lx, Ua, Ub, Uc, Ud ]
    {MKENV},   [ MKENV Na ]
    {MK0CLZ},  [ MK0CLZ Px ]
    {DYNCALL}, [ DYNCALL Na, Nb ]
    {IFRAME},  [ IFRAME Lx, Ly ]
    {EFRAME}   [ EFRAME Lx ]

metodo Opcode#bytecode
    devolver yo#valor
finmetodo

variable OP
si VERDADERO
    clase I
        metodo metodoNoEncontrado: mensaje, argumentos
    finclase

    metodo I#metodoNoEncontrado: mensaje, argumentos
        devolver Tupla#crear: (EnviarMensaje: Opcode, mensaje), ...argumentos
    finmetodo

    fijar OP a I#crear
finsi

clase DeclrFunción
    atributos nombre, parámetros, cuerpo
finclase

metodo estatico DeclrFunción#crear: nom, par, cuer
    devolver clonar yo#_crear con
        nombre: nom
        parámetros: par
        cuerpo: cuer
    finclonar
finmetodo

metodo DeclrFunción#comoTexto
    devolver {(DeclrFunción ~t con ~t es ~t)}#formatear: yo#nombre, yo#parámetros, yo#cuerpo
finmetodo


clase Compilado
    atributos instrucciones, declaraciones
finclase

metodo estatico Compilado#crear: i, d
    devolver clonar yo#_crear con
        instrucciones: i
        declaraciones: d
    finclonar
finmetodo

metodo estatico Compilado#deInstrucciónes: i
    devolver Compilado#crear: i, Arreglo#vacio
finmetodo

metodo estatico Compilado#deDeclaraciones: d
    devolver Compilado#crear: Arreglo#vacio, d
finmetodo

metodo estatico Compilado#vacío
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio
finmetodo

metodo Compilado#operador_>>: otro
    devolver Compilado#crear:
        (Concatenar: yo#instrucciones, otro#instrucciones),
        (Concatenar: yo#declaraciones, otro#declaraciones)
finmetodo

metodo Compilado#comoTexto
    devolver {(Compilado ds = ~t, is = ~t)}#formatear: yo#declaraciones, yo#instrucciones
finmetodo


procedimiento Listado: compilado
    Escribir: {===== Code:}
    ParaCadaElementoConÍndice: compilado#instrucciones, procedimiento: tupla, i
        Escribir: ({#~t}#formatear: i), {}, ({[~t] ~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
    finprocedimiento
    Escribir: {===== Declr:}
    ParaCadaElementoConÍndice: compilado#declaraciones, procedimiento: declr, i
        necesitas EsInstancia: declr, DeclrFunción
        Escribir: ({#~t}#formatear: i), {proc}, declr#nombre
        ParaCadaElementoConÍndice: declr#parámetros, procedimiento: p, j
            Escribir: {}, {}, ({#~t}#formatear: j), p
        finprocedimiento
        ParaCadaElementoConÍndice: declr#cuerpo, procedimiento: tupla, i
            Escribir: {}, ({#~t}#formatear: i), {}, ({[~t] ~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
        finprocedimiento
        Escribir: {}, {end}
    finprocedimiento
finprocedimiento


funcion UnirCompilados: partes
    devolver Reducir: Compilado#vacío, (BinOp: {>>}), partes
finfuncion


funcion NombresDefinídosSinParámetros: ast
    devolver ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSinParámetros}
finfuncion

funcion NombresDeLosParámetros: ast
    devolver Mapear: ast#parámetros, &(RN#NombreResueltoDe)
finfuncion


funcion LocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
finfuncion

funcion RemapeosDelBloque: locales, nombresLibres
    variable i
    fijar i a 0
    Escribir: {$$}, locales, {::}, nombresLibres
    devolver Diccionario#desdeArreglo: (Mapear: locales, funcion: metalocal
        variable nuevoBinding
        fijar nuevoBinding a i
        fijar i a i + 1
        devolver Arreglo#crearCon: (NombreEnIR: metalocal#binding), nuevoBinding
    finfuncion)
finfuncion

funcion CompilarBloqueAWasm: subámbito, instrucciones, bindingsCapturados
    variables is, ds
    fijar is a Arreglo#vacio
    fijar ds a Arreglo#vacio
    [ ParaCadaElemento: subámbito#todosLosBindingsLocales, procedimiento: binding ]
    [     variable id ]
    [     fijar id a NombreEnIR: binding ]
    [     is#agregarAlFinal: (Arreglo#crearCon: (OP#LOCAL: id)) ]
    [ finprocedimiento ]
    ParaCadaElemento: instrucciones, procedimiento: instr
        variable subc
        fijar subc a CompilarAWasm: instr, bindingsCapturados
        is#agregarAlFinal: subc#instrucciones
        ds#agregarAlFinal: subc#declaraciones
        si EsInstancia: instr, AST#NodoExpresion
            is#agregarAlFinal: (Arreglo#crearCon: OP#PRINTT)
        finsi
    finprocedimiento
    devolver Compilado#crear: (Aplanar: is), (Aplanar: ds)
finfuncion

funcion CompilarAWasm: ast, bindingsCapturados
    funcion IDDeIR: binding
        variable ir
        fijar ir a NombreEnIR: binding
        si bindingsCapturados#contiene: ir
            devolver bindingsCapturados#en: ir
        sino
            Escribir: {remapeo no encontrado para}, ir
            devolver ir
        finsi
    finfuncion

    si EsInstancia: ast, AST#NodoPrograma
        variable subámbito
        fijar subámbito a RN#ObtenerNombresDefinídos: ast
        devolver CompilarBloqueAWasm: subámbito, ast#instrucciones, bindingsCapturados
    finsi
    si EsInstancia: ast, AST#NodoNumeroLiteral
        devolver Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#CONST: ast#valor), OP#RT_LIT)
    finsi
    si EsInstancia: ast, AST#NodoOperador
        variables lhs, rhs
        fijar lhs a CompilarAWasm: ast#lhs, bindingsCapturados
        fijar rhs a CompilarAWasm: ast#rhs, bindingsCapturados
        si ast#op#op = {+}
            devolver lhs >> rhs >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#SUM))
        finsi
        si ast#op#op = {-}
            devolver lhs >> rhs >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#SUB))
        finsi
        si ast#op#op = {*}
            devolver lhs >> rhs >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#MUL))
        finsi
        si ast#op#op = {/}
            devolver lhs >> rhs >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#DIV))
        finsi
        NoImplementado
    finsi
    si EsInstancia: ast, AST#NodoIdentificador
        variables id, nombreIR, esCaptura, índiceEnEntorno, altura, índiceDeCaptura, res
        fijar nombreIR a NombreEnIR: ast
        fijar índiceEnEntorno a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceEnEntorno}
        fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        fijar esCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        si esCaptura || (altura > 0)
            fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#EGETC: LocalDelEntornoActual, altura, índiceDeCaptura))
        sino
            fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGET: índiceDeCaptura))
        finsi
        si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
            fijar res a res >> Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#DYNCALL: 0, 1))
        finsi
        devolver res
        [ si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable} ]
        [     devolver Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#ECALLC: LocalDelEntornoActual, altura, índiceDeCaptura, 0, 1)) ]
        [ sino ]
        [     devolver Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#EGETC: LocalDelEntornoActual, altura, índiceDeCaptura)) ]
        [ finsi ]
    finsi
    si EsInstancia: ast, AST#NodoVariable
        devolver Compilado#vacío
    finsi
    si EsInstancia: ast, AST#NodoFijar
        variables id, val, altura, índiceDeCaptura, op, esCaptura
        fijar id a IDDeIR: ast#objetivo
        fijar altura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índiceDeCaptura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        fijar esCaptura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        si esCaptura || (altura > 0)
            fijar op a OP#LSETC: LocalDelEntornoActual, altura, índiceDeCaptura
        sino
            fijar op a OP#LSET: LocalDelEntornoActual, índiceDeCaptura
        finsi
        fijar val a CompilarAWasm: ast#valor, bindingsCapturados
        devolver val >> (Compilado#deInstrucciónes: (Arreglo#crearCon: op))
    finsi
    si EsInstancia: ast, AST#NodoFunción
        variables id, parámetros, preludio, cuerpo, fn, remapeos, nombresLibres, inicDeClosure, locales, capturas
        [ fijar id a IDDeIR: ast#nombre ]
        [ fijar locales a LocalesDelBloque: ast ]
        [ fijar nombresLibres a NombresLibres: ast ]
        [ fijar remapeos a RemapeosDelBloque: locales, nombresLibres ]
        [ fijar parámetros a Mapear: ast#parámetros, funcion: nid ]
        [     devolver remapeos#en: (NombreEnIR: (RN#NombreResueltoDe: nid)) ]
        [ finfuncion ]
        [ fijar preludio a (Compilado#deInstrucciónes: ]
        [     (Arreglo#crearCon: ]
        [         (OP#IFRAME: LocalDelEntornoActual, LocalDelEntornoSuperior), ]
        [         ...(Mapear: (Únicos: (Filtrar: locales, (MétodoComoFunción: {esLocal}))), ]
        [                     funcion: metalocal ]
        [                         devolver OP#EINIT: LocalDelEntornoActual, metalocal#índiceDeCaptura, (remapeos#en: (NombreEnIR: metalocal#binding)) ]
        [                     finfuncion), ]
        [         (OP#MKCLZ: {DONE}))) ]
        [ si (locales#longitud > 0) || VERDADERO ]
        [     fijar parámetros a Concatenar: (Arreglo#crearCon: LocalDelEntornoSuperior), parámetros ]
        [     fijar inicDeClosure a ]
        [         (Compilado#deInstrucciónes: (Arreglo#crearCon: ]
        [             (OP#MKENV: {EL}))) ]
        [         >> (Compilado#deInstrucciónes: ]
        [             (Aplanar: (Mapear: (Únicos: (Filtrar: locales, funcion: obj devolver no obj#esLocal finfuncion)), ]
        [                                funcion: metalocal ]
        [                                    devolver Arreglo#crearCon: ]
        [                                        (OP#ESET: {EL}, metalocal#índiceDeCaptura, (bindingsCapturados#en: (NombreEnIR: metalocal#binding))) ]
        [                                finfuncion))) ]
        [         >> (Compilado#deInstrucciónes: (Arreglo#crearCon: ]
        [             (OP#MKCLZ: {EL}, id))) ]
        [ sino ]
        [     fijar inicDeClosure a Compilado#vacío ]
        [ finsi ]
        fijar id a NombreEnIR: ast#nombre

        fijar preludio a Arreglo#vacio
        [ params ]
        fijar parámetros a Mapear: ast#parámetros, funcion: nid
            devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        finfuncion
        preludio#agregarAlFinal: (OP#PARAM: LocalDelEntornoSuperior)
        preludio#agregarAlFinal: (Mapear: parámetros, funcion: idx devolver OP#PARAM: idx finfuncion)
        [ locales ]
        fijar locales a LocalesDelBloque: ast
        preludio#agregarAlFinal: (Mapear: (Únicos:
            (Filtrar: (Filtrar: locales, (MétodoComoFunción: {esLocal})), funcion: meta
                devolver no Contiene: parámetros, meta#índiceDeCaptura
            finfuncion)),
            funcion: metalocal
                devolver OP#LOCAL: metalocal#índiceDeCaptura
            finfuncion)
        [ envinit ]
        fijar capturas a Únicos: (Filtrar: locales, funcion: metalocal
            devolver metalocal#esLocal && metalocal#esCapturado
        finfuncion)
        preludio#agregarAlFinal: (OP#IFRAME: LocalDelEntornoActual, LocalDelEntornoSuperior)
        preludio#agregarAlFinal: (Mapear: capturas, funcion: metalocal
            devolver OP#EINIT: LocalDelEntornoActual, metalocal#índiceDeCaptura, metalocal#índiceDeCaptura
        finfuncion)
        preludio#agregarAlFinal: (OP#EFRAME: LocalDelEntornoActual)

        fijar nombresLibres a NombresLibres: ast
        fijar remapeos a RemapeosDelBloque: locales, nombresLibres

        fijar inicDeClosure a Compilado#deInstrucciónes: (Arreglo#crearCon:
            (OP#MKCLZ: LocalDelEntornoActual, id, (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}), (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura})))

        fijar cuerpo a (Compilado#deInstrucciónes: (Aplanar: preludio)) >> (CompilarBloqueAWasm: (NombresDefinídosSinParámetros: ast), ast#cuerpo, remapeos)
        fijar fn a DeclrFunción#crear: id, parámetros, cuerpo#instrucciones
        devolver inicDeClosure >> (Compilado#deDeclaraciones: cuerpo#declaraciones) >> (Compilado#deDeclaraciones: (Arreglo#crearCon: fn))
    finsi
    Inalcanzable
finfuncion

funcion ParsearYDefunc: programa
    variable ast
    fijar ast a Parser#CrearAST: programa

    variable ámbitoPrincipal
    fijar ámbitoPrincipal a RN#ResolverNombres:
        ast,
        procedimiento: nombreDelMódulo
            Inalcanzable
        finprocedimiento,
        procedimiento: ámbito finprocedimiento,
        procedimiento: ámbito finprocedimiento
    Defun#Defuncionalizar: ast
    devolver ast
finfuncion

variables ast, programa, cc
fijar programa a {

variable X, Y
funcion Q: W, E
    funcion A: S
        fijar E a S
        fijar X a S
    finfuncion
    fijar X a W
    A
finfuncion
Q

}

[{

funcion Q
    2 * 3 - 20 / 4
finfuncion

funcion W: X, Y
    funcion J: K
        funcion Ñ: L
            L - K - X
        finfuncion
        K + X + Y
    finfuncion
    X + Y
finfuncion

variables X, Y, Z
fijar X a 4
fijar Y a X * 2 - Q * 2
fijar Z a Y * Y
Z / 2
Q

}]

clase XD
    atributos esCapturado, binding, índiceDeCaptura, esLocal, altura
    metodo comoTexto
finclase

metodo XD#comoTexto
    devolver {(XD binding = ~t, índiceDeCaptura = ~t, altura = ~t, esCapturado = ~t, esLocal = ~t)}#formatear: yo#binding, yo#índiceDeCaptura, yo#altura, yo#esCapturado, yo#esLocal
finmetodo

fijar ast a ParsearYDefunc: programa
AnotaciónDeCapturas: ast
EnumeraciónDeCapturas: ast, funcion: nid Escribir: {INALC}, nid Inalcanzable finfuncion
AnotarÍndiceEnEntorno: ast, (Arreglo#crearCon: 0)
EnumeraciónDeLocalesDeProcedimiento: ast, funcion: nid
    devolver clonar XD#crear con
        esCapturado: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        binding: RN#NombreResueltoDe: nid
        índiceDeCaptura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        altura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        esLocal: (nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}) = 0
    finclonar
finfuncion
Escribir: {ast=}, ast
fijar cc a CompilarAWasm: ast, (RemapeosDelBloque: (LocalesDelBloque: ast), (NombresLibres: ast))
Listado: cc
[fijar cc a CompilarAWasm: ast, Diccionario#vacío

Escribir: ({~t :: ~t :: ~t}#formatear: (TipoDe: cc), (TipoDe: cc#declaraciones), (TipoDe: cc#instrucciones))
Escribir: ({~t~%~t}#formatear: cc#declaraciones, cc#instrucciones)
Listado: cc]
[__Lua: {rt.inspectobj}, cc]
