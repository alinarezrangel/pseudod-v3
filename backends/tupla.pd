utilizar bepd/builtins
utilizar bepd/datos/conjunto (Conjunto)
utilizar bepd/datos/diccionario (Diccionario)
utilizar bepd/x/puerto/conPosición (PosiciónTextual)
utilizar bepd/utilidades/texto
utilizar bepd/x/enum (Enum, EnumConValores)

utilizar tokens como Tokens
utilizar ast como AST
utilizar parser como Parser
utilizar resoluciónDeNombres como RN
utilizar defuncionalización como Defun



[ Pase de anotación de capturas

  Anota cada identificador en su punto de declaración con un metadato
  `capturado` (boole) que indica si el identificador fue capturado o no.

]

funcion Parcial: proc, ...argumentos
    devolver funcion: ...másArgumentos
        devolver %proc: ...argumentos, ...másArgumentos
    finfuncion
finfuncion

funcion MétodoComoFunción: ...args
    si args#longitud = 1
        devolver funcion: obj, ...resto
            devolver EnviarMensaje: obj, (args#en: 0), ...resto
        finfuncion
    sino
        necesitas args#longitud = 2
        devolver funcion: ...resto
            devolver EnviarMensaje: (args#en: 0), (args#en: 1), ...resto
        finfuncion
    finsi
finfuncion

funcion Caminar: nodo, filtro, cuerpo
    si %filtro: nodo
        devolver %cuerpo: nodo, funcion: cont
            devolver Caminar: cont, filtro, cuerpo
        finfuncion
    finsi

    funcion recur: nodo
        devolver Caminar: nodo, filtro, cuerpo
    finfuncion

    si EsInstancia: nodo, AST#NodoPrograma
        devolver ParaCadaElemento: nodo#instrucciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoVariable
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFijar
        recur: nodo#objetivo
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoEscribir
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoNl
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoClase
        recur: nodo#nombre
        si no EsNulo: nodo#claseBase
            recur: nodo#claseBase
        finsi
        ParaCadaElemento: nodo#extiendeClases, &recur
        ParaCadaElemento: nodo#implementaClases, &recur
        devolver ParaCadaElemento: nodo#declaraciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#parámetros, &recur
    finsi
    si EsInstancia: nodo, AST#NodoImplementa
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#definiciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineMétodoEnClase
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunción
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoNecesitas
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoDevolver
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoSi
        recur: nodo#condicional
        ParaCadaElemento: nodo#siVerdadero, &recur
        devolver ParaCadaElemento: nodo#siFalso, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMientras
        recur: nodo#condicional
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMétodo
        si no EsNulo: nodo#deClase
            recur: nodo#deClase
        finsi
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoAtributos
        recur: nodo#deClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoUtilizar
        NoImplementado
    finsi

    si EsInstancia: nodo, AST#NodoIdentificador
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoNumeroLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoTextoLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoLlamarProcedimiento
        recur: nodo#proc
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoEnviarMensaje
        recur: nodo#objeto
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoOperador
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoNoLlamar
        devolver recur: nodo#base
    finsi
    si EsInstancia: nodo, AST#NodoAutoejecutar
        recur: nodo#expr
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunciónAnónima
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoSonIguales
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoReferenciar
        devolver recur: nodo#nombre
    finsi
    si EsInstancia: nodo, AST#NodoNo
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoClonar
        recur: nodo#expresiónAClonar
        devolver ParaCadaElemento: nodo#campos, funcion: campo
            devolver recur: (campo#en: 1)
        finfuncion
    finsi

    si EsInstancia: nodo, AST#NodoVariadic
        devolver recur: nodo#interno
    finsi

    [ Nunca se llega hasta aquí. ]
    Escribir: ({Caminar no implementado para ~t}#formatear: (TipoDe: nodo))
    Inalcanzable
finfuncion


clase LlaveAnotaciónDeCapturas
    metodo comoTexto
finclase

metodo LlaveAnotaciónDeCapturas#comoTexto
    devolver {LLAVE_ANOTACIÓN_DE_CAPTURAS}
finmetodo

variable LLAVE_ANOTACIÓN_DE_CAPTURAS
fijar LLAVE_ANOTACIÓN_DE_CAPTURAS a LlaveAnotaciónDeCapturas#crear

funcion AnotaciónDeCapturas: ast
    variable nombresCapturadosAcc, nombresCapturados
    fijar nombresCapturadosAcc a Arreglo#vacio
    Caminar: ast, funcion: nodo
        variable declaraciones
        fijar declaraciones a Arreglo#crearCon:
            AST#NodoVariable, AST#NodoFunción, AST#NodoClase, AST#NodoMétodo, AST#NodoFunciónAnónima
        devolver Algún: (Mapear: declaraciones, (Parcial: &EsInstancia, nodo))
    finfuncion, funcion: nodo, recur
        si EsInstancia: nodo, AST#NodoFunción
            nombresCapturadosAcc#agregarAlFinal: (nodo#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres})
            ParaCadaElemento: nodo#cuerpo, funcion: cn
                devolver %recur: cn
            finfuncion
            devolver NULO
        finsi
    finfuncion
    fijar nombresCapturados a Reducir: Conjunto#vacío, (MétodoComoFunción: {unión}), nombresCapturadosAcc
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoIdentificador
    finfuncion, funcion: nodo, recur
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}, (nombresCapturados#contiene: (RN#NombreResueltoDe: nodo))
    finfuncion
finfuncion


[ Nombre código del backend. Véase también la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Tupla (IR) Bootstrap}

funcion NombreEnIR: identOBinding
    si EsInstancia: identOBinding, AST#NodoIdentificador
        fijar identOBinding a RN#NombreResueltoDe: identOBinding
    finsi
    devolver identOBinding
finfuncion

funcion LocalDelEntorno
    devolver {E}
finfuncion


clase Tupla
    atributos opcode, argumentos

    metodo estatico crear: op, ...args
    metodo es: op
    metodo en: n
    metodo comoTexto
finclase

metodo estatico Tupla#crear: op, ...args
    variable inst
    fijar inst a yo#_crear
    fijar inst#opcode a op
    fijar inst#argumentos a args
    devolver inst
finmetodo

metodo Tupla#es: op
    devolver yo#op = op
finmetodo

metodo Tupla#en: n
    devolver yo#argumentos#en: n
finmetodo

metodo Tupla#comoTexto
    devolver {(Tupla ~t ~t)}#formatear:
        yo#opcode#nombre,
        (Unir:
         (Mapear: yo#argumentos, funcion: x
              devolver x#comoTexto
          finfuncion),
         {, })
finmetodo

variable Opcode
fijar Opcode a EnumConValores: {Opcode},
    {SUM}, 0,
    {SUB}, 1,
    {MUL}, 2,
    {DIV}, 3,
    {LSET}, 4,
    {LGET}, 5,
    {CONST}, 6,
    {LOCAL}, 7,
    {CALL}, 8,
    {RT_LIT}, 9,
    {PRINTT}, 10,
    {MKCLZ}, 11,
    {EGET}, 12,
    {ESET}, 13,
    {MKENV}, 14,
    {MK0CLZ}, 15,
    {DYNCALL}, 16,
    {ECALL}, 17

metodo Opcode#bytecode
    devolver yo#valor
finmetodo

variable OP
si VERDADERO
    clase I
        metodo metodoNoEncontrado: mensaje, argumentos
    finclase

    metodo I#metodoNoEncontrado: mensaje, argumentos
        devolver Tupla#crear: (EnviarMensaje: Opcode, mensaje), ...argumentos
    finmetodo

    fijar OP a I#crear
finsi

clase DeclrFunción
    atributos nombre, parámetros, cuerpo
finclase

metodo estatico DeclrFunción#crear: nom, par, cuer
    devolver clonar yo#_crear con
        nombre: nom
        parámetros: par
        cuerpo: cuer
    finclonar
finmetodo

metodo DeclrFunción#comoTexto
    devolver {(DeclrFunción ~t con ~t es ~t)}#formatear: yo#nombre, yo#parámetros, yo#cuerpo
finmetodo


clase Compilado
    atributos instrucciones, declaraciones
finclase

metodo estatico Compilado#crear: i, d
    devolver clonar yo#_crear con
        instrucciones: i
        declaraciones: d
    finclonar
finmetodo

metodo estatico Compilado#deInstrucciónes: i
    devolver Compilado#crear: i, Arreglo#vacio
finmetodo

metodo estatico Compilado#deDeclaraciones: d
    devolver Compilado#crear: Arreglo#vacio, d
finmetodo

metodo estatico Compilado#vacío
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio
finmetodo

metodo Compilado#operador_>>: otro
    devolver Compilado#crear:
        (Concatenar: yo#instrucciones, otro#instrucciones),
        (Concatenar: yo#declaraciones, otro#declaraciones)
finmetodo

metodo Compilado#comoTexto
    devolver {(Compilado ds = ~t, is = ~t)}#formatear: yo#declaraciones, yo#instrucciones
finmetodo


procedimiento Listado: compilado
    Escribir: {===== Code:}
    ParaCadaElementoConÍndice: compilado#instrucciones, procedimiento: tupla, i
        Escribir: ({#~t}#formatear: i), {}, ({[~t] ~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
    finprocedimiento
    Escribir: {===== Declr:}
    ParaCadaElementoConÍndice: compilado#declaraciones, procedimiento: declr, i
        necesitas EsInstancia: declr, DeclrFunción
        Escribir: ({#~t}#formatear: i), {proc}, declr#nombre
        ParaCadaElementoConÍndice: declr#parámetros, procedimiento: p, j
            Escribir: {}, {}, ({#~t}#formatear: j), p
        finprocedimiento
        ParaCadaElementoConÍndice: declr#cuerpo, procedimiento: tupla, i
            Escribir: {}, ({#~t}#formatear: i), {}, ({[~t] ~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
        finprocedimiento
        Escribir: {}, {end}
    finprocedimiento
finprocedimiento


funcion BinOp: op
    devolver funcion: lhs, rhs
        devolver EnviarMensaje: lhs, ({operador_}#concatenar: op), rhs
    finfuncion
finfuncion

funcion UnirCompilados: partes
    devolver Reducir: Compilado#vacío, (BinOp: {>>}), partes
finfuncion


funcion NombresDefinídosSinParámetros: ast
    devolver ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSinParámetros}
finfuncion

funcion NombresDeLosParámetros: ast
   devolver Mapear: ast#parámetros, &(RN#NombreResueltoDe)
finfuncion


funcion CompilarBloqueAWasm: subámbito, instrucciones, bindingsCapturados
    variables is, ds
    fijar is a Arreglo#vacio
    fijar ds a Arreglo#vacio
    ParaCadaElemento: subámbito#todosLosBindingsLocales, procedimiento: binding
        variable id
        fijar id a NombreEnIR: binding
        is#agregarAlFinal: (Arreglo#crearCon: (OP#LOCAL: id))
    finprocedimiento
    ParaCadaElemento: instrucciones, procedimiento: instr
        variable subc
        fijar subc a CompilarAWasm: instr, bindingsCapturados
        is#agregarAlFinal: subc#instrucciones
        ds#agregarAlFinal: subc#declaraciones
        si EsInstancia: instr, AST#NodoExpresion
            is#agregarAlFinal: (Arreglo#crearCon: OP#PRINTT)
        finsi
    finprocedimiento
    devolver Compilado#crear: (Aplanar: is), (Aplanar: ds)
finfuncion

funcion CompilarAWasm: ast, bindingsCapturados
    funcion IDDeIR: binding
        variable ir
        fijar ir a NombreEnIR: binding
        si bindingsCapturados#contiene: ir
            devolver bindingsCapturados#en: ir
        sino
            devolver ir
        finsi
    finfuncion
    si EsInstancia: ast, AST#NodoPrograma
        variable subámbito
        fijar subámbito a RN#ObtenerNombresDefinídos: ast
        devolver CompilarBloqueAWasm: subámbito, ast#instrucciones, bindingsCapturados
    finsi
    si EsInstancia: ast, AST#NodoNumeroLiteral
        devolver Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#CONST: ast#valor), OP#RT_LIT)
    finsi
    si EsInstancia: ast, AST#NodoOperador
        variable lhs, rhs
        fijar lhs a CompilarAWasm: ast#lhs, bindingsCapturados
        fijar rhs a CompilarAWasm: ast#rhs, bindingsCapturados
        si ast#op#op = {+}
            devolver lhs >> rhs >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#SUM))
        finsi
        si ast#op#op = {-}
            devolver lhs >> rhs >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#SUB))
        finsi
        si ast#op#op = {*}
            devolver lhs >> rhs >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#MUL))
        finsi
        si ast#op#op = {/}
            devolver lhs >> rhs >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#DIV))
        finsi
        NoImplementado
    finsi
    si EsInstancia: ast, AST#NodoIdentificador
        variables id, nombreIR, esCaptura
        fijar nombreIR a NombreEnIR: ast
        si bindingsCapturados#contiene: nombreIR
            fijar id a bindingsCapturados#en: nombreIR
            fijar esCaptura a VERDADERO
        sino
            fijar id a nombreIR
            fijar esCaptura a FALSO
        finsi
        si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
            si esCaptura
                devolver Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#ECALL: LocalDelEntorno, id, 0, 1))
            sino
                devolver Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#CALL: id, 0, 1))
            finsi
        sino
            si esCaptura
                devolver Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#EGET: LocalDelEntorno, id))
            sino
                devolver Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGET: id))
            finsi
        finsi
    finsi
    si EsInstancia: ast, AST#NodoVariable
        devolver Compilado#vacío
    finsi
    si EsInstancia: ast, AST#NodoFijar
        variables id, val
        fijar id a IDDeIR: ast#objetivo
        fijar val a CompilarAWasm: ast#valor, bindingsCapturados
        devolver val >> (Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LSET: id)))
    finsi
    si EsInstancia: ast, AST#NodoFunción
        variables id, parámetros, cuerpo, fn, nombresLibres, remapeos, i, nuevasCapturas, inicDeClosure
        fijar id a IDDeIR: ast#nombre
        fijar parámetros a Mapear: (NombresDeLosParámetros: ast), &IDDeIR
        fijar cuerpo a Compilado#vacío
        fijar nombresLibres a ast#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres}
        fijar i a 0
        fijar nuevasCapturas a Arreglo#vacio
        fijar remapeos a Diccionario#desdeArreglo: (nombresLibres#mapear: funcion: binding
            variable nuevoBinding
            fijar nuevoBinding a i
            fijar i a i + 1
            nuevasCapturas#agregarAlFinal: nuevoBinding
            devolver Arreglo#crearCon: (NombreEnIR: binding), nuevoBinding
        finfuncion)#comoArreglo
        si nombresLibres#longitud > 0
            fijar parámetros a Concatenar: (Arreglo#crearCon: LocalDelEntorno), parámetros
            [ fijar cuerpo a (Compilado#deInstrucciónes: (Mapear: nuevasCapturas, funcion: ir ]
            [     devolver OP#LOCAL: ir ]
            [ finfuncion)) >> cuerpo ]
            fijar inicDeClosure a
                (Compilado#deInstrucciónes: (Arreglo#crearCon:
                    (OP#MKENV: LocalDelEntorno)))
                >> (Compilado#deInstrucciónes: (Aplanar: (Mapear: nombresLibres#comoArreglo, funcion: binding
                        devolver Arreglo#crearCon:
                            (OP#ESET: LocalDelEntorno, (remapeos#en: binding), (NombreEnIR: binding))
                    finfuncion)))
                >> (Compilado#deInstrucciónes: (Arreglo#crearCon:
                    (OP#MKCLZ: LocalDelEntorno, id)))
        sino
            fijar inicDeClosure a Compilado#vacío
        finsi
        fijar cuerpo a cuerpo >> CompilarBloqueAWasm: (NombresDefinídosSinParámetros: ast), ast#cuerpo, remapeos
        fijar fn a DeclrFunción#crear: id, parámetros, cuerpo#instrucciones
        devolver inicDeClosure >> (Compilado#deDeclaraciones: cuerpo#declaraciones) >> (Compilado#deDeclaraciones: (Arreglo#crearCon: fn))
    finsi
    Inalcanzable
finfuncion

funcion ParsearYDefunc: programa
    variable ast
    fijar ast a Parser#CrearAST: programa

    variable ámbitoPrincipal
    fijar ámbitoPrincipal a RN#ResolverNombres:
        ast,
        procedimiento: nombreDelMódulo
            Inalcanzable
        finprocedimiento,
        procedimiento: ámbito finprocedimiento,
        procedimiento: ámbito finprocedimiento
    Defun#Defuncionalizar: ast
    devolver ast
finfuncion

variables ast, programa, cc
fijar programa a {

variable X, Y
funcion Q: W, E
    fijar X a W
    funcion A: S
        fijar E a S
        fijar X a S
    finfuncion
finfuncion

}

[{

funcion Q
    2 * 3 - 20 / 4
finfuncion

funcion W: X, Y
    funcion J: K
        funcion Ñ: L
            L - K - X
        finfuncion
        K + X + Y
    finfuncion
    X + Y
finfuncion

variables X, Y, Z
fijar X a 4
fijar Y a X * 2 - Q * 2
fijar Z a Y * Y
Z / 2
Q

}]

fijar ast a ParsearYDefunc: programa
Escribir: {ast=}, ast
AnotaciónDeCapturas: ast
Escribir: {res=}, ast
[fijar cc a CompilarAWasm: ast, Diccionario#vacío

Escribir: ({~t :: ~t :: ~t}#formatear: (TipoDe: cc), (TipoDe: cc#declaraciones), (TipoDe: cc#instrucciones))
Escribir: ({~t~%~t}#formatear: cc#declaraciones, cc#instrucciones)
Listado: cc]
[__Lua: {rt.inspectobj}, cc]
