utilizar bepd/builtins
utilizar bepd/x/adhoc (ObjetoAdHoc)
utilizar bepd/datos/conjunto (Conjunto)
utilizar bepd/datos/diccionario (Diccionario)
utilizar bepd/x/puerto (SalidaEstándar)
utilizar bepd/x/puerto/conPosición (PosiciónTextual)
utilizar bepd/x/sistemaDeArchivos/archivo como SistemaDeArchivos
[utilizar bepd/utilidades/arreglo]
utilizar bepd/utilidades/texto
utilizar bepd/x/enum (Enum, EnumConValores)

utilizar tokens como Tokens
utilizar ast como AST
utilizar parser como Parser
utilizar resoluciónDeNombres como RN
utilizar defuncionalización como Defun



[DOCUMENTA
@brief{Devuelve un arreglo sin duplicados.}

Devuelve un arreglo como @pd{arr} pero sin elementos duplicados. Además, el
órden de los elementos no está especificado.
DOCUMENTA]
funcion Únicos: arr
    devolver (Conjunto#desdeArreglo: arr)#comoArreglo
finfuncion

funcion SepararArreglo: arr, cond
    variables parteVerdadera, parteFalsa
    fijar parteVerdadera a Arreglo#vacio
    fijar parteFalsa a Arreglo#vacio
    ParaCadaElemento: arr, procedimiento: el
        si %cond: el
            parteVerdadera#agregarAlFinal: el
        sino
            parteFalsa#agregarAlFinal: el
        finsi
    finprocedimiento
    devolver ObjetoAdHoc: {parteVerdadera}, parteVerdadera, {parteFalsa}, parteFalsa
finfuncion


[DOCUMENTA
@brief{Camina un AST.}

Cada nodo del AST es visitado de forma recursiva. Si @pd{filtro} (una función
de la forma @pd{filtro: nodo}) devuelve verdadero entonces la recursión es
terminada y @pd{cuerpo} es llamado con dos valores: el nodo que @pd{filtro}
seleccionó y una función @pd{cont: nodo} que "continúa" con la caminata,
visitando de nuevo (de forma recursiva) @pd{nodo}. Si @pd{filtro} devuelve
falso para un nodo, @pd{cuerpo} no es llamado, en cambio, @pd{Caminar}
automáticamente se llama a si mismo sobre los campos recursivos de ese nodo.

Todo esto básicamente hace que @pd{Caminar} sea una versión más cómoda y más
fácil de usar que @pd{CaminaNodos}.
DOCUMENTA]
variable NADA

funcion Caminar': nodo, cuerpo
    funcion visitarPartesRecursivas: nodo, f
        si EsInstancia: nodo, AST#NodoPrograma
            devolver ParaCadaElemento: nodo#instrucciones, f
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoFijar
            %f: nodo#objetivo
            devolver %f: nodo#valor
        finsi
        si EsInstancia: nodo, AST#NodoEscribir
            devolver %f: nodo#valor
        finsi
        si EsInstancia: nodo, AST#NodoNl
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoClase
            %f: nodo#nombre
            si no EsNulo: nodo#claseBase
                %f: nodo#claseBase
            finsi
            ParaCadaElemento: nodo#extiendeClases, f
            ParaCadaElemento: nodo#implementaClases, f
            devolver ParaCadaElemento: nodo#declaraciones, f
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
            %f: nodo#nombre
            devolver ParaCadaElemento: nodo#parámetros, f
        finsi
        si EsInstancia: nodo, AST#NodoImplementa
            %f: nodo#nombre
            devolver ParaCadaElemento: nodo#definiciones, f
        finsi
        si EsInstancia: nodo, AST#NodoDefineAtributosEnClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoDefineMétodoEnClase
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoNecesitas
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoDevolver
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoSi
            %f: nodo#condicional
            ParaCadaElemento: nodo#siVerdadero, f
            devolver ParaCadaElemento: nodo#siFalso, f
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            %f: nodo#condicional
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoMétodo
            si no EsNulo: nodo#deClase
                %f: nodo#deClase
            finsi
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoAtributos
            %f: nodo#deClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoUtilizar
            NoImplementado
        finsi

        si EsInstancia: nodo, AST#NodoIdentificador
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoNumeroLiteral
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoTextoLiteral
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoLlamarProcedimiento
            %f: nodo#proc
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoEnviarMensaje
            %f: nodo#objeto
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoOperador
            %f: nodo#lhs
            devolver %f: nodo#rhs
        finsi
        si EsInstancia: nodo, AST#NodoNoLlamar
            devolver %f: nodo#base
        finsi
        si EsInstancia: nodo, AST#NodoAutoejecutar
            %f: nodo#expr
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoFunciónAnónima
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoSonIguales
            %f: nodo#lhs
            devolver %f: nodo#rhs
        finsi
        si EsInstancia: nodo, AST#NodoReferenciar
            devolver %f: nodo#nombre
        finsi
        si EsInstancia: nodo, AST#NodoNo
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoClonar
            %f: nodo#expresiónAClonar
            devolver ParaCadaElemento: nodo#campos, funcion: campo
                devolver %f: (campo#en: 1)
            finfuncion
        finsi

        si EsInstancia: nodo, AST#NodoVariadic
            devolver %f: nodo#interno
        finsi

        [ Nunca se llega hasta aquí. ]
        Escribir: ({Caminar no implementado para ~t}#formatear: (TipoDe: nodo))
        Inalcanzable
    finfuncion

    clase RecursorDeCaminar
        metodo \llamar\: nodo
        metodo llamarConRecursión: nodo, recur
    finclase

    metodo RecursorDeCaminar#\llamar\: nodoEnElQueContinuar
        devolver yo#llamarConRecursión: nodoEnElQueContinuar, cuerpo
    finmetodo

    metodo RecursorDeCaminar#llamarConRecursión: nodoEnElQueContinuar, recur
        devolver visitarPartesRecursivas: nodoEnElQueContinuar, funcion: nodo
            devolver %recur: nodo, yo
        finfuncion
    finmetodo

    devolver %cuerpo: nodo, RecursorDeCaminar#crear
finfuncion

funcion Caminar: nodo, filtro, cuerpo
    funcion bucle: nodo, K
        si %filtro: nodo
            devolver %cuerpo: nodo, funcion: nodoEnElQueContinuar
                devolver bucle: nodoEnElQueContinuar, K
            finfuncion
        sino
            devolver %K: nodo
        finsi
    finfuncion
    devolver Caminar': nodo, &bucle
finfuncion


[ Este backend consiste de varios "mini-pases". Actualmente se encuentran en
  este mismo archivo, quizás después deba moverlos a sus propios archivos.

  Todos estos minipases usan la llave de anotación de capturas. ]


clase LlaveAnotaciónDeCapturas
    metodo comoTexto
finclase

metodo LlaveAnotaciónDeCapturas#comoTexto
    devolver {LLAVE_ANOTACIÓN_DE_CAPTURAS}
finmetodo

variable LLAVE_ANOTACIÓN_DE_CAPTURAS
fijar LLAVE_ANOTACIÓN_DE_CAPTURAS a LlaveAnotaciónDeCapturas#crear

[DOCUMENTA
@brief{Obtiene los nombres libres de un nodo.}

Véase el pase de defuncionalización (@pd{Defuncionalizar}).
DOCUMENTA]
funcion NombresLibres: nodo
    si EsInstancia: nodo, AST#NodoPrograma
        devolver Arreglo#vacio
    sino
        devolver nodo#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres}
    finsi
finfuncion

[DOCUMENTA
@brief{Pase de anotación de capturas.}

Anota todos los @pd{AST#NodoIdentificador} del AST con un metadato
@code{esCapturado} (con llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un
@pd{Boole} indicando si ese identificador es capturado o no por una closure.
DOCUMENTA]
procedimiento AnotaciónDeCapturas: ast
    variable nombresCapturadosAcc, nombresCapturados
    fijar nombresCapturadosAcc a Arreglo#vacio
    Caminar: ast, funcion: nodo
        variable declaraciones
        fijar declaraciones a Arreglo#crearCon:
            AST#NodoVariable, AST#NodoFunción, AST#NodoClase, AST#NodoMétodo, AST#NodoFunciónAnónima
        devolver Algún: (Mapear: declaraciones, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoFunción
            nombresCapturadosAcc#agregarAlFinal: (NombresLibres: nodo)
            ParaCadaElemento: nodo#cuerpo, procedimiento: cn
                devolver %recur: cn
            finprocedimiento
            devolver NULO
        finsi
    finprocedimiento
    fijar nombresCapturados a Reducir: Conjunto#vacío, (MétodoComoFunción: {unión}), nombresCapturadosAcc
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoIdentificador
    finfuncion, procedimiento: nodo, recur
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}, (nombresCapturados#contiene: (RN#NombreResueltoDe: nodo))
    finprocedimiento
finprocedimiento


[DOCUMENTA
@brief{Pase de enumeración de locales del procedimiento.}

Acumula las variables locales de todos los ámbitos del
AST. @pd{ámbitoContenedor} es el ámbito que contiene a @pd{ast}.

A medida que acumula las variables, va agregando el resultado de
@pd{%obtenerMetadatosAdicionales: nodoIdentificador} a los siguientes metadatos
de todos los nodos del AST que contienen un ámbito y al identificador
encontrado:

@itemlist(
@item{@pd{AST#NodoPrograma}: @code{localesDelNodo'}.}

@item{@pd{AST#NodoSi}: @code{localesSiVerdadero} y @code{localesSiFalso}.}

@item{@pd{AST#NodoMientras}: @code{localesDelNodo}.}

@item{@pd{AST#NodoPrograma} y @pd{AST#NodoFunción}: @code{localesDelProcedimiento}.}
)

Además, para los @pd{AST#NodoPrograma} y @pd{AST#NodoFunción} el metadato
@code{bindingsLocalesDelProcedimiento} será agregado con los bindings de todas
las variables locales del ámbito.

Todos los metadatos son agregados con la llave de anotación de capturas
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}.
DOCUMENTA]
procedimiento EnumeraciónDeLocalesDeProcedimiento: ast, ámbitoContenedor, obtenerMetadatosAdicionales
    necesitas (EsInstancia: ast, AST#NodoFunción)
           || (EsInstancia: ast, AST#NodoFunciónAnónima)
           || (EsInstancia: ast, AST#NodoPrograma)
    variables locales, ámbitosLocales, nodosLocales
    fijar locales a Arreglo#vacio
    fijar ámbitosLocales a Pila#vacía
    fijar nodosLocales a Pila#vacía

    procedimiento AgregarLocal: nid
        locales#agregarAlFinal: nid
        necesitas ámbitosLocales#_elementos#longitud = nodosLocales#_elementos#longitud
        ParaCadaElemento: nodosLocales#_elementos, procedimiento: agregador
            devolver %agregador: nid
        finprocedimiento
    finprocedimiento

    procedimiento CreaAgregador: nodo, metadato
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato, Arreglo#vacio
        devolver procedimiento: nid
            (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato)#agregarAlFinal: (%obtenerMetadatosAdicionales: nid)
        finprocedimiento
    finprocedimiento

    ámbitosLocales#apilar: ámbitoContenedor
    nodosLocales#apilar: (CreaAgregador: ast, {localesDelNodo'})

    funcion filtro: nodo
        devolver (EsInstancia: nodo, AST#NodoIdentificador)
              || (EsInstancia: nodo, AST#NodoFunción)
              || (EsInstancia: nodo, AST#NodoFunciónAnónima)
              || (EsInstancia: nodo, AST#NodoSi)
              || (EsInstancia: nodo, AST#NodoMientras)
              || (EsInstancia: nodo, AST#NodoPrograma)
    finfuncion

    procedimiento interno: nodo, recur
        si EsInstancia: nodo, AST#NodoIdentificador
            si Defun#EsLocalEntre: ámbitoContenedor, ámbitosLocales#últimoValorApilado, nodo
                AgregarLocal: nodo
            finsi
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            %recur: nodo#condicional
            ámbitosLocales#apilar: (RN#ObtenerNombresDefinídos: nodo)
            nodosLocales#apilar: (CreaAgregador: nodo, {localesDelNodo})
            ParaCadaElemento: nodo#cuerpo, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            %recur: nodo#condicional
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiVerdadero})
            ParaCadaElemento: nodo#siVerdadero, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiFalso})
            ParaCadaElemento: nodo#siFalso, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            AgregarLocal: nodo#nombre
            devolver EnumeraciónDeLocalesDeProcedimiento: nodo, (RN#ObtenerNombresDefinídos: nodo), obtenerMetadatosAdicionales
        finsi
        si (EsInstancia: nodo, AST#NodoFunciónAnónima) || (EsInstancia: nodo, AST#NodoPrograma)
            devolver EnumeraciónDeLocalesDeProcedimiento: nodo, (RN#ObtenerNombresDefinídos: nodo), obtenerMetadatosAdicionales
        finsi
    finprocedimiento

    funcion recurrir: nodo, filtro, cuerpo
        Caminar': nodo, procedimiento: nodo, K
            devolver K#llamarConRecursión: nodo, funcion: nodo, K
                devolver Caminar: nodo, filtro, cuerpo
            finfuncion
        finprocedimiento
    finfuncion

    si (EsInstancia: ast, AST#NodoFunción) || (EsInstancia: ast, AST#NodoFunciónAnónima)
        ParaCadaElemento: ast#parámetros, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
        ParaCadaElemento: ast#cuerpo, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
    finsi
    si EsInstancia: ast, AST#NodoPrograma
        ParaCadaElemento: ast#instrucciones, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
    finsi

    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}, (Conjunto#desdeArreglo: (Mapear: locales, &(RN#NombreResueltoDe)))
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}, (Mapear: locales, obtenerMetadatosAdicionales)
finprocedimiento

procedimiento AnotarLocalesInmediatas: ast
    variable NODOS_CON_ÁMBITO
    fijar NODOS_CON_ÁMBITO a Arreglo#crearCon: AST#NodoPrograma, AST#NodoSi, AST#NodoMientras, AST#NodoFunción, AST#NodoFunciónAnónima

    funcion esBloqueConÁmbito: ast
        devolver (Algún: (Mapear: NODOS_CON_ÁMBITO, (Parcial: &EsInstancia, ast)))
    finfuncion

    procedimiento marcarInmediatas: ast, ámbito, recurBloque
        variable todasLasLocales
        fijar todasLasLocales a Arreglo#vacio
        Caminar: ast, funcion: ast
            devolver (EsInstancia: ast, AST#NodoIdentificador) || (esBloqueConÁmbito: ast)
        finfuncion, procedimiento: ast, recur
            si EsInstancia: ast, AST#NodoIdentificador
                variables nr, inmediata
                fijar nr a RN#NombreResueltoDe: ast
                fijar inmediata a Contiene: ámbito#todosLosBindingsLocales, nr
                Escribir: {ID}, ast
                Escribir: {ES}, nr, {Y}, inmediata
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localInmediata}, inmediata
                si inmediata
                    todasLasLocales#agregarAlFinal: ast
                finsi
                devolver NULO
            finsi
            si EsInstancia: ast, AST#NodoFunción
                %recur: ast#nombre
                devolver %recurBloque: ast
            finsi
            devolver %recurBloque: ast
        finprocedimiento
        devolver todasLasLocales
    finprocedimiento

    procedimiento recursión: ast, K
        si esBloqueConÁmbito: ast
            procedimiento marcarConÁmbito: ast, ámbito
                variable locales
                fijar locales a Arreglo#vacio
                K#llamarConRecursión: ast, funcion: nodo, K'
                    variable nuevasLocales
                    fijar nuevasLocales a marcarInmediatas: nodo, ámbito, funcion: bloque
                        devolver recursión: bloque, K
                    finfuncion
                    fijar locales a Concatenar: locales, nuevasLocales
                finfuncion
                devolver locales
            finprocedimiento

            si EsInstancia: ast, AST#NodoSi
                variables siVerdadero, siFalso, localesSiVerdadero, localesSiFalso
                fijar siVerdadero a ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero}
                fijar siFalso a ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso}
                fijar localesSiVerdadero a marcarConÁmbito: ast, siVerdadero
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiVerdadero}, localesSiVerdadero
                fijar localesSiFalso a marcarConÁmbito: ast, siFalso
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiFalso}, localesSiFalso
                Escribir: {NodoSi}, ast#areaTextual
                Escribir: {siVerdadero}, localesSiVerdadero
                Escribir: {siFalso}, localesSiFalso
            sino
                si EsInstancia: ast, AST#NodoFunción
                    variables ámbito, locales, localInmediata
                    fijar ámbito a RN#ObtenerNombresDefinídos: ast
                    fijar localInmediata a ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localInmediata}
                    fijar locales a marcarConÁmbito: ast, ámbito
                    ast#nombre#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localInmediata}, localInmediata
                    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}, locales
                    Escribir: {NodoFunción}, ast#areaTextual
                    Escribir: {locales}, locales
                sino
                    variables ámbito, locales
                    fijar ámbito a RN#ObtenerNombresDefinídos: ast
                    fijar locales a marcarConÁmbito: ast, ámbito
                    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}, locales
                    Escribir: (TipoDe: ast), ast#areaTextual
                    Escribir: {locales}, locales
                finsi
            finsi
        sino
            Escribir: ast
            Inalcanzable
        finsi
    finprocedimiento

    Caminar': ast, &recursión
finprocedimiento


clase EstadoDeEnumeraciónDeCapturas
    [ asoc: Diccionario de los bindings a sus informaciones de capturas. ]
    [ acc: Número de capturas. ]
    atributos asoc, acc, estadoSuperior

    metodo estatico inicial
    metodo estatico desdeEstado: estado

    metodo marcarÍndiceCapturaEnDeclaración: nid
    metodo marcarÍndiceCapturaEnUso: nid
    metodo informaciónDeLaCaptura: nid

    metodo profundidad
finclase

metodo estatico EstadoDeEnumeraciónDeCapturas#inicial
    devolver yo#crear
finmetodo

metodo estatico EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
    devolver clonar yo#crear con
        estadoSuperior: estado
    finclonar
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#inicializar
    fijar yo#asoc a Diccionario#vacío
    fijar yo#acc a 0
    fijar yo#estadoSuperior a NULO
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnDeclaración: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, 0
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, yo#acc
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, yo#profundidad
    yo#asoc#fijarEn: (RN#NombreResueltoDe: nid), yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#informaciónDeLaCaptura: nid
    si yo#asoc#contiene: (RN#NombreResueltoDe: nid)
        devolver ObjetoAdHoc: {altura}, 0,
                              {índiceDeCaptura}, (yo#asoc#en: (RN#NombreResueltoDe: nid)),
                              {profundidad}, yo#profundidad
    sino
        variable dt
        fijar dt a yo#estadoSuperior#informaciónDeLaCaptura: nid
        devolver clonar dt con
            altura: dt#altura + 1
        finclonar
    finsi
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnUso: nid
    variable dt
    fijar dt a yo#informaciónDeLaCaptura: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, dt#altura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, dt#índiceDeCaptura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, dt#profundidad
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#profundidad
    si EsNulo: yo#estadoSuperior
        devolver 0
    sino
        devolver 1 + yo#estadoSuperior#profundidad
    finsi
finmetodo

[DOCUMENTA
@brief{Anota los identificadores del programa con su información de captura.}

Cada identificador es anotado con los metadatos @code{altura},
@code{profundidad} e @code{índiceDeCaptura} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}).

@code{altura} es el número de entornos que se debe "saltar".

@code{índiceDeCaptura} es el índice dentro del entorno seleccionado. Asume que
cada ámbito es compilado a un entorno en el IR.

@code{profundidad} es un número que indica la profundidad dentro del programa
en la que se declaró la variable
DOCUMENTA]
procedimiento EnumeraciónDeCapturas: ast, estado
    variable DECLARACIONES
    fijar DECLARACIONES a Arreglo#crearCon: AST#NodoVariable, AST#NodoFunción,
                                            AST#NodoFunciónAnónima, AST#NodoIdentificador,
                                            AST#NodoSi, AST#NodoMientras, AST#NodoPrograma

    Caminar: ast, funcion: nodo
        devolver Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoPrograma
            ParaCadaElemento: nodo#instrucciones, recur
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, estado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            ParaCadaElemento: nodo#nombres, &(estado#marcarÍndiceCapturaEnDeclaración)
            devolver NULO
        finsi
        si (EsInstancia: nodo, AST#NodoFunción) || (EsInstancia: nodo, AST#NodoFunciónAnónima)
            variable subestado
            si EsInstancia: nodo, AST#NodoFunción
                estado#marcarÍndiceCapturaEnDeclaración: nodo#nombre
            finsi
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#parámetros, &(subestado#marcarÍndiceCapturaEnDeclaración)
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            variable subestado
            %recur: nodo#condicional
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            variables subestadoSiVerdadero, subestadoSiFalso
            %recur: nodo#condicional
            fijar subestadoSiVerdadero a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siVerdadero, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestadoSiVerdadero
            finprocedimiento
            fijar subestadoSiFalso a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siFalso, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestadoSiFalso
            finprocedimiento
            necesitas subestadoSiVerdadero#profundidad = subestadoSiFalso#profundidad
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestadoSiFalso#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            estado#marcarÍndiceCapturaEnUso: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Anota los bindings locales de un ámbito.}

Agrega a cada nodo identificador un metadato @code{esLocal} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un @pd{Boole} indicando si el
identificador es "local" a su posición: es decir, si fue declarado en la
función en la que se encuentra.
DOCUMENTA]
procedimiento AnotarBindingsLocales: ast
    necesitas (EsInstancia: ast, AST#NodoFunción)
           || (EsInstancia: ast, AST#NodoFunciónAnónima)
           || (EsInstancia: ast, AST#NodoPrograma)
    variable bindings
    fijar bindings a BindingsLocalesDelBloque: ast
    Caminar: ast, funcion: nodo
        devolver (no Defun#SonElMismoObjeto: nodo, ast)
              && (   (EsInstancia: nodo, AST#NodoIdentificador)
                  || (EsInstancia: nodo, AST#NodoFunción)
                  || (EsInstancia: nodo, AST#NodoFunciónAnónima))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoIdentificador
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}, (bindings#contiene: (RN#NombreResueltoDe: nodo))
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunciónAnónima
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            nodo#nombre#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}, (bindings#contiene: (RN#NombreResueltoDe: nodo#nombre))
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento

procedimiento MarcaVariablesLocalesEnSubámbitos: ast
    Caminar': ast, procedimiento: nodo, K
        si (EsInstancia: nodo, AST#NodoFunción)
        || (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoPrograma)
            variables bindings, locales, localesReales
            fijar bindings a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}
            fijar locales a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
            fijar localesReales a Filtrar: (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelNodo'}),
                                           funcion: local
                                               devolver local#profundidad = (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad})
                                           finfuncion

            [ localesReales contiene las variables declaradas directamente en
              `nodo`, mientras que `locales` y `bindings` contienen las locales
              y bindings de `nodo` y todos sus subámbitos excepto
              funciones/métodos/procedimientos. ]

            variables bindingsDeEsteÁmbito, localesDeEsteÁmbito
            fijar bindingsDeEsteÁmbito a Conjunto#desdeArreglo: (Mapear: localesReales, (MétodoComoFunción: {binding}))
            fijar localesDeEsteÁmbito a Filtrar: locales, funcion: local
                devolver bindingsDeEsteÁmbito#contiene: local#binding
            finfuncion

            procedimiento marcarSubidentificadores: nodo
                Caminar: nodo, funcion: nodo
                    devolver (EsInstancia: nodo, AST#NodoIdentificador)
                          || (EsInstancia: nodo, AST#NodoFunción)
                          || (EsInstancia: nodo, AST#NodoPrograma)
                finfuncion, procedimiento: nodo, subrecur
                    si EsInstancia: nodo, AST#NodoFunción
                        nodo#nombre#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta}, (bindingsDeEsteÁmbito#contiene: (RN#NombreResueltoDe: nodo#nombre))
                        devolver MarcaVariablesLocalesEnSubámbitos: nodo
                    finsi
                    si EsInstancia: nodo, AST#NodoPrograma
                        devolver MarcaVariablesLocalesEnSubámbitos: nodo
                    finsi
                    si EsInstancia: nodo, AST#NodoIdentificador
                        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta}, (bindingsDeEsteÁmbito#contiene: (RN#NombreResueltoDe: nodo))
                    finsi
                finprocedimiento
            finprocedimiento

            devolver K#llamarConRecursión: nodo, &marcarSubidentificadores
        sino
            devolver %K: nodo
        finsi
    finprocedimiento
finprocedimiento

procedimiento MarcaVariablesQueEstánEnElEntorno: ast
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoIdentificador
    finfuncion, procedimiento: nodo, recur
        variables esLocal, esCapturada, esLocalDirecta
        fijar esCapturada a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        fijar esLocal a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
        fijar esLocalDirecta a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta}
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}, (esCapturada || (no esLocal) || (no esLocalDirecta))
    finprocedimiento
finprocedimiento

funcion EstáEnElEntorno: nid
    devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}
finfuncion


[ Fin de los minipases. Ahora comienza el backend "real": ]


[ Nombre código del backend. Véase también la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Tupla (IR) Bootstrap}

[ El IR:

  El IR esta compuesto de 3 "partes": las instrucciones, las declaraciones y
  las constantes. Se asume que el órden de las instrucciones importa pero el de
  las constantes y las declaraciones no.

  Las instrucciones consisten de un arreglo de "tuplas": cada tupla es como un
  arreglo de tamaño mayor a 1, donde el primer elemento es la instrucción u
  opcode y los demás elementos son los argumentos. Cada opcode requiere sus
  propios argumentos con tipos específicos.

  Las constantes son un diccionario de un CID ("constant-ID") a la constante
  dada. El IR solo puede representar constantes numéricas (como instancias de
  números) y textuales (como instancias de textos).

  Las declaraciones actualmente solo incluyen la declaración de función, la
  cual consiste del ID de la función, sus parámetros y las instrucciones de su
  cuerpo.

  Estas 3 partes están agrupadas en una estructura llamada `Compilado`. La
  operación más fundamental de un compilado es secuenciar (`A >> B`) pero
  también tienen otras.

Semanticas:

  El IR tiene un número ilimitado de registros o variables locales (o solo
  "locales") por cada marco de activación de cada función. También tiene una
  pila que es compartida entre marcos de activación: cada función debe tener
  cuidado de mantener la pila en un estado apropiado (las funciones no pueden
  leer los elementos de la pila que fueron agregados antes de entrar a
  esta). Finalmente, una última pila, la pila de ámbitos, es usada para
  compilar `si`-`finsi` y `mientras`-`finmientras`. A diferencia de la pila
  general, esta segunda pila no es compartida por los marcos de activación lo
  que significa que no es importante asegurarse de que esté en un estado válido
  al final de la función.

  Todo esto hace que el IR sea bastante fácil de usar: variables e
  instrucciones pueden usar directamente los registros mientras que las
  expresiones utilizan la pila para guardar los valores intermediarios. Nota
  que la pila no es completamente dinámica: siempre está vacía entre
  instrucciones. Esto es importante porque es posible que los pases posteriores
  del compilador "desapilen" el código eliminando la pila y convirtiendo todo
  el código a registros.

  Finalmente: exísten algunos opcodes para saltar tanto como incondicional como
  condicionalmente. Todos están intencionalmente hechos para que los únicos
  objetivos de un salto sean etiquetas. Por ejemplo, en vez de una instrucción
  "salta si es falso" `BR <etiqueta>` hay una "salta de acuerdo a una
  condición" `CHOOSE <siVerdadero>, <siFalso>`. Gracias a esto es posible
  convertir el IR a un grafo de bloques básicos y todos los bloques con bordes
  entrantes comenzarán con una etiqueta.

  Los tipos de objetos manejados por el IR son, en su mayoría, los mismos que
  los builtins de PseudoD: números, textos y booleanos. Además, 2 tipos
  adicionales (objetos y closures) son utilizados para implementar los
  demás. Tal como el intérprete, todos los objetos en la VM son "reales":
  puedes enviar mensajes a números o closures sin problemas.

  Las closures están implementadas como un puntero a una función y un
  entorno. Los objetos son como funciones pero su puntero a función apunta a la
  función que recibirá los mensajes y su entorno contiene los atributos del
  objeto.

  Un entorno consiste de un puntero a un entorno "superior" y una lista de
  registros almacenados. Los entornos son usados para implementar closures y
  objetos. Puedes crear un entorno con las instrucciones de "marco" (*frame
  instructions*, se llaman así porque siempre aparecen al principio de las
  funciones, "reificando" los marcos de activación). Para acceder a un valor en
  un entorno necesitas una altura (el número de entornos a "saltar" desde el
  actual) y un índice (el objeto dentro del entorno seleccionado a acceder).

  Cuando se llama a una closure, su entorno es pasado como primer argumento.

  Los registros especiales `ESUP` y `EACT` representan el entorno "superior" al
  actual y el entorno actual, respectivamente. `EACT` tiene que ser
  inicializado manualmente. `ESUP` es el entorno pasado a esta función
  (recuerda, el primer argumento es especial).

  Como durante la compilación cada ámbito pasa a ser un entorno, es necesario
  un sistema para prevenir que las variables `EACT` y `ESUP` se confundan (por
  ejemplo, si tienes un `si` dentro de un `mientras`, el `EACT` del mientras
  debe ser distínto del `EACT` del `si`). Para esto existe la pila de ámbitos:
  cada ámbito guarda sus entornos (`EACT`) en la pila de ámbitos.

Instrucciones:

  Los prefijos significan:

  1. `C`: Índice de constante de la lista de constantes.
  2. `N`: Constante numérica.
  3. `F`: Constante real.
  4. `L`: Índice de registro local.
  5. `E`: Entorno: un registro local o alguna de las variables especiales
     `EACT` o `ESUP`.
  6. `U`: Número positivo (mayor o igual a 0).
  7. `T`: Etiqueta.
  8. `P`: ID de un procedimiento.
  9. `?`: Combinado con `E` o `L` indica que el argumento puede ser el valor
     especial `NIL`.

  SUM    {a b -- c}
  SUB    {a b -- c}
  MUL    {a b -- c}
  DIV    {a b -- c}
    Operaciones aritméticas básicas. Operan en la pila.

  LT     {a b -- c}
  GT     {a b -- c}
  LE     {a b -- c}
  GE     {a b -- c}
  OPEQ   {a b -- c}
    Menor/mayor que, mayor/menor o igual a. Operan en la pila.

  POP    {a --}
    Saca e ignora el elemento en la cima de la pila.

  LCONST Cx    {-- a}
    Carga la constante con el índice `Cx` y la empuja en la pila.

  ICONST Na    {-- a}
  FCONST Fa    {-- a}
    Empuja una constante numérica.

  BCONST Na    {-- a}
    Empuja una constante booleana. Si `Na` es 1, empuja `VERDADERO`. Si es
    0 empuja `FALSO`.

  LOCAL Lx
    Declara un registro local. Solo puede estár al principio de una
    lista de instrucciones.

  PARAM Lx
    Declara un parámetro. `Lx` será el registro local que contenga al parámetro
    (`Lx` es declarado automáticamente, no es necesario declararlo de nuevo con
    `LOCAL`). Solo puede estar antes que `LOCAL` en un procedimiento.

  MKCLZ Ex, Px    {-- c}
  MK0CLZ Px    {-- c}
    Crea una closure mezclando un procedimiento (`Px`) y un entorno
    (`Ex`). `MK0CLZ` es como `MKCLZ` pero utiliza un entorno vacío.

  LSET Lx    {v --}
    Saca un elemento de la pila y lo asigna a la local `Lx`.

  LGET Lx    {-- v}
    Obtiene y empuja en la pila el valor de la local `Lx`.

  LSETC Ex, Ua, Ub    {v --}
    Saca un elemento de la pila y lo asigna a la variable dada del
    entorno. `Ex` es el entorno, `Ua` es la altura de la variable y `Ub` es el
    índice de la variable.

  LGETC Ex, Ua, Ub    {-- v}
    Obtiene la variable dada del entorno y empuja su valor en la pila. `Ex` es
    el entorno, `Ua` es la altura de la variable y `Ub` es el índice de la
    variable.

  ROT Ua
    Rota los primeros `Ua + 1` elementos en la cima de la pila. Por ejemplo si
    la pila tenía 4 elementos:

      <-----T
      A B C D

    (La flecha apunta a la base de la pila.)
    Entonces ejecutar `ROT 3` dejará la pila como:

      <-----T
      B C D A

    Esto es muy útil, por ejemplo, al compilar `obj#mensaje: 1, 2, 3`: el orden
    en el que compilan las partes de la expresión anterior es:

      <-------T
      obj 1 2 3

    Pero necesitamos `1 2 3 obj` para poder invocar el mensaje con `MSG`.

    (Puedes imaginar a este opcode como un "prepara para llamar a una
    función/método con `Ua` argumentos".)

  MSG Cx, Ua, Ub
    Saca un elemento, el objeto que recibirá el mensaje. Luego le envía a este
    el mensaje indicado por la constante `Cx`. Este mensaje es llamado con `Ua`
    argumentos y se espera que devuelva `Ub` resultados.

  DYNCALL Ua, Ub
    Envía el mensaje `llamar` al objeto en la cima de la pila. Similar a `MSG`.

  RETN Ua
    Devuelve `Ua` objetos (que deben estar en la pila) del procedimiento
    actual.

  OPNFRM Ex, ?Ey, Ua    {--}
    Inicializa un entorno. El nuevo entorno es guardado en `Ex`. Si `Ey` es
    especificado será el entorno superior. `Ua` es el tamaño del entorno, es
    decir, el número de variables que contiene.

  ENEW Ex, Ua    {--}
    Inicializa una variable dentro del entorno. La variable en el índice `Ua`
    del entorno `Ex` será fijada a `NULO`.

  EINIT Ex, Ua, Ly    {--}
    Inicializa una variable dentro del entorno. La variable en el índice `Ua`
    del entorno `Ex` será fijada al valor del registro `Ly`.

  CLSFRM Ex    {--}
    "Cierra" un entorno. Luego de cerrarlo, no puedes usar `EINIT` o `ENEW` con
    `Ex`. En cambio, cualquier cambio al entorno tendrá que pasar por `LSETC`.

  NAME Tx
    Declara `Tx` como una etiqueta. `Tx` debe ser único en el procedimiento
    actual.

  CHOOSE Tx, Ty    {x --}
    Saca un elemento de la pila, si es verdadero salta a `Tx`, si no salta a
    `Ty`.

  JMP Tx    {--}
    Salta incondicionalmente a `Tx`.

  MTRUE    {x --}
    Saca un objeto de la pila y falla con un error si no es verdadero. Este
    opcode implementa la instrucción `necesitas`.

  CMPEQ    {a b -- c}
  CMPNEQ    {a b -- c}
    Compara si dos objetos de la pila son iguales/diferentes, empujando
    verdadero o falso.

  NOT    {a -- b}
    Niega el boole en la cima de la pila.

  PRN    {a --}
    Escribe el texto en la cima de la pila.

  NL    {--}
    Escribe el fin de línea.

  TODO: Documenta como SPUSH debe estar seguido de OPNFRM.

  SPUSH EACT, ESUP
  SPOP EACT, ESUP
    Empuja/saca y reorganiza `EACT`/`ESUP` en la pila de ámbitos. Luego de
    `SPUSH EACT, ESUP`, `EACT` estará en la pila de ámbitos y `EACT`/`ESUP`
    serán "rotados", de forma que `EACT` será el entorno superior de `EACT` y
    `ESUP` será el entorno superior de `ESUP`.

    `SPOP EACT, ESUP` revierte esto, sacando y rotando de nuevo las variables.

Ejemplo:

  Equivalente (más o menos) en PseudoD:

    variable X
    funcion Y: v
        devolver (v + 4) * X
    finfuncion
    fijar X a 5
    escribir Y: 3
    nl

  En bytecode:

    Instrucciones:
      LOCAL 3
      LOCAL 4
      OPNFRM EACT, NIL, 1
      EINIT EACT, 0, 3
      CLSFRM EACT
      MKCLZ EACT, 1
      LSET 4
      ICONST 5
      LSETC EACT, 0, 0
      LGET 4
      ICONST 3
      ROT 1
      DYNCALL 1, 1
      PRN
      NL

    Procedimientos:
      PROC 1
        PARAM ESUP
        PARAM 2
        OPNFRM EACT, ESUP, 0
        CLSFRM EACT
        LGET 2
        ICONST 4
        SUM
        LGETC EACT, 1, 0
        MUL
        RETN 1
      ENDPROC

    Constantes:
      (nada)

]

[DOCUMENTA
@brief{Variable local que contiene al entorno superior.}

Es la constante @code{ESUP} del bytecode.
DOCUMENTA]
funcion LocalDelEntornoSuperior
    devolver {ESUP}
finfuncion

[DOCUMENTA
@brief{Variable local que contiene al entorno actual.}

Es la constante @code{EACT} del bytecode.
DOCUMENTA]
funcion LocalDelEntornoActual
    devolver {EACT}
finfuncion


[DOCUMENTA
@brief{Una tupla de opcode y los argumentos.}

La tupla tiene más de un elemento: el primero siempre es el opcode, mientras
que los demás son los argumentos.
DOCUMENTA]
clase Tupla
    [DOCUMENTA
    @brief{El opcode de esta tupla.}
    DOCUMENTA]
    atributo opcode

    [DOCUMENTA
    @brief{Los argumentos de esta tupla.}

    Es un arreglo.
    DOCUMENTA]
    atributo argumentos

    [DOCUMENTA
    @brief{Crea una nueva tupla.}
    DOCUMENTA]
    metodo estatico crear: op, ...args

    [DOCUMENTA
    @brief{Determina si es o no un opcode específico.}

    Devuelve @pd{VERDADERO} o @pd{FALSO} dependiendo de si el opcode de esta
    tupla es @pd{op}.
    DOCUMENTA]
    metodo es: op

    [DOCUMENTA
    @brief{Obtiene un argumento de la tupla.}

    Devuelve el argumento número @pd{n} de esta tupla, contando desde 0.
    DOCUMENTA]
    metodo en: n

    [DOCUMENTA
    @brief{Devuelve una representación textual de la tupla.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico Tupla#crear: op, ...args
    variable inst
    fijar inst a yo#_crear
    fijar inst#opcode a op
    fijar inst#argumentos a args
    devolver inst
finmetodo

metodo Tupla#es: op
    devolver yo#opcode = op
finmetodo

metodo Tupla#en: n
    devolver yo#argumentos#en: n
finmetodo

metodo Tupla#comoTexto
    devolver {(Tupla ~t ~t)}#formatear:
        yo#opcode#nombre,
        (Unir:
         (Mapear: yo#argumentos, funcion: x
              devolver x#comoTexto
          finfuncion),
         {, })
finmetodo

[DOCUMENTA
@brief{Crea una enumeración con valores incrementales.}

Como @pd{Enum} pero los valores de las enumeraciones no son su nombre si no un
número que se va incrementando de 1 en 1. Por ejemplo:

@ejemplo|{
variable X
fijar X a EnumConValoresIncrementales: {X},
    {A}, {B}, {C}, {D}
necesitas X#A#valor = 0
necesitas X#B#valor = 1
necesitas X#C#valor = 2
necesitas X#D#valor = 3
}|
DOCUMENTA]
funcion EnumConValoresIncrementales: nombre, ...valores
    variable pares
    fijar pares a Diccionario#vacío
    ParaCadaElementoConÍndice: valores, procedimiento: valor, i
        pares#fijarEn: valor, i
    finprocedimiento
    devolver EnumConValores: nombre, ...(Aplanar: pares#comoArreglo)
finfuncion

[DOCUMENTA
@brief{Todos los opcodes del bytecode.}

Esta enumeración contiene todos los opcodes del bytecode. El valor de cada
enumerado es el "código" del opcode.

Como una conveniencia, los enumerados también tienen un método @code{bytecode}
como un alias de @code{valor} (por ejemplo, @pd{Opcode#SUM#bytecode} es igual
que @pd{Opcode#SUM#valor}).
DOCUMENTA]
variable Opcode
fijar Opcode a EnumConValoresIncrementales: {Opcode},
    {SUM},     [ SUM ]
    {SUB},     [ SUB ]
    {MUL},     [ MUL ]
    {DIV},     [ DIV ]
    {LT},      [ LT ]
    {GT},      [ GT ]
    {LE},      [ LE ]
    {GE},      [ GE ]
    {OPEQ},    [ OPEQ ]
    {POP},     [ POP ]
    {LCONST},  [ LCONST Cx ]
    {ICONST},  [ ICONST Na ]
    {FCONST},  [ FCONST Fa ]
    {LOCAL},   [ LOCAL Lx  (Solo al principio de un procedimiento) ]
    {PARAM},   [ PARAM Lx  (Solo antes que LOCAL en un procedimiento) ]
    {MKCLZ},   [ MKCLZ Ex, Px ]
    {MK0CLZ},  [ MK0CLZ Px ]
    {LSET},    [ LSET Lx ]
    {LGET},    [ LGET Lx ]
    {LSETC},   [ LSETC Ex, Ua, Ub ]
    {LGETC},   [ LGETC Ex, Ua, Ub ]
    {ROT},     [ ROT Ua ]
    {DYNCALL}, [ DYNCALL Ua, Ub ]
    {RETN},    [ RETN Ua ]
    {ENEW},    [ ENEW Lx, Ua ]
    {EINIT},   [ EINIT Lx, Ua, Ly ]
    {OPNFRM},  [ OPNFRM Ex, ?Ey, Ua ]
    {CLSFRM},  [ CLSFRM Ex ]
    {CHOOSE},  [ CHOOSE Tx, Ty ]
    {JMP},     [ JMP Tx ]
    {NAME},    [ NAME Tx ]
    {MTRUE},   [ MTRUE ]
    {CMPEQ},   [ CMPEQ ]
    {CMPNEQ},  [ CMPNEQ ]
    {NOT},     [ NOT ]
    {MSG},     [ MSG Cx, Ua, Ub ]
    {PRN},     [ PRN ]
    {NL},      [ NL ]
    {SPUSH},   [ SPUSH EACT ]
    {SPOP}     [ SPOP EACT ]

metodo Opcode#bytecode
    devolver yo#valor
finmetodo

[ El objeto `OP` es un pequeño DSL para construir tuplas. `OP#SUM: 1, 2` es lo
  mismo que `Tupla#crear: Opcode#SUM, 1, 2` ]

variable OP
si VERDADERO
    clase I
        metodo metodoNoEncontrado: mensaje, argumentos
    finclase

    metodo I#metodoNoEncontrado: mensaje, argumentos
        devolver Tupla#crear: (EnviarMensaje: Opcode, mensaje), ...argumentos
    finmetodo

    fijar OP a I#crear
finsi

[DOCUMENTA
@brief{Declaración de función o procedimiento dentro del bytecode.}
DOCUMENTA]
clase DeclrFunción
    [DOCUMENTA
    @brief{Nombre de la función.}

    Debe ser un número único en el programa.
    DOCUMENTA]
    atributo nombre

    [DOCUMENTA
    @brief{Los parámetros de la función.}

    Un arreglo de números: cada número es el ID de un registro local que será
    el parámetro en la función. Opcionalmente @pd{LocalDelEntornoSuperior}
    puede aparecer como primer elemento.
    DOCUMENTA]
    atributo parámetros

    [DOCUMENTA
    @brief{Cuerpo de la función.}

    Un arreglo de tuplas.
    DOCUMENTA]
    atributo cuerpo

    [DOCUMENTA
    @brief{Crea una nueva declaración de función.}
    DOCUMENTA]
    metodo estatico crear: nombre, parámetros, cuerpo

    [DOCUMENTA
    @brief{Devuelve una representación textual de la declaración.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico DeclrFunción#crear: nombre, parámetros, cuerpo
    devolver clonar yo#_crear con
        nombre: nombre
        parámetros: parámetros
        cuerpo: cuerpo
    finclonar
finmetodo

metodo DeclrFunción#comoTexto
    devolver {(DeclrFunción ~t con ~t es ~t)}#formatear: yo#nombre, yo#parámetros, yo#cuerpo
finmetodo

[DOCUMENTA
@brief{Una constante en el IR.}

Representa un mapeo de un ID de constante a la constante.

Aunque nada te lo prohibe, no deberías usar constantes para representar números
"pequeños" (menores a 2^32). Para estos usa el opcode @code{ICONST}.
DOCUMENTA]
clase Constante
    [DOCUMENTA
    @brief{Id de la constante.}
    DOCUMENTA]
    atributo id

    [DOCUMENTA
    @brief{Valor de la constante.}

    Solo puede ser un número o un texto.
    DOCUMENTA]
    atributo valor

    [DOCUMENTA
    @brief{Crea una nueva constante y la devuelve.}
    DOCUMENTA]
    metodo estatico crear: id, valor

    [DOCUMENTA
    @brief{Devuelve una representación textual del mapeo de la constante.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico Constante#crear: id, valor
    devolver clonar yo#_crear con
        id: id
        valor: valor
    finclonar
finmetodo

metodo Constante#comoTexto
    devolver {(Constante#crear: ~t, ~t)}#formatear: yo#id, yo#valor
finmetodo


[DOCUMENTA
@brief{Un fragmento de compilación.}

Un compilado representa un fragmento de la compilación. Contiene un arreglo de
instrucciones, una secuencia de declaraciones y una secuencia de constantes. El
orden de las declaraciones y constantes no importa, pero el de las
instrucciones sí.
DOCUMENTA]
clase Compilado
    [DOCUMENTA
    @brief{Arreglo de tuplas, que son las instrucciones de este compilado.}
    DOCUMENTA]
    atributo instrucciones

    [DOCUMENTA
    @brief{Arreglo de declaraciones.}

    Actualmente la única declaración válida es @pd{DeclrFunción}.
    DOCUMENTA]
    atributo declaraciones

    [DOCUMENTA
    @brief{Constantes de este compilado.}

    Arreglo de @pd{Constante}.
    DOCUMENTA]
    atributo constantes

    [DOCUMENTA
    @brief{Crea un compilado con los datos dados.}
    DOCUMENTA]
    metodo estatico crear: instrucciones, declaraciones, constantes

    [DOCUMENTA
    @brief{Crea un compilado sin constantes ni declaraciones.}
    DOCUMENTA]
    metodo estatico deInstrucciónes: instrucciones

    [DOCUMENTA
    @brief{Crea un compilado sin instrucciones ni constantes.}
    DOCUMENTA]
    metodo estatico deDeclaraciones: declaraciones

    [DOCUMENTA
    @brief{Crea un compilado sin instrucciones ni declaraciones.}
    DOCUMENTA]
    metodo estatico deConstantes: constantes

    [DOCUMENTA
    @brief{Secuencia dos compilados.}

    Mezcla las declaraciones y constantes de los compilados @pd{yo} y
    @pd{otro}. Además, las instrucciones de @pd{yo} son concatenadas
    @bold{antes} que las de @pd{otro}.

    El resultado de esto es un nuevo compilado cuyas instrucciones son primero
    las de @pd{yo} y después las de @pd{otro}, con todo lo demás en un orden no
    especificado.
    DOCUMENTA]
    metodo \operador_>>\: otro

    [DOCUMENTA
    @brief{Devuelve el valor de la constante con ID @pd{idDeConstante}.}
    DOCUMENTA]
    metodo valorDeConstante: idDeConstante

    [DOCUMENTA
    @brief{Devuelve una representación textual del compilado.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico Compilado#crear: i, d, c
    devolver clonar yo#_crear con
        instrucciones: i
        declaraciones: d
        constantes: c
    finclonar
finmetodo

metodo estatico Compilado#deInstrucciónes: i
    devolver Compilado#crear: i, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo estatico Compilado#deDeclaraciones: d
    devolver Compilado#crear: Arreglo#vacio, d, Arreglo#vacio
finmetodo

metodo estatico Compilado#deConstantes: c
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, c
finmetodo

metodo estatico Compilado#vacío
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo Compilado#operador_>>: otro
    devolver Compilado#crear:
        (Concatenar: yo#instrucciones, otro#instrucciones),
        (Concatenar: yo#declaraciones, otro#declaraciones),
        (Concatenar: yo#constantes, otro#constantes)
finmetodo

metodo Compilado#valorDeConstante: idDeConstante
    variable encontrados
    fijar encontrados a Filtrar: yo#constantes, funcion: const
        devolver const#id = idDeConstante
    finfuncion
    necesitas encontrados#longitud = 1
    devolver (encontrados#en: 0)#valor
finmetodo

metodo Compilado#comoTexto
    devolver {(Compilado ds = ~t, is = ~t, cs = ~t)}#formatear: yo#declaraciones, yo#instrucciones, yo#constantes
finmetodo


[DOCUMENTA
@brief{Escribe una versión "descompilada" de un compilado.}

Escribe todos los datos de un compilado de forma "bonita", como si fuese un
"assembly listing" (de allí el nombre "listado").
DOCUMENTA]
procedimiento Listado: compilado
    Escribir: {===== Constants:}
    ParaCadaElementoConÍndice: compilado#constantes, procedimiento: const, i
        Escribir: ({#~t}#formatear: i), {}, ({~t => ~t}#formatear: const#id, const#valor)
    finprocedimiento
    Escribir: {===== Code:}
    ParaCadaElementoConÍndice: compilado#instrucciones, procedimiento: tupla, i
        Escribir: ({#~t}#formatear: i), {}, ({[~t] 	~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
    finprocedimiento
    Escribir: {===== Declr:}
    ParaCadaElementoConÍndice: compilado#declaraciones, procedimiento: declr, i
        necesitas EsInstancia: declr, DeclrFunción
        Escribir: ({#~t}#formatear: i), {proc}, declr#nombre
        ParaCadaElementoConÍndice: declr#parámetros, procedimiento: p, j
            Escribir: {}, {}, ({#~t}#formatear: j), p
        finprocedimiento
        ParaCadaElementoConÍndice: declr#cuerpo, procedimiento: tupla, i
            Escribir: {}, ({#~t}#formatear: i), {}, ({[~t] 	~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
        finprocedimiento
        Escribir: {}, {end}
    finprocedimiento
finprocedimiento


[DOCUMENTA
@brief{Secuencia todos los compilados.}

@pd{partes} debe ser un arreglo de compilados que serán secuenciados con
@code{>>} en orden. Devuelve el resultado de secuenciarlos.
DOCUMENTA]
funcion UnirCompilados: partes
    devolver Reducir: Compilado#vacío, (OperadorBinario: {>>}), partes
finfuncion


[DOCUMENTA
@brief{Obtiene los nombres definídos sin parámetros de una
función/método/procedimiento.}

Devuelve el valor del metadato @code{nombresDefinídosSinParámetros} (con llave
@pd{RN#LLAVE_RESOLUCIÓN_DE_NOMBRES}).
DOCUMENTA]
funcion NombresDefinídosSinParámetros: ast
    devolver ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSinParámetros}
finfuncion

[DOCUMENTA
@brief{Obtiene los nombres resueltos de los parámetros de un
método/función/procedimiento.}

@pd{ast} debe ser un @pd{AST#NodoFunción}, @pd{AST#NodoFunciónAnónima},
@pd{AST#NodoMétodo} o @pd{AST#NodoDefineMétodoEnClase}. Devuelve un arreglo con
los nombres resueltos de los parámetros (en orden).
DOCUMENTA]
funcion NombresDeLosParámetros: ast
    devolver Mapear: ast#parámetros, &(RN#NombreResueltoDe)
finfuncion


[DOCUMENTA
@brief{Obtiene las locales del procedimiento.}

A pesar de lo que su nombre indica, solo funciona con nodos con el metadato
@code{localesDelProcedimiento} (funciones, métodos, procedimientos y
@pd{AST#NodoPrograma}).
DOCUMENTA]
funcion LocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
finfuncion

[DOCUMENTA
@brief{Obtiene los bindings locales del procedimiento.}

Solo funciona con los mismos nodos que @pd{LocalesDelBloque}.
DOCUMENTA]
funcion BindingsLocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}
finfuncion

variable ContadorDeEtiquetas
fijar ContadorDeEtiquetas a 0
[DOCUMENTA
@brief{Devuelve una nueva etiqueta.}

Devuelve un número único que sirve como etiqueta para las instrucciones de
control de flujo (@code{JMP} y @code{CHOOSE}).
DOCUMENTA]
procedimiento GenerarEtiqueta
    fijar ContadorDeEtiquetas a ContadorDeEtiquetas + 1
    devolver ContadorDeEtiquetas
finprocedimiento

variable ContadorDeConstantes
fijar ContadorDeConstantes a 0
[DOCUMENTA
@brief{Devuelve un nuevo ID de constante.}

Devuelve un número único que sirve como ID de constante.
DOCUMENTA]
procedimiento GenerarIdDeConstante
    fijar ContadorDeConstantes a ContadorDeConstantes + 1
    devolver ContadorDeConstantes
finprocedimiento

variable ContadorDeProcedimientos
fijar ContadorDeProcedimientos a 0
procedimiento GenerarIdDeProcedimiento
    fijar ContadorDeProcedimientos a ContadorDeProcedimientos + 1
    devolver ContadorDeProcedimientos
finprocedimiento

[ TODO: Renombra todas las funciones de compilación de "WASM" a "Tuplas". ]

[DOCUMENTA
@brief{Compila un arreglo de instrucciones a un compilado.}

@pd{instrucciones} debe ser un arreglo de @pd{AST#NodoInstrucción}. Esta
función automaticamente se encarga de dejar la pila en un estado apropiado
cuando se encuentra a una expresión en una posición de instrucción.
DOCUMENTA]
funcion CompilarBloqueAWasm: instrucciones
    variable res
    fijar res a Compilado#vacío
    ParaCadaElemento: instrucciones, procedimiento: instr
        fijar res a res >> (CompilarAWasm: instr)
        si EsInstancia: instr, AST#NodoExpresion
            fijar res a res >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#POP))
        finsi
    finprocedimiento
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila un identificador.}

@pd{ast} debe ser el @pd{AST#NodoIdentificador} del bloque.

Devuelve un compilado que obtiene la variable @pd{ast} y la empuja en la pila.
DOCUMENTA]
funcion CompilarIdentificador: ast
    variables altura, índiceDeCaptura, res, binding
    fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    fijar binding a RN#NombreResueltoDe: ast
    si EstáEnElEntorno: ast
        fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGETC: LocalDelEntornoActual, altura, índiceDeCaptura))
    sino
        fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGET: binding))
    finsi
    devolver res
finfuncion

funcion CompilarFijarIdentificador: ast
    variables altura, índiceDeCaptura, op, binding
    fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    fijar binding a RN#NombreResueltoDe: ast
    si EstáEnElEntorno: ast
        fijar op a OP#LSETC: LocalDelEntornoActual, altura, índiceDeCaptura
    sino
        fijar op a OP#LSET: binding
    finsi
    devolver Compilado#deInstrucciónes: (Arreglo#crearCon: op)
finfuncion

[DOCUMENTA
@brief{Compila las declaraciones de las locales de un procedimiento.}

Devuelve un arreglo con todas las declaraciones @code{LOCAL} necesarias.

@params(
@defparam(locales){Arreglo de las variables locales (generado con
@pd{EnumeraciónDeLocalesDeProcedimiento}) del bloque.}

@defparam(parámetros){Los parámetros del método, función o procedimiento como
un arreglo de bindings. Si se esta compilando un bloque que no es uno de estos,
@pd{parámetros} debería ser un arreglo vacío. Este parámetro es necesario
porque los parámetros son locales pero no deberían estar declarados con
@code{LOCAL} si no con @code{PARAM}.}
)
DOCUMENTA]
funcion CompilarLocales: locales, parámetros
    Escribir: {-=-}
    ParaCadaElemento: locales, procedimiento: local
        si EstáEnElEntorno: local#nodo
            Escribir: {Está en el entorno:}, local
        finsi
    finprocedimiento
    Escribir: {---}
    funcion índiceDeCaptura: nodo
        devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    finfuncion
    variable índices
    fijar índices a (Mapear: parámetros, &índiceDeCaptura)
    devolver
        Mapear:
            (Únicos:
                (Mapear: (Filtrar: locales,
                                   funcion: meta
                                       devolver (no EstáEnElEntorno: meta#nodo) && (no Contiene: índices, meta#índiceDeCaptura)
                                   finfuncion),
                         funcion: local
                             devolver local#binding
                         finfuncion)),
            funcion: registro
                devolver OP#LOCAL: registro
            finfuncion
finfuncion

[DOCUMENTA
@brief{Mapea un arreglo, manteniendo solo los valores únicos de una llave
dada.}

Mapea cada elemento de @pd{arr} con @pd{func}, pero solo mantiene elementos
para los que @pd{unicos} (una función de la forma @pd{%unicos: elemento})
devuelva un valor único. Por ejemplo:

@ejemplo|{
utilizar bepd/x/adhoc (ObjetoAdHoc)

funcion Usuario: nombre, id
    devolver ObjetoAdHoc: {nombre}, nombre, {id}, id
finfuncion

variable A
fijar A a Arreglo#crearCon:
    (Usuario: {Miguel}, 1),
    (Usuario: {María}, 2),
    (Usuario: {Miguel (otra cuenta)}, 1)
necesitas (MapearÚnicos: A,
                         funcion: usuario
                             devolver usuario#id
                         finfuncion,
                         funcion: usuario
                             devolver usuario#nombre
                         finfuncion)
          =
          (Arreglo#crearCon: {Miguel}, {María})
}|

DOCUMENTA]
funcion MapearÚnicos: arr, unicos, func
    variables res, llaves
    fijar res a Arreglo#vacio
    fijar llaves a Conjunto#vacío
    ParaCadaElemento: arr, procedimiento: el
        variable llave
        fijar llave a %unicos: el
        si no (llaves#contiene: llave)
            fijar llaves a llaves#unión: (Conjunto#conValores: llave)
            res#agregarAlFinal: (%func: el)
        finsi
    finprocedimiento
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila las instrucciones @code{OPNFRM}...@code{CLSFRM} de un bloque.}

Devuelve un arreglo de instrucciones que crea e inicializa el entorno del
bloque actual, asignándolo a @code{EACT} apropiadamente.

@params(
@defparam(capturas){Un arreglo con las variables locales (producidas por
@pd{EnumeraciónDeLocalesDeProcedimiento}) que son capturadas (su atributo
@code{#esCapturado} debe ser verdadero). Puedes obtener este arreglo con
@pd{VariablesLocalesCapturadas}.}

@defparam(exísteMarcoSuperior){@pd{Boole} que indica si exíste
@code{ESUP}. Determina si el entorno tendrá marco superior.}

@defparam(profundidad){Profundidad en el programa en la que el ámbito se
encuentra.}
)
DOCUMENTA]
funcion CompilarEntornoDelÁmbito: parámetros, localesEnElEntorno, localesInmediatas, exísteMarcoSuperior, profundidad
    funcion índiceDeCaptura: nid
        devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    finfuncion

    variables ops, máximoÍndiceDeLocalEnElEntorno, localesSiSonParámetros, nrsParámetros
    fijar ops a Arreglo#vacio
    fijar máximoÍndiceDeLocalEnElEntorno a Reducir: -1, &Max, (Mapear: (Filtrar: localesInmediatas, &EstáEnElEntorno), &índiceDeCaptura)
    [ máximoÍndiceDeLocalEnElEntorno es el máximo ind. de los locales
      capturados, o -1 si no hay ninguno. De esta forma,
      máximoÍndiceDeLocalCapturado + 1 es el tamaño mínimo necesario para el
      marco de activación ("marco de llamada" o "call-frame") ]
    ops#agregarAlFinal: (OP#OPNFRM: LocalDelEntornoActual, (exísteMarcoSuperior#escojer: LocalDelEntornoSuperior, {NIL}), (máximoÍndiceDeLocalEnElEntorno + 1))
    fijar nrsParámetros a Mapear: parámetros, &(RN#NombreResueltoDe)
    fijar localesSiSonParámetros a SepararArreglo: localesInmediatas, funcion: local
        devolver Contiene: nrsParámetros, (RN#NombreResueltoDe: local)
    finfuncion
    ops#agregarAlFinal: (Mapear: (Filtrar: localesSiSonParámetros#parteVerdadera, &EstáEnElEntorno), funcion: local
        devolver OP#EINIT: LocalDelEntornoActual, (índiceDeCaptura: local), (RN#NombreResueltoDe: local)
    finfuncion)
    ops#agregarAlFinal: (Mapear: (Filtrar: localesSiSonParámetros#parteFalsa, &EstáEnElEntorno), funcion: local
        devolver OP#ENEW: LocalDelEntornoActual, (índiceDeCaptura: local)
    finfuncion)
    ops#agregarAlFinal: (OP#CLSFRM: LocalDelEntornoActual)
    devolver ops
finfuncion

[DOCUMENTA
@brief{Filtra un arreglo de locales para obtener las capturas de un bloque.}

Devuelve un arreglo con las variables locales capturadas.
DOCUMENTA]
funcion VariablesLocalesCapturadas: locales
    devolver Únicos: (Filtrar: locales, (MétodoComoFunción: {esCapturado}))
finfuncion

funcion VariablesEnElEntorno: locales
    devolver Únicos: (Filtrar: locales, funcion: local
        devolver local#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}
    finfuncion)
finfuncion

[DOCUMENTA
@brief{Compila los locales y el entorno de un bloque.}

Llama a @pd{CompilarLocales} y @pd{CompilarEntornoDelÁmbito}, acumulando sus
resultados. Devuelve un arreglo de instrucciones que sirve como "inicio" o
"preludio" de un bloque.
DOCUMENTA]
funcion CompilarLocalesYClosure: locales, localesEnElEntorno, localesInmediatas, parámetros, exísteMarcoSuperior, profundidad
    devolver Concatenar:
        (CompilarLocales: locales, parámetros),
        (CompilarEntornoDelÁmbito: parámetros, localesEnElEntorno, localesInmediatas, exísteMarcoSuperior, profundidad)
finfuncion

funcion Inspeccionar: A, B
    Escribir: A, B
    devolver B
finfuncion

[DOCUMENTA
@brief{Compila una instrucción o expresión a un compilado.}

Devuelve un @pd{Compilado} con el resultado de compilar @pd{ast}. Si @pd{ast}
es un @pd{AST#NodoExpresion} entonces el compilado dejará en la pila el
resultado de la expresión. Si es un @pd{AST#NodoInstrucción} entonces no dejará
valores en la pila.
DOCUMENTA]
funcion CompilarAWasm: ast
    funcion Instrucciones: ...Is
        devolver Compilado#deInstrucciónes: Is
    finfuncion

    si EsInstancia: ast, AST#NodoPrograma
        variables locales, localesEnElEntorno, profundidad, localesInmediatas
        fijar locales a LocalesDelBloque: ast
        fijar localesEnElEntorno a VariablesEnElEntorno: locales
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar localesInmediatas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}
        devolver (Compilado#deInstrucciónes: (Aplanar: (CompilarLocalesYClosure: locales, localesEnElEntorno, localesInmediatas, Arreglo#vacio, FALSO, profundidad)))
              >> (CompilarBloqueAWasm: ast#instrucciones)
    finsi
    si EsInstancia: ast, AST#NodoNumeroLiteral
        devolver Instrucciones: (OP#ICONST: ast#valor)
    finsi
    si EsInstancia: ast, AST#NodoTextoLiteral
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (Instrucciones: (OP#LCONST: cid))
              >> (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, ast#valor)))
    finsi
    si EsInstancia: ast, AST#NodoOperador
        variables lhs, rhs
        fijar lhs a CompilarAWasm: ast#lhs
        fijar rhs a CompilarAWasm: ast#rhs
        si ast#op#op = {+}
            devolver lhs >> rhs >> (Instrucciones: OP#SUM)
        finsi
        si ast#op#op = {-}
            devolver lhs >> rhs >> (Instrucciones: OP#SUB)
        finsi
        si ast#op#op = {*}
            devolver lhs >> rhs >> (Instrucciones: OP#MUL)
        finsi
        si ast#op#op = {/}
            devolver lhs >> rhs >> (Instrucciones: OP#DIV)
        finsi
        si ast#op#op = {=}
            devolver lhs >> rhs >> (Instrucciones: OP#OPEQ)
        finsi
        si ast#op#op = {<}
            devolver lhs >> rhs >> (Instrucciones: OP#LT)
        finsi
        si ast#op#op = {=<}
            devolver lhs >> rhs >> (Instrucciones: OP#LE)
        finsi
        si ast#op#op = {>}
            devolver lhs >> rhs >> (Instrucciones: OP#GT)
        finsi
        si ast#op#op = {>=}
            devolver lhs >> rhs >> (Instrucciones: OP#GE)
        finsi
        variables cid, optxt
        fijar cid a GenerarIdDeConstante
        fijar optxt a {operador_}#concatenar: ast#op#op
        devolver (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, optxt)))
              >> lhs >> rhs
              >> (Instrucciones: (OP#ROT: 1),
                                 (OP#MSG: cid, 2, 1))
    finsi
    si EsInstancia: ast, AST#NodoIdentificador
        variable res
        fijar res a CompilarIdentificador: ast
        si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
            fijar res a res >> (Instrucciones: (OP#DYNCALL: 0, 1))
        finsi
        devolver res
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        si ast#mensajes#longitud = 0
            devolver CompilarIdentificador: ast#base
        sino
            NoImplementado
        finsi
    finsi
    si EsInstancia: ast, AST#NodoEnviarMensaje
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (CompilarAWasm: ast#objeto)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#MSG: cid, ast#argumentos#longitud, 1))
              >> (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, ast#mensaje)))
    finsi
    si EsInstancia: ast, AST#NodoLlamarProcedimiento
        devolver (CompilarIdentificador: ast#proc)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#DYNCALL: ast#argumentos#longitud, 1))
    finsi
    si EsInstancia: ast, AST#NodoAutoejecutar
        devolver (CompilarAWasm: ast#expr)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#DYNCALL: ast#argumentos#longitud, 1))
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        necesitas ast#mensajes#longitud = 0
        devolver CompilarIdentificador: ast
    finsi
    si EsInstancia: ast, AST#NodoVariable
        devolver Compilado#vacío
    finsi
    si EsInstancia: ast, AST#NodoFijar
        devolver (CompilarAWasm: ast#valor) >> (CompilarFijarIdentificador: ast#objetivo)
    finsi
    si EsInstancia: ast, AST#NodoSi
        variables etiqSi, etiqSino, etiqFinsi, localesEnElEntornoSiVerdadero, localesEnElEntornoSiFalso, localesSiVerdadero, localesSiFalso, localesInmediatasSiVerdadero, localesInmediatasSiFalso, profundidad
        fijar etiqSi a GenerarEtiqueta
        fijar etiqSino a GenerarEtiqueta
        fijar etiqFinsi a GenerarEtiqueta

        fijar localesSiVerdadero a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiVerdadero}
        fijar localesEnElEntornoSiVerdadero a VariablesEnElEntorno: localesSiVerdadero
        fijar localesSiFalso a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiFalso}
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar localesInmediatasSiVerdadero a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiVerdadero}
        fijar localesInmediatasSiFalso a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiFalso}
        fijar localesEnElEntornoSiFalso a VariablesEnElEntorno: localesSiFalso

        devolver (CompilarAWasm: ast#condicional)
              >> (Instrucciones: (OP#CHOOSE: etiqSi, etiqSino),
                                 (OP#NAME: etiqSi),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntornoSiVerdadero, localesInmediatasSiVerdadero, VERDADERO, profundidad)))
              >> (CompilarBloqueAWasm: ast#siVerdadero)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqFinsi),
                                 (OP#NAME: etiqSino),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntornoSiFalso, localesInmediatasSiFalso, VERDADERO, profundidad)))
              >> (CompilarBloqueAWasm: ast#siFalso)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#NAME: etiqFinsi))
    finsi
    si EsInstancia: ast, AST#NodoMientras
        variables etiqInicio, etiqCont, etiqFinmientras, locales, localesEnElEntorno, localesInmediatas, nombresLibres, profundidad
        fijar etiqInicio a GenerarEtiqueta
        fijar etiqCont a GenerarEtiqueta
        fijar etiqFinmientras a GenerarEtiqueta

        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar locales a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelNodo}
        fijar localesInmediatas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}
        fijar localesEnElEntorno a VariablesEnElEntorno: locales

        devolver (Instrucciones: (OP#NAME: etiqInicio))
              >> (CompilarAWasm: ast#condicional)
              >> (Instrucciones: (OP#CHOOSE: etiqCont, etiqFinmientras),
                                 (OP#NAME: etiqCont),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntorno, localesInmediatas, VERDADERO, profundidad)))
              >> (CompilarBloqueAWasm: ast#cuerpo)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqInicio),
                                 (OP#NAME: etiqFinmientras))
    finsi
    si EsInstancia: ast, AST#NodoNecesitas
        devolver (CompilarAWasm: ast#expresión) >> (Instrucciones: OP#MTRUE)
    finsi
    si EsInstancia: ast, AST#NodoDevolver
        devolver (CompilarAWasm: ast#expresión) >> (Instrucciones: (OP#RETN: 1))
    finsi
    si (EsInstancia: ast, AST#NodoFunción) || (EsInstancia: ast, AST#NodoFunciónAnónima)
        variables nrsParámetros, preludio, cuerpo, fn, nombresLibres, inicDeClosure, locales, localesEnElEntorno, profundidad, localesInmediatas, procid

        fijar preludio a Arreglo#vacio
        [ params ]
        fijar nrsParámetros a NombresDeLosParámetros: ast
        preludio#agregarAlFinal: (Mapear: nrsParámetros, funcion: nr devolver OP#PARAM: nr finfuncion)
        [ locales ]
        fijar locales a LocalesDelBloque: ast
        fijar localesEnElEntorno a VariablesEnElEntorno: locales
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar localesInmediatas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}
        fijar nombresLibres a NombresLibres: ast

        fijar preludio a Concatenar: preludio, (CompilarLocalesYClosure: locales, localesEnElEntorno, localesInmediatas, ast#parámetros, VERDADERO, profundidad)

        fijar procid a GenerarIdDeProcedimiento
        fijar inicDeClosure a (Instrucciones: (OP#MKCLZ: LocalDelEntornoActual, procid))
        si EsInstancia: ast, AST#NodoFunción
            fijar inicDeClosure a inicDeClosure >> (CompilarFijarIdentificador: ast#nombre)
        finsi

        fijar cuerpo a (Compilado#deInstrucciónes: (Aplanar: preludio)) >> (CompilarBloqueAWasm: ast#cuerpo)
        fijar fn a DeclrFunción#crear: procid, nrsParámetros, cuerpo#instrucciones
        devolver inicDeClosure
             >> (Compilado#deDeclaraciones: cuerpo#declaraciones)
             >> (Compilado#deDeclaraciones: (Arreglo#crearCon: fn))
             >> (Compilado#deConstantes: cuerpo#constantes)
    finsi
    si EsInstancia: ast, AST#NodoSonIguales
        variable cmp
        si ast#tipoIgualdad = AST#TipoIgualdad#IGUALES
            fijar cmp a Instrucciones: OP#CMPEQ
        sino
            fijar cmp a Instrucciones: OP#CMPNEQ
        finsi
        devolver (CompilarAWasm: ast#lhs)
              >> (CompilarAWasm: ast#rhs)
              >> cmp
    finsi
    si EsInstancia: ast, AST#NodoNo
        devolver Instrucciones: OP#NOT
    finsi
    si EsInstancia: ast, AST#NodoEscribir
        devolver (CompilarAWasm: ast#valor) >> (Instrucciones: OP#PRN)
    finsi
    si EsInstancia: ast, AST#NodoNl
        devolver Instrucciones: OP#NL
    finsi

    Inalcanzable
finfuncion

[DOCUMENTA
@brief{Normaliza los IDs de las constantes de un compilado.}

El proceso de compilación puede generar muchas constantes duplicadas, esto pone
estrés en el backend que asume que las constantes son únicas. Esta función
devuelve un nuevo @pd{Compilado} que es como @pd{compilado}, pero no solo no
tiene constantes duplicadas, si no que también tiene "parches" que arreglan
todas las referencias ya existentes a constantes. El resultado es un compilado
que es semánticamente identico al original pero con menos constantes.
DOCUMENTA]
funcion NormalizaLosIdsDeConstantes: compilado
    variables constantes, índiceDeConstantes
    fijar constantes a Diccionario#vacío
    fijar índiceDeConstantes a 0

    procedimiento normalizarInstrucciones: instrs
        devolver Mapear: instrs, procedimiento: tupla
            si (tupla#es: Opcode#LCONST) || (tupla#es: Opcode#MSG)
                [ Tanto LCONST como MSG tienen su CID en el primer argumento. ]
                variables cid, cv, clon, cidReal
                fijar cid a tupla#en: 0
                fijar cv a compilado#valorDeConstante: cid
                fijar clon a clonar tupla con finclonar
                si no (constantes#contiene: cv)
                    fijar cidReal a índiceDeConstantes
                    constantes#fijarEn: cv, cidReal
                    fijar índiceDeConstantes a índiceDeConstantes + 1
                sino
                    fijar cidReal a constantes#en: cv
                finsi
                clon#argumentos#fijarEn: 0, cidReal [ <= parchea el CID ]
                devolver clon
            sino
                [ Ningun otro opcode tiene un CID. ]
                devolver tupla
            finsi
        finprocedimiento
    finprocedimiento

    variables nuevasInstrs, nuevasConstantes, nuevasDeclrs
    fijar nuevasInstrs a normalizarInstrucciones: compilado#instrucciones
    fijar nuevasDeclrs a Mapear: compilado#declaraciones, funcion: declr
        devolver clonar declr con
            cuerpo: normalizarInstrucciones: declr#cuerpo
        finclonar
    finfuncion
    fijar nuevasConstantes a Arreglo#vacio
    constantes#paraCadaPar: procedimiento: constv, cid
        nuevasConstantes#agregarAlFinal: (Constante#crear: cid, constv)
    finprocedimiento
    devolver Compilado#crear: nuevasInstrs, nuevasDeclrs, nuevasConstantes
finfuncion

funcion ExtráeInicioMientras: arr, pred
    variable últimoÍndiceVálido
    fijar últimoÍndiceVálido a LlamarConEC: procedimiento: salir
        ParaCadaElementoConÍndice: arr, procedimiento: el, i
            si no %pred: el
                %salir: i
            finsi
        finprocedimiento
        %salir: arr#longitud
    finprocedimiento
    devolver PedazoDeArreglo: arr, 0, (últimoÍndiceVálido + 1)
finfuncion

funcion NormalizaLosIdsDeLocales: compilado
    funcion normalizaLasLocales: parámetros, instrucciones
        variables nuevasLocales, locales, nuevasInstrucciones, nuevosParámetros
        fijar nuevasLocales a Diccionario#vacío
        fijar locales a Filtrar: instrucciones, funcion: tupla
            devolver tupla#es: Opcode#LOCAL
        finfuncion
        ParaCadaElementoConÍndice: parámetros, procedimiento: param, i
            nuevasLocales#fijarEn: param, i
        finprocedimiento
        ParaCadaElementoConÍndice: locales, procedimiento: tupla, i
            nuevasLocales#fijarEn: (tupla#en: 0), (parámetros#longitud + i)
        finprocedimiento

        [ Estas locales nunca cambian, podría tener tres condicionales abajo
          pero creo que es más fácil simplemente agregarlas al diccionario. ]
        nuevasLocales#fijarEn: LocalDelEntornoActual, LocalDelEntornoActual
        nuevasLocales#fijarEn: LocalDelEntornoSuperior, LocalDelEntornoSuperior
        nuevasLocales#fijarEn: {NIL}, {NIL}

        Escribir: {#######}, nuevasLocales

        fijar nuevasInstrucciones a Mapear: instrucciones, funcion: tupla
            [ Escribir: {%%}, tupla ]
            [ Todos estos opcodes tienen su única referencia a una variable
              local en su primer argumento ]
            si (tupla#es: Opcode#LOCAL) || (tupla#es: Opcode#PARAM)
            || (tupla#es: Opcode#LSET)  || (tupla#es: Opcode#LGET)
            || (tupla#es: Opcode#LSETC) || (tupla#es: Opcode#LGETC)
            || (tupla#es: Opcode#MKCLZ) || (tupla#es: Opcode#CLSFRM)
            || (tupla#es: Opcode#ENEW)
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                devolver clon
            finsi
            si tupla#es: Opcode#OPNFRM
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                clon#argumentos#fijarEn: 1, (nuevasLocales#en: (clon#argumentos#en: 1))
                devolver clon
            finsi
            si tupla#es: Opcode#EINIT
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                clon#argumentos#fijarEn: 2, (nuevasLocales#en: (clon#argumentos#en: 2))
                devolver clon
            finsi
            [ Los demás opcodes no tienen referencias a locales ]
            devolver tupla
        finfuncion
        fijar nuevosParámetros a Mapear: parámetros, &(nuevasLocales#en)

        devolver ObjetoAdHoc: {parámetros}, nuevosParámetros,
                              {instrucciones}, nuevasInstrucciones
    finfuncion

    devolver Compilado#crear:
        (normalizaLasLocales: Arreglo#vacio, compilado#instrucciones)#instrucciones,
        (Mapear: compilado#declaraciones, funcion: declr
            variable parámetrosYCuerpo
            fijar parámetrosYCuerpo a normalizaLasLocales: declr#parámetros, declr#cuerpo
            devolver clonar declr con
                parámetros: parámetrosYCuerpo#parámetros
                cuerpo: parámetrosYCuerpo#instrucciones
            finclonar
        finfuncion),
        compilado#constantes
finfuncion

funcion EscaparParaPDVM: texto
    devolver MapearTexto: texto, funcion: car
        si car = {\}
            devolver {\\}
        finsi
        si car = {~q}#formatear
            devolver {\~q}#formatear
        finsi
        si car = {~%}#formatear
            devolver {\n}
        finsi
        devolver car
    finfuncion
finfuncion

procedimiento EmitirCompilado: compilado, puertoDeEscritura
    procedimiento emitirCódigo: tuplas
        ParaCadaElemento: tuplas, procedimiento: tupla
            puertoDeEscritura#escribirTexto: tupla#opcode#nombre
            ParaCadaElementoConÍndice: tupla#argumentos, procedimiento: argumento, i
                si i > 0
                    puertoDeEscritura#escribirTexto: {,}
                finsi
                puertoDeEscritura#escribirTexto: { }
                puertoDeEscritura#escribirTexto: argumento#comoTexto
            finprocedimiento
            puertoDeEscritura#escribirTexto: {~%}#formatear
        finprocedimiento
    finprocedimiento

    puertoDeEscritura#escribirTexto: {PDVM 1.0~%}#formatear
    puertoDeEscritura#escribirTexto: {PLATFORM "pdcrt"~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "code"~%}#formatear
    emitirCódigo: compilado#instrucciones
    puertoDeEscritura#escribirTexto: {ENDSECTION~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "procedures"~%}#formatear
    ParaCadaElemento: compilado#declaraciones, procedimiento: declr
        necesitas EsInstancia: declr, DeclrFunción
        puertoDeEscritura#escribirTexto: ({PROC ~t~%}#formatear: declr#nombre)
        ParaCadaElemento: declr#parámetros, procedimiento: param
            puertoDeEscritura#escribirTexto: ({PARAM ~t~%}#formatear: param)
        finprocedimiento
        emitirCódigo: declr#cuerpo
        puertoDeEscritura#escribirTexto: {ENDPROC~%}#formatear
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "constant pool"~%}#formatear
    ParaCadaElemento: compilado#constantes, procedimiento: constante
        necesitas EsInstancia: constante#valor, Texto
        puertoDeEscritura#escribirTexto: ({#~t STRING "~T"~%}#formatear: constante#id, (EscaparParaPDVM: constante#valor))
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%}#formatear
finprocedimiento

funcion ParsearYDefunc: programa
    variable ast
    fijar ast a Parser#CrearAST: programa

    variable ámbitoPrincipal
    fijar ámbitoPrincipal a RN#ResolverNombres:
        ast,
        procedimiento: nombreDelMódulo
            Inalcanzable
        finprocedimiento,
        procedimiento: ámbito finprocedimiento,
        procedimiento: ámbito finprocedimiento
    Defun#Defuncionalizar: ast
    devolver ast
finfuncion

[{

funcion Q
    2 * 3 - 20 / 4
finfuncion

funcion W: X, Y
    funcion J: K
        funcion Ñ: L
            L - K - X
        finfuncion
        K + X + Y
    finfuncion
    X + Y
finfuncion

variables X, Y, Z
fijar X a 4
fijar Y a X * 2 - Q * 2
fijar Z a Y * Y
Z / 2
Q

}]

clase XD
    atributos esCapturado, binding, índiceDeCaptura, esLocal, altura, profundidad, esLocalInmediata, nodo
    metodo comoTexto
finclase

metodo XD#comoTexto
    devolver {(XD binding = ~t, índiceDeCaptura = ~t, altura = ~t, profundidad = ~t, esCapturado = ~t, esLocal = ~t, esLocalInmediata = ~t, nodo = ~t)}#formatear: yo#binding, yo#índiceDeCaptura, yo#altura, yo#profundidad, yo#esCapturado, yo#esLocal, yo#esLocalInmediata, yo#nodo
finmetodo

variables ast, programa, cc
Escribir: ({Leyendo: ~t}#formatear: (__Argv#en: 0))
fijar programa a SistemaDeArchivos#LeerArchivo: (__Argv#en: 0)
fijar ast a ParsearYDefunc: programa
AnotaciónDeCapturas: ast
[AnotarProfundidadDeIdentificadorEnBloque: ast, 0]
EnumeraciónDeCapturas: ast, EstadoDeEnumeraciónDeCapturas#inicial
EnumeraciónDeLocalesDeProcedimiento: ast, (RN#ObtenerNombresDefinídos: ast), funcion: nid devolver NULO finfuncion
AnotarBindingsLocales: ast
AnotarLocalesInmediatas: ast
EnumeraciónDeLocalesDeProcedimiento: ast, (RN#ObtenerNombresDefinídos: ast), funcion: nid
    devolver clonar XD#crear con
        esCapturado: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        binding: RN#NombreResueltoDe: nid
        índiceDeCaptura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        altura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        esLocal: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
        profundidad: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        esLocalInmediata: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localInmediata}
        nodo: nid
    finclonar
finfuncion
MarcaVariablesLocalesEnSubámbitos: ast
MarcaVariablesQueEstánEnElEntorno: ast
fijar cc a CompilarAWasm: ast
variable ncc
fijar ncc a NormalizaLosIdsDeConstantes: cc
Listado: ncc
Escribir: {====================}
EmitirCompilado: (NormalizaLosIdsDeLocales: ncc), SalidaEstándar

[ FIXME:

El bug es que las variables solo son consideradas como capturadas si pasan de
una función a otra, y son consideradas como locales si no son de la función
actual. Cuando pruebo `esCapturada || no esLocal` para saber si debería usar
`EACT` o no, no estoy teniendo en cuenta un tercer caso: si una variable está
declarada en un ámbito que no es el principal del programa/función, esta se
mueve automáticamente al subentorno creado por `SPUSH`. Como estas variables
aún son locales y no son capturadas, después trato de accederlas con `LGET` en
vez de `LGETC`. Creo que la mejor opción sería:

1. Agregar un nuevo pase `MarcaVariablesLocalesEnSubámbitos` que marque todas
estas variables que son locales (irrelevantemente de si son capturadas o no)
pero son declaradas en subámbitos en vez de el ámbito principal.

2. Hacer que la condición para que una local esté en el entorno sea
`esCapturada || no esLocal || esDeclaradaEnUnSubámbito`.

 ]

[ FIXME:

El nuevo bug es que las funciones (declaradas con `funcion`) no están siendo
consideradas locales: conceptualmente no hay diferencia entre una `function X
... finfuncion` y `variable X fijar X a funcion ... finfuncion` (ignorando
intencionalmente el sistema de autoejecución). Sin embargo, por algún motivo,
las funciones no aparecen en la lista de locales (opcode `LOCAL`) incluso
cuando parece que si son marcadas como locales..

 ]

[fijar cc a CompilarAWasm: ast, Diccionario#vacío

Escribir: ({~t :: ~t :: ~t}#formatear: (TipoDe: cc), (TipoDe: cc#declaraciones), (TipoDe: cc#instrucciones))
Escribir: ({~t~%~t}#formatear: cc#declaraciones, cc#instrucciones)
Listado: cc]
[__Lua: {rt.inspectobj}, cc]
