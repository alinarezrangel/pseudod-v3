utilizar bepd/builtins
utilizar bepd/x/adhoc (ObjetoAdHoc)
utilizar bepd/datos/conjunto (Conjunto)
utilizar bepd/datos/diccionario (Diccionario)
utilizar bepd/x/puerto (SalidaEstándar)
utilizar bepd/x/puerto/deArchivo como PDA
utilizar bepd/x/puerto/conPosición (PosiciónTextual)
utilizar bepd/x/sistemaDeArchivos/archivo como SistemaDeArchivos
utilizar bepd/utilidades/texto
utilizar bepd/utilidades/iteración
utilizar bepd/utilidades/arreglo
utilizar bepd/x/enum (Enum, EnumConValores)

utilizar tokens como Tokens
utilizar ast como AST
utilizar parser como Parser
utilizar resoluciónDeNombres como RN
utilizar defuncionalización como Defun
utilizar módulos como Módulos



[DOCUMENTA
@brief{Camina un AST.}

@pd{nodo} es el nodo que se recorrerá.

@pd{cuerpo} es el procedimiento que se llamará.

Específicamente, @pd{Caminar'} llamará a @pd{cuerpo} con dos valores, el nodo
actual (que al principio es @pd{nodo}) y un @italic{recursor}. El recursor
tiene 2 métodos:

@itemlist(
@item{@code{recursor#\llamar\: nodo}: Itera sobre cada subnodo de @pd{nodo}
(sin incluir @pd{nodo}) y continúa la recursión con cada uno.}

@item{@code{recursor#llamarConRecursión: nodo, nuevoCuerpo}: Itera sobre cada
subnodo de @pd{nodo} (sin incluirlo) y continúa la recursión con cada uno como
si @pd{Caminar'} se hubiese llamado con @pd{nuevoCuerpo} en vez de
@pd{cuerpo}.}
)

Devuelve un valor indefinido.
DOCUMENTA]
funcion Caminar': nodo, cuerpo
    funcion visitarPartesRecursivas: nodo, f
        si EsInstancia: nodo, AST#NodoPrograma
            devolver ParaCadaElemento: nodo#instrucciones, f
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoFijar
            %f: nodo#objetivo
            devolver %f: nodo#valor
        finsi
        si EsInstancia: nodo, AST#NodoEscribir
            devolver %f: nodo#valor
        finsi
        si EsInstancia: nodo, AST#NodoNl
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoClase
            %f: nodo#nombre
            si no EsNulo: nodo#claseBase
                %f: nodo#claseBase
            finsi
            ParaCadaElemento: nodo#extiendeClases, f
            ParaCadaElemento: nodo#implementaClases, f
            devolver ParaCadaElemento: nodo#declaraciones, f
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
            %f: nodo#nombre
            devolver ParaCadaElemento: nodo#parámetros, f
        finsi
        si EsInstancia: nodo, AST#NodoImplementa
            %f: nodo#nombre
            devolver ParaCadaElemento: nodo#definiciones, f
        finsi
        si EsInstancia: nodo, AST#NodoDefineAtributosEnClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoDefineMétodoEnClase
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoNecesitas
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoDevolver
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoSi
            %f: nodo#condicional
            ParaCadaElemento: nodo#siVerdadero, f
            devolver ParaCadaElemento: nodo#siFalso, f
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            %f: nodo#condicional
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoMétodo
            si no EsNulo: nodo#deClase
                %f: nodo#deClase
            finsi
            %f: nodo#nombre
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoAtributos
            %f: nodo#deClase
            devolver ParaCadaElemento: nodo#nombres, f
        finsi
        si EsInstancia: nodo, AST#NodoUtilizar
            NoImplementado
        finsi

        si EsInstancia: nodo, AST#NodoIdentificador
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoNumeroLiteral
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoTextoLiteral
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoLlamarProcedimiento
            %f: nodo#proc
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoEnviarMensaje
            %f: nodo#objeto
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoOperador
            %f: nodo#lhs
            devolver %f: nodo#rhs
        finsi
        si EsInstancia: nodo, AST#NodoNoLlamar
            devolver %f: nodo#base
        finsi
        si EsInstancia: nodo, AST#NodoAutoejecutar
            %f: nodo#expr
            devolver ParaCadaElemento: nodo#argumentos, f
        finsi
        si EsInstancia: nodo, AST#NodoFunciónAnónima
            ParaCadaElemento: nodo#parámetros, f
            devolver ParaCadaElemento: nodo#cuerpo, f
        finsi
        si EsInstancia: nodo, AST#NodoSonIguales
            %f: nodo#lhs
            devolver %f: nodo#rhs
        finsi
        si EsInstancia: nodo, AST#NodoReferenciar
            devolver %f: nodo#nombre
        finsi
        si EsInstancia: nodo, AST#NodoNo
            devolver %f: nodo#expresión
        finsi
        si EsInstancia: nodo, AST#NodoClonar
            %f: nodo#expresiónAClonar
            devolver ParaCadaElemento: nodo#campos, funcion: campo
                devolver %f: (campo#en: 1)
            finfuncion
        finsi

        si EsInstancia: nodo, AST#NodoVariadic
            devolver %f: nodo#interno
        finsi

        [ Nunca se llega hasta aquí. ]
        Escribir: ({Caminar no implementado para ~t}#formatear: (TipoDe: nodo))
        Inalcanzable
    finfuncion

    clase RecursorDeCaminar
        metodo \llamar\: nodo
        metodo llamarConRecursión: nodo, recur
    finclase

    metodo RecursorDeCaminar#\llamar\: nodoEnElQueContinuar
        devolver yo#llamarConRecursión: nodoEnElQueContinuar, cuerpo
    finmetodo

    metodo RecursorDeCaminar#llamarConRecursión: nodoEnElQueContinuar, recur
        devolver visitarPartesRecursivas: nodoEnElQueContinuar, funcion: nodo
            devolver %recur: nodo, yo
        finfuncion
    finmetodo

    devolver %cuerpo: nodo, RecursorDeCaminar#crear
finfuncion

[DOCUMENTA
@brief{Versión más fácil de usar de @pd{Caminar'}.}

Llama a @pd{cuerpo} con cada subnodo de @pd{nodo} para el cual @pd{%filtro:
nodo} devuelva @pd{VERDADERO}. Esta es una versión más limitada pero también
más fácil de usar que @pd{Caminar'}.

Devuelve un valor indefinido.
DOCUMENTA]
funcion Caminar: nodo, filtro, cuerpo
    funcion bucle: nodo, K
        si %filtro: nodo
            devolver %cuerpo: nodo, funcion: nodoEnElQueContinuar
                devolver bucle: nodoEnElQueContinuar, K
            finfuncion
        sino
            devolver %K: nodo
        finsi
    finfuncion
    devolver Caminar': nodo, &bucle
finfuncion


[ Este backend consiste de varios "mini-pases". Actualmente se encuentran en
  este mismo archivo, quizás después deba moverlos a sus propios archivos.

  Todos estos minipases usan la llave de anotación de capturas. ]


[DOCUMENTA
@brief{Tipo de @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}.}
DOCUMENTA]
clase LlaveAnotaciónDeCapturas
    metodo comoTexto
finclase

metodo LlaveAnotaciónDeCapturas#comoTexto
    devolver {LLAVE_ANOTACIÓN_DE_CAPTURAS}
finmetodo

[DOCUMENTA
@brief{Llave de anotación de capturas.}

Es la llave usada por los pases del backend de tuplas para agregar metadatos a
los nodos.
DOCUMENTA]
variable LLAVE_ANOTACIÓN_DE_CAPTURAS
fijar LLAVE_ANOTACIÓN_DE_CAPTURAS a LlaveAnotaciónDeCapturas#crear

[DOCUMENTA
@brief{Obtiene los nombres libres de un nodo.}

Véase el pase de defuncionalización (@pd{Defuncionalizar}).
DOCUMENTA]
funcion NombresLibres: nodo
    si EsInstancia: nodo, AST#NodoPrograma
        devolver Conjunto#vacío
    sino
        devolver nodo#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres}
    finsi
finfuncion

[DOCUMENTA
@brief{Anota todos los identificadores que representan variables.}

Anota todos los @pd{AST#NodoIdentificador} de @pd{ast} con el metadato
@code{esBásicamenteTextual} (llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es
@pd{VERDADERO} o @pd{FALSO} dependiendo de si el @pd{AST#NodoIdentificador} es
"textual" (su @code{#nombre} debe ser interpretado de forma literal) o no (es
el nombre de una variable).
DOCUMENTA]
procedimiento AnotarIdentificadoresTextuales: ast
    variable especiales
    fijar especiales a Arreglo#crearCon:
        AST#NodoIdentificador, AST#NodoDeclaraciónDeAtributosEnClase,
        AST#NodoDeclaraciónDeMétodoEnClase, AST#NodoMétodo, AST#NodoAtributos
    procedimiento esTextual: nodo, es
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esBásicamenteTextual}, es
    finprocedimiento
    Caminar: ast, funcion: nodo
        devolver Algún: (Mapear: especiales, (Parcial: &EsInstancia, nodo))
    finfuncion, funcion: nodo, recur
        si EsInstancia: nodo, AST#NodoIdentificador
            esTextual: nodo, FALSO
        finsi
        si EsInstancia: nodo, AST#NodoMétodo
            esTextual: nodo#deClase, FALSO
            esTextual: nodo#nombre, VERDADERO
            ParaCadaElemento: nodo#parámetros, recur
            ParaCadaElemento: nodo#cuerpo, recur
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
            ParaCadaElemento: nodo#nombres, procedimiento: nombre
                esTextual: nombre, VERDADERO
            finprocedimiento
        finsi
        si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
            esTextual: nodo#nombre, VERDADERO
            ParaCadaElemento: nodo#parámetros, recur
        finsi
        si EsInstancia: nodo, AST#NodoAtributos
            esTextual: nodo#deClase, FALSO
            ParaCadaElemento: nodo#nombres, procedimiento: nombre
                esTextual: nombre, VERDADERO
            finprocedimiento
        finsi
    finfuncion
finprocedimiento

[DOCUMENTA
@brief{Obtiene el metadato @code{esBásicamenteTextual} (llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}).}

Si @pd{nodo} no es un @pd{AST#NodoIdentificador} devuelve @pd{FALSO}.
DOCUMENTA]
funcion EsBásicamenteTextual: nodo
    si EsInstancia: nodo, AST#NodoIdentificador
        devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esBásicamenteTextual}
    sino
        devolver FALSO
    finsi
finfuncion

[DOCUMENTA
@brief{Determina si el nodo representa una variable mediante el metadato
@code{esBásicamenteTextual} (llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}).}

Básicamente devuelve @code{no esBásicamenteTextual}. Si @pd{nodo} no es un
@pd{AST#NodoIdentificador} devuelve @pd{FALSO}.
DOCUMENTA]
funcion EsIdentificadorDeVariable: nodo
    si EsInstancia: nodo, AST#NodoIdentificador
        devolver no nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esBásicamenteTextual}
    sino
        devolver FALSO
    finsi
finfuncion

[DOCUMENTA
@brief{Determina si el nodo contiene una variable @pd{yo} implícita.}

Devuelve @pd{VERDADERO} si @pd{nodo} declara de forma implícita una variable
@pd{yo}. Por ejemplo, @pd{AST#NodoFunción}es que fueron declarados con
@code{metodo}, @pd{AST#NodoMétodo} y @pd{AST#NodoFunciónAnónima} que fueron
creadas con @code{metodo} declaran de forma implícita una variable @pd{yo}.
DOCUMENTA]
funcion ContieneYoImplícito: nodo
    si EsInstancia: nodo, AST#NodoFunciónAnónima
        devolver nodo#esMétodo
    finsi
    si EsInstancia: nodo, AST#NodoMétodo
        devolver VERDADERO
    finsi
    devolver FALSO
finfuncion

[DOCUMENTA
@brief{Devuelve el nombre resuelto (binding) del @pd{yo} implícito de un nodo.}

@pd{nodo} debe declarar un @pd{yo} implícito (véase @pd{ContieneYoImplícito}).
DOCUMENTA]
funcion NombreResueltoDelYoImplícito: nodo
    necesitas ContieneYoImplícito: nodo
    devolver nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombreResueltoDeYo}
finfuncion

[DOCUMENTA
@brief{Si el nodo debe ser ignorado para propósitos de compilación.}

Algunos nodos, como los @pd{AST#NodoDeclaraciónDeMétodoEnClase} no deben ser
compilados ni analizados. Estos nodos básicamente no tienen funcionalidad para
el backend.

Devuelve @pd{VERDADERO} si @pd{nodo} debería ser ignorado y @pd{FALSO} de lo
contrario.
DOCUMENTA]
funcion DebeIgnorarElNodo: nodo
    devolver EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
finfuncion

[DOCUMENTA
@brief{Pase de anotación de capturas.}

Anota todos los @pd{AST#NodoIdentificador} del AST con un metadato
@code{esCapturado} (con llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un
@pd{Boole} indicando si ese identificador es capturado o no por una closure.
DOCUMENTA]
procedimiento AnotaciónDeCapturas: ast
    variable nombresCapturadosAcc, nombresCapturados
    fijar nombresCapturadosAcc a Arreglo#vacio
    Caminar: ast, funcion: nodo
        variable declaraciones
        fijar declaraciones a Arreglo#crearCon:
            AST#NodoVariable, AST#NodoFunción, AST#NodoClase, AST#NodoMétodo, AST#NodoFunciónAnónima
        devolver (DebeIgnorarElNodo: nodo)
              || (ContieneYoImplícito: nodo)
              || (Algún: (Mapear: declaraciones, (Parcial: &EsInstancia, nodo)))
    finfuncion, procedimiento: nodo, recur
        [ FIXME: Esto siempre captura `yo` incluso cuando no lo esta siendo realmente ]
        [ si ContieneYoImplícito: nodo ]
        [     nombresCapturadosAcc#agregarAlFinal: (Conjunto#conValores: (NombreResueltoDelYoImplícito: nodo)) ]
        [ finsi ]
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si (EsInstancia: nodo, AST#NodoFunción)
        || (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoMétodo)
            nombresCapturadosAcc#agregarAlFinal: (NombresLibres: nodo)
            ParaCadaElemento: nodo#cuerpo, procedimiento: cn
                devolver %recur: cn
            finprocedimiento
            devolver NULO
        finsi
    finprocedimiento
    fijar nombresCapturados a Reducir: Conjunto#vacío, (MétodoComoFunción: {unión}), nombresCapturadosAcc
    Caminar': ast, procedimiento: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si ContieneYoImplícito: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsCapturado}, (nombresCapturados#contiene: (NombreResueltoDelYoImplícito: nodo))
        finsi
        si EsIdentificadorDeVariable: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}, (nombresCapturados#contiene: (RN#NombreResueltoDe: nodo))
        finsi
        devolver %recur: nodo
    finprocedimiento
finprocedimiento

[ TODO: Documenta las siguientes clases ]
clase LocalDelProcedimiento
    metodo esCapturado
    metodo binding
    metodo índiceDeCaptura
    metodo esLocal
    metodo altura
    metodo profundidad
    metodo esLocalInmediata
    metodo esLocalDirecta
    metodo estáEnElEntorno
finclase

metodo LocalDelProcedimiento#comoTexto
    devolver {(~t esCapturado = ~t, binding = ~t, índiceDeCaptura = ~t, esLocal = ~t, altura = ~t, profundidad = ~t, esLocalInmediata = ~t, esLocalDirecta = ~t, estáEnElEntorno = ~t)}#formatear: (TipoDe: yo), yo#esCapturado, yo#binding, yo#índiceDeCaptura, yo#esLocal, yo#altura, yo#profundidad, yo#esLocalInmediata, yo#esLocalDirecta, yo#estáEnElEntorno
finmetodo

clase IdentificadorLocalDelProcedimiento hereda LocalDelProcedimiento
    metodo estatico crear: nid
    metodo nodo
finclase

atributo IdentificadorLocalDelProcedimiento#nodo

metodo IdentificadorLocalDelProcedimiento#inicializar: nid
    fijar yo#nodo a nid
finmetodo

metodo IdentificadorLocalDelProcedimiento#binding
    devolver RN#NombreResueltoDe: yo#nodo
finmetodo

metodo IdentificadorLocalDelProcedimiento#esCapturado
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#índiceDeCaptura
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#esLocal
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#altura
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#profundidad
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#esLocalInmediata
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalInmediata}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalInmediata}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#esLocalDirecta
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta}
    sino
        devolver NULO
    finsi
finmetodo

metodo IdentificadorLocalDelProcedimiento#estáEnElEntorno
    si yo#nodo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}
        devolver yo#nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}
    sino
        devolver NULO
    finsi
finmetodo

clase YoLocalDelProcedimiento hereda LocalDelProcedimiento
    metodo estatico crear: nodoConYo
    metodo nodoConYo
finclase

atributo YoLocalDelProcedimiento#nodoConYo

metodo YoLocalDelProcedimiento#inicializar: nodoConYo
    necesitas ContieneYoImplícito: nodoConYo
    fijar yo#nodoConYo a nodoConYo
finmetodo

metodo YoLocalDelProcedimiento#binding
    devolver NombreResueltoDelYoImplícito: yo#nodoConYo
finmetodo

metodo YoLocalDelProcedimiento#esCapturado
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsCapturado}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsCapturado}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#índiceDeCaptura
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeYo}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeYo}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#esLocal
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocal}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocal}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#altura
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeYo}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeYo}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#profundidad
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeYo}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeYo}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#esLocalInmediata
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalInmediata}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalInmediata}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#esLocalDirecta
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalDirecta}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalDirecta}
    sino
        devolver NULO
    finsi
finmetodo

metodo YoLocalDelProcedimiento#estáEnElEntorno
    si yo#nodoConYo#contieneMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEstáEnElEntorno}
        devolver yo#nodoConYo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEstáEnElEntorno}
    sino
        devolver NULO
    finsi
finmetodo

[ TODO: Documenta este pase ]
procedimiento EnumeraciónDeLocalesDeProcedimiento: ast, ámbitoContenedor
    necesitas (EsInstancia: ast, AST#NodoFunción)
           || (EsInstancia: ast, AST#NodoFunciónAnónima)
           || (EsInstancia: ast, AST#NodoMétodo)
           || (EsInstancia: ast, AST#NodoPrograma)
    variables locales, ámbitosLocales, nodosLocales
    fijar locales a Arreglo#vacio
    fijar ámbitosLocales a Pila#vacía
    fijar nodosLocales a Pila#vacía

    procedimiento AgregarLocal: local
        locales#agregarAlFinal: local
        necesitas ámbitosLocales#longitud = nodosLocales#longitud
        ParaCadaElemento: nodosLocales#_elementos, procedimiento: agregador
            devolver %agregador: local
        finprocedimiento
    finprocedimiento

    procedimiento FijarMetadatoConIdentificadorLocal: nid
        variable local
        fijar local a IdentificadorLocalDelProcedimiento#crear: nid
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {local}, local
        devolver local
    finprocedimiento

    procedimiento AgregarIdentificadorLocal: nid
        devolver AgregarLocal: (FijarMetadatoConIdentificadorLocal: nid)
    finprocedimiento

    procedimiento AgregarYoLocal: nodoConYo
        necesitas ContieneYoImplícito: nodoConYo
        variable local
        fijar local a YoLocalDelProcedimiento#crear: nodoConYo
        nodoConYo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localYo}, local
        devolver AgregarLocal: local
    finprocedimiento

    procedimiento CreaAgregador: nodo, metadato
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato, Arreglo#vacio
        devolver procedimiento: local
            (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato)#agregarAlFinal: local
        finprocedimiento
    finprocedimiento

    ámbitosLocales#apilar: ámbitoContenedor
    nodosLocales#apilar: (CreaAgregador: ast, {localesDelNodo'})

    funcion filtro: nodo
        devolver (DebeIgnorarElNodo: nodo)
              || (EsIdentificadorDeVariable: nodo)
              || (EsInstancia: nodo, AST#NodoFunción)
              || (EsInstancia: nodo, AST#NodoMétodo)
              || (EsInstancia: nodo, AST#NodoFunciónAnónima)
              || (EsInstancia: nodo, AST#NodoSi)
              || (EsInstancia: nodo, AST#NodoMientras)
              || (EsInstancia: nodo, AST#NodoPrograma)
              || (ContieneYoImplícito: nodo)
    finfuncion

    procedimiento interno: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si EsIdentificadorDeVariable: nodo
            si Defun#EsLocalEntre: ámbitoContenedor, ámbitosLocales#últimoValorApilado, nodo
                AgregarIdentificadorLocal: nodo
            sino
                FijarMetadatoConIdentificadorLocal: nodo
            finsi
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            %recur: nodo#condicional
            ámbitosLocales#apilar: (RN#ObtenerNombresDefinídos: nodo)
            nodosLocales#apilar: (CreaAgregador: nodo, {localesDelNodo})
            ParaCadaElemento: nodo#cuerpo, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            %recur: nodo#condicional
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiVerdadero})
            ParaCadaElemento: nodo#siVerdadero, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiFalso})
            ParaCadaElemento: nodo#siFalso, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi

        si (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoMétodo)
        || (EsInstancia: nodo, AST#NodoPrograma)
        || (EsInstancia: nodo, AST#NodoFunción)
            si EsInstancia: nodo, AST#NodoMétodo
                %recur: nodo#deClase
            finsi
            si EsInstancia: nodo, AST#NodoFunción
                %recur: nodo#nombre
            finsi
            devolver EnumeraciónDeLocalesDeProcedimiento: nodo, (RN#ObtenerNombresDefinídos: nodo)
        finsi

        necesitas no ContieneYoImplícito: nodo
    finprocedimiento

    si (EsInstancia: ast, AST#NodoFunción)
    || (EsInstancia: ast, AST#NodoFunciónAnónima)
    || (EsInstancia: ast, AST#NodoMétodo)
        ParaCadaElemento: ast#parámetros, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
        ParaCadaElemento: ast#cuerpo, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
    finsi
    si ContieneYoImplícito: ast
        AgregarYoLocal: ast
    finsi
    si EsInstancia: ast, AST#NodoPrograma
        ParaCadaElemento: ast#instrucciones, procedimiento: nodo
            devolver Caminar: nodo, &filtro, &interno
        finprocedimiento
    finsi

    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}, (Conjunto#desdeArreglo: (Mapear: locales, (MétodoComoFunción: {binding})))
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}, locales
finprocedimiento

[DOCUMENTA
@brief{Anota todas las variables locales que estan en el ámbito en el que
fueron declaradas.}

Cuando una variable es usada en el mismo ámbito en el que fue declarada decimos
que este uso es @italic{inmediato}. Los usos inmediatos son importantes porque
si todos los usos de una variable son usos inmediatos entonces esta puede estar
fuera de cualquier entorno.

Agrega el metadato (con la llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS})
@code{localesInmediatas} a cada nodo que pueda tener un ámbito
(@pd{AST#NodoPrograma}, @pd{AST#NodoMientras}, @pd{AST#NodoFunción},
@pd{AST#NodoFunciónAnónima}). @pd{AST#NodoSi} tiene sus propios metadatos
@code{localesInmediatasSiVerdadero} y @code{localesInmediatasSiFalso}. En todos
los casos el valor del metadato es un arreglo con las locales del ámbito
(devueltas tal y como @pd{EnumeraciónDeLocalesDeProcedimiento}) que son locales
inmediatas.

Además, anota cada @pd{AST#NodoIdentificador} con @code{localInmediata}, un
metadato que es @pd{VERDADERO} o @pd{FALSO} dependiendo de si el identificador
es una local inmediata o no.
DOCUMENTA]
procedimiento AnotarLocalesInmediatas: ast
    variable NODOS_CON_ÁMBITO
    fijar NODOS_CON_ÁMBITO a Arreglo#crearCon: AST#NodoPrograma, AST#NodoSi, AST#NodoMientras, AST#NodoFunción, AST#NodoFunciónAnónima, AST#NodoMétodo

    funcion esBloqueConÁmbito: ast
        devolver (Algún: (Mapear: NODOS_CON_ÁMBITO, (Parcial: &EsInstancia, ast)))
    finfuncion

    procedimiento marcarInmediatas: ast, ámbito, recurBloque
        variable todasLasLocales
        fijar todasLasLocales a Arreglo#vacio
        Caminar: ast, funcion: ast
            devolver (DebeIgnorarElNodo: ast)
                  || (EsIdentificadorDeVariable: ast)
                  || (esBloqueConÁmbito: ast)
        finfuncion, procedimiento: ast, recur
            si DebeIgnorarElNodo: ast
                devolver NULO
            finsi
            si EsIdentificadorDeVariable: ast
                variables nr, inmediata
                fijar nr a RN#NombreResueltoDe: ast
                fijar inmediata a Contiene: ámbito#todosLosBindingsLocales, nr
                [ Escribir: {ID}, ast ]
                [ Escribir: {ES}, nr, {Y}, inmediata ]
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localInmediata}, inmediata
                si inmediata
                    todasLasLocales#agregarAlFinal: ast
                finsi
                devolver NULO
            finsi
            si EsInstancia: ast, AST#NodoMétodo
                %recur: ast#deClase
                devolver %recurBloque: ast
            finsi
            si EsInstancia: ast, AST#NodoFunción
                %recur: ast#nombre
                devolver %recurBloque: ast
            finsi
            devolver %recurBloque: ast
        finprocedimiento
        devolver todasLasLocales
    finprocedimiento

    procedimiento recursión: ast, K
        si DebeIgnorarElNodo: ast
            devolver NULO
        finsi
        si esBloqueConÁmbito: ast
            procedimiento marcarConÁmbito: ast, ámbito
                variable locales
                fijar locales a Arreglo#vacio
                K#llamarConRecursión: ast, funcion: nodo, K'
                    variable nuevasLocales
                    fijar nuevasLocales a marcarInmediatas: nodo, ámbito, funcion: bloque
                        devolver recursión: bloque, K
                    finfuncion
                    fijar locales a Concatenar: locales, nuevasLocales
                finfuncion
                devolver locales
            finprocedimiento

            si EsInstancia: ast, AST#NodoSi
                variables siVerdadero, siFalso, localesSiVerdadero, localesSiFalso
                fijar siVerdadero a ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero}
                fijar siFalso a ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso}
                fijar localesSiVerdadero a marcarConÁmbito: ast, siVerdadero
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiVerdadero}, localesSiVerdadero
                fijar localesSiFalso a marcarConÁmbito: ast, siFalso
                ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiFalso}, localesSiFalso
                [ Escribir: {NodoSi}, ast#areaTextual ]
                [ Escribir: {siVerdadero}, localesSiVerdadero ]
                [ Escribir: {siFalso}, localesSiFalso ]
            sino
                variable locales
                si EsInstancia: ast, AST#NodoFunción
                    variables ámbito, localInmediata
                    fijar ámbito a RN#ObtenerNombresDefinídos: ast
                    fijar localInmediata a ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localInmediata}
                    fijar locales a marcarConÁmbito: ast, ámbito
                    ast#nombre#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localInmediata}, localInmediata
                    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}, locales
                    [ Escribir: {NodoFunción}, ast#areaTextual ]
                    [ Escribir: {locales}, locales ]
                sino
                    variable ámbito
                    fijar ámbito a RN#ObtenerNombresDefinídos: ast
                    fijar locales a marcarConÁmbito: ast, ámbito
                    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}, locales
                    [ Escribir: (TipoDe: ast), ast#areaTextual ]
                    [ Escribir: {locales}, locales ]
                finsi

                si ContieneYoImplícito: ast
                    [ Escribir: {Contiene yo implícito} ]
                    [ variable nrYo ]
                    [ fijar nrYo a NombreResueltoDelYoImplícito: ast ]
                    [ ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalInmediata}, (Contiene: (Mapear: locales, (MétodoComoFunción: {binding})), nrYo) ]
                    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalInmediata}, VERDADERO
                finsi
            finsi
        sino
            Escribir: ast
            Inalcanzable
        finsi
    finprocedimiento

    Caminar': ast, &recursión
finprocedimiento


clase EstadoDeEnumeraciónDeCapturas
    [ asoc: Diccionario de los bindings a sus informaciones de capturas. ]
    [ acc: Número de capturas. ]
    atributos asoc, acc, estadoSuperior

    metodo estatico inicial
    metodo estatico desdeEstado: estado

    metodo marcarÍndiceCapturaEnDeclaración: nid
    metodo marcarÍndiceCapturaEnDeclaraciónDeYo: nid
    metodo marcarÍndiceCapturaEnUso: nid
    metodo informaciónDeLaCaptura: nid

    metodo profundidad
finclase

metodo estatico EstadoDeEnumeraciónDeCapturas#inicial
    devolver yo#crear
finmetodo

metodo estatico EstadoDeEnumeraciónDeCapturas#desdeBuiltins: builtins
    variables estado, acc
    fijar estado a yo#crear
    fijar acc a 0
    builtins#paraCadaPar: procedimiento: nombre, binding
        estado#asoc#fijarEn: binding, acc
        fijar acc a acc + 1
    finprocedimiento
    fijar estado#acc a acc
    devolver estado
finmetodo

metodo estatico EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
    devolver clonar yo#crear con
        estadoSuperior: estado
    finclonar
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#inicializar
    fijar yo#asoc a Diccionario#vacío
    fijar yo#acc a 0
    fijar yo#estadoSuperior a NULO
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnDeclaración: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, 0
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, yo#acc
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, yo#profundidad
    yo#asoc#fijarEn: (RN#NombreResueltoDe: nid), yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnDeclaraciónDeYo: nodo
    nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {alturaDeYo}, 0
    nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCapturaDeYo}, yo#acc
    nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidadDeYo}, yo#profundidad
    yo#asoc#fijarEn: (NombreResueltoDelYoImplícito: nodo), yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#informaciónDeLaCaptura: nid
    si yo#asoc#contiene: (RN#NombreResueltoDe: nid)
        devolver ObjetoAdHoc: {altura}, 0,
                              {índiceDeCaptura}, (yo#asoc#en: (RN#NombreResueltoDe: nid)),
                              {profundidad}, yo#profundidad
    sino
        variable dt
        si EsNulo: yo#estadoSuperior
            Escribir: {No existe?}, nid
        finsi
        necesitas no EsNulo: yo#estadoSuperior
        fijar dt a yo#estadoSuperior#informaciónDeLaCaptura: nid
        devolver clonar dt con
            altura: dt#altura + 1
        finclonar
    finsi
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnUso: nid
    variable dt
    fijar dt a yo#informaciónDeLaCaptura: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, dt#altura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, dt#índiceDeCaptura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, dt#profundidad
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#profundidad
    si EsNulo: yo#estadoSuperior
        devolver 0
    sino
        devolver 1 + yo#estadoSuperior#profundidad
    finsi
finmetodo

[DOCUMENTA
@brief{Anota los identificadores del programa con su información de captura.}

Cada identificador es anotado con los metadatos @code{altura},
@code{profundidad} e @code{índiceDeCaptura} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}).

@code{altura} es el número de entornos que se debe "saltar".

@code{índiceDeCaptura} es el índice dentro del entorno seleccionado. Asume que
cada ámbito es compilado a un entorno en el IR.

@code{profundidad} es un número que indica la profundidad dentro del programa
en la que se declaró la variable
DOCUMENTA]
procedimiento EnumeraciónDeCapturas: ast, estado
    variable DECLARACIONES
    fijar DECLARACIONES a Arreglo#crearCon: AST#NodoVariable, AST#NodoFunción, AST#NodoMétodo,
                                            AST#NodoFunciónAnónima, AST#NodoIdentificador,
                                            AST#NodoSi, AST#NodoMientras, AST#NodoPrograma,
                                            AST#NodoClase

    Caminar: ast, funcion: nodo
        devolver (DebeIgnorarElNodo: nodo)
              || (Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo)))
    finfuncion, procedimiento: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoPrograma
            ParaCadaElemento: nodo#instrucciones, recur
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, estado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoClase
            estado#marcarÍndiceCapturaEnDeclaración: nodo#nombre
            si no EsNulo: nodo#claseBase
                %recur: nodo#claseBase
            finsi
            ParaCadaElemento: nodo#extiendeClases, recur
            ParaCadaElemento: nodo#implementaClases, recur
            ParaCadaElemento: nodo#declaraciones, recur
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            ParaCadaElemento: nodo#nombres, &(estado#marcarÍndiceCapturaEnDeclaración)
            devolver NULO
        finsi
        si (EsInstancia: nodo, AST#NodoFunción)
        || (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoMétodo)
            variable subestado
            si EsInstancia: nodo, AST#NodoFunción
                estado#marcarÍndiceCapturaEnDeclaración: nodo#nombre
            finsi
            si EsInstancia: nodo, AST#NodoMétodo
                estado#marcarÍndiceCapturaEnUso: nodo#deClase
            finsi
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            si ContieneYoImplícito: nodo
                subestado#marcarÍndiceCapturaEnDeclaraciónDeYo: nodo
            finsi
            ParaCadaElemento: nodo#parámetros, procedimiento: param
                si EsInstancia: param, AST#NodoVariadic
                    subestado#marcarÍndiceCapturaEnDeclaración: param#interno
                sino
                    subestado#marcarÍndiceCapturaEnDeclaración: param
                finsi
            finprocedimiento
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            variable subestado
            %recur: nodo#condicional
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            variables subestadoSiVerdadero, subestadoSiFalso
            %recur: nodo#condicional
            fijar subestadoSiVerdadero a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siVerdadero, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestadoSiVerdadero
            finprocedimiento
            fijar subestadoSiFalso a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siFalso, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestadoSiFalso
            finprocedimiento
            necesitas subestadoSiVerdadero#profundidad = subestadoSiFalso#profundidad
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestadoSiFalso#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            si EsIdentificadorDeVariable: nodo
                estado#marcarÍndiceCapturaEnUso: nodo
            sino
                [ Escribir: {EnumeraciónDeCapturas: No es id. de variable </>}, nodo ]
            finsi
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Anota los bindings locales de un ámbito.}

Agrega a cada nodo identificador un metadato @code{esLocal} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un @pd{Boole} indicando si el
identificador es "local" a su posición: es decir, si fue declarado en la
función en la que se encuentra.
DOCUMENTA]
procedimiento AnotarBindingsLocales: ast
    necesitas (EsInstancia: ast, AST#NodoFunción)
           || (EsInstancia: ast, AST#NodoMétodo)
           || (EsInstancia: ast, AST#NodoFunciónAnónima)
           || (EsInstancia: ast, AST#NodoPrograma)
    variables bindings, nombre
    fijar bindings a BindingsLocalesDelBloque: ast
    si EsInstancia: ast, AST#NodoFunción
        fijar nombre a ast#nombre
    sino
        fijar nombre a NULO
    finsi
    Caminar: ast, funcion: nodo
        devolver (DebeIgnorarElNodo: nodo)
              || (   (no Defun#SonElMismoObjeto: nodo, ast)
                  && (no Defun#SonElMismoObjeto: nodo, nombre)
                  && (   (EsInstancia: nodo, AST#NodoIdentificador)
                      || (EsInstancia: nodo, AST#NodoFunción)
                      || (EsInstancia: nodo, AST#NodoMétodo)
                      || (EsInstancia: nodo, AST#NodoFunciónAnónima)
                      || (EsInstancia: nodo, AST#NodoPrograma)))
    finfuncion, procedimiento: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            si EsIdentificadorDeVariable: nodo
                nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}, (bindings#contiene: (RN#NombreResueltoDe: nodo))
            sino
                [ Escribir: {AnotarBindingsLocales: No es id. de variable </>}, nodo ]
            finsi
            devolver NULO
        finsi
        si ContieneYoImplícito: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocal}, (bindings#contiene: (NombreResueltoDelYoImplícito: nodo))
        finsi
        si (EsInstancia: nodo, AST#NodoFunciónAnónima) || (EsInstancia: nodo, AST#NodoPrograma)
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            %recur: nodo#nombre
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMétodo
            %recur: nodo#deClase
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Marca todas las variables que son locales directas.}

Un uso de una variable cuenta como "uso local directo" si sucede dentro de la
misma función en la que la variable fue declarada. Este procedimiento marca
todos los @pd{AST#NodoIdentificador} con el metadato @code{esLocalDirecta}
(llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un @pd{Boole} indicando si este
identificador es un uso local directo.
DOCUMENTA]
procedimiento MarcaVariablesLocalesEnSubámbitos: ast
    Caminar': ast, procedimiento: nodo, K
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si (EsInstancia: nodo, AST#NodoFunción)
        || (EsInstancia: nodo, AST#NodoFunciónAnónima)
        || (EsInstancia: nodo, AST#NodoMétodo)
        || (EsInstancia: nodo, AST#NodoPrograma)
        || (ContieneYoImplícito: nodo)
            variables bindings, locales, localesReales, nombre, deClase
            fijar bindings a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}
            fijar locales a nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
            fijar localesReales a Filtrar: (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelNodo'}),
                                           funcion: local
                                               devolver local#profundidad = (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad})
                                           finfuncion

            [ localesReales contiene las variables declaradas directamente en
              `nodo`, mientras que `locales` y `bindings` contienen las locales
              y bindings de `nodo` y todos sus subámbitos excepto
              funciones/métodos/procedimientos. ]

            si EsInstancia: nodo, AST#NodoFunción
                fijar nombre a nodo#nombre
            sino
                fijar nombre a NULO
            finsi
            si EsInstancia: nodo, AST#NodoMétodo
                fijar deClase a nodo#deClase
            sino
                fijar deClase a NULO
            finsi

            variables bindingsDeEsteÁmbito, localesDeEsteÁmbito
            fijar bindingsDeEsteÁmbito a Conjunto#desdeArreglo: (Mapear: localesReales, (MétodoComoFunción: {binding}))
            fijar localesDeEsteÁmbito a Filtrar: locales, funcion: local
                devolver bindingsDeEsteÁmbito#contiene: local#binding
            finfuncion

            si ContieneYoImplícito: nodo
                nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEsLocalDirecta}, (bindingsDeEsteÁmbito#contiene: (NombreResueltoDelYoImplícito: nodo))
            finsi

            procedimiento marcarSubidentificadores: nodo
                Caminar: nodo, funcion: nodo
                    devolver (DebeIgnorarElNodo: nodo)
                          || (   (no Defun#SonElMismoObjeto: nodo, nombre)
                              && (no Defun#SonElMismoObjeto: nodo, deClase)
                              && (   (EsInstancia: nodo, AST#NodoIdentificador)
                                  || (EsInstancia: nodo, AST#NodoFunción)
                                  || (EsInstancia: nodo, AST#NodoMétodo)
                                  || (EsInstancia: nodo, AST#NodoFunciónAnónima)
                                  || (EsInstancia: nodo, AST#NodoPrograma)))
                finfuncion, procedimiento: nodo, subrecur
                    si DebeIgnorarElNodo: nodo
                        devolver NULO
                    finsi
                    si EsInstancia: nodo, AST#NodoFunción
                        %subrecur: nodo#nombre
                        MarcaVariablesLocalesEnSubámbitos: nodo
                        devolver NULO
                    finsi
                    si EsInstancia: nodo, AST#NodoMétodo
                        %subrecur: nodo#deClase
                        MarcaVariablesLocalesEnSubámbitos: nodo
                        devolver NULO
                    finsi
                    si (EsInstancia: nodo, AST#NodoPrograma) || (EsInstancia: nodo, AST#NodoFunciónAnónima)
                        devolver MarcaVariablesLocalesEnSubámbitos: nodo
                    finsi
                    si EsInstancia: nodo, AST#NodoIdentificador
                        si EsIdentificadorDeVariable: nodo
                            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocalDirecta}, (bindingsDeEsteÁmbito#contiene: (RN#NombreResueltoDe: nodo))
                        sino
                            [ Escribir: {MarcaVariablesLocalesEnSubámbitos: No es id. de variable </>}, nodo ]
                        finsi
                    finsi
                finprocedimiento
            finprocedimiento

            devolver K#llamarConRecursión: nodo, &marcarSubidentificadores
        sino
            devolver %K: nodo
        finsi
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Marca todos los identificadores con un metadato indicando si deben
estar en el entorno o no.}

Le agrega el metadato @code{estáEnElEntorno} (llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) a todos los @pd{AST#NodoIdentificador}. Este
metadato es un @pd{Boole} que indica si este uso del identificador debe estar
en el entorno de la función o no.
DOCUMENTA]
procedimiento MarcaVariablesQueEstánEnElEntorno: ast
    funcion esLocal: local
        [ si EsInstancia: local, IdentificadorLocalDelProcedimiento ]
        [     Escribir: {! S:}, local#nodo ]
        [ sino ]
        [     Escribir: {! S:}, local#nodoConYo ]
        [ finsi ]
        si EsInstancia: local, IdentificadorLocalDelProcedimiento
            Escribir: {! L1:}, local#nodo#areaTextual
        sino
            Escribir: {! L2:}, local#nodoConYo#areaTextual
        finsi
        Escribir: {! B:}, local#binding
        Escribir: {ES}, (local#esCapturado || (no local#esLocal) || (no local#esLocalDirecta))
        si (no local#esCapturado)
            Escribir: {OJO}, (no local#esLocal), (no local#esLocalDirecta)
        finsi
        devolver local#esCapturado || (no local#esLocal) || (no local#esLocalDirecta)
    finfuncion
    Caminar': ast, procedimiento: nodo, recur
        si DebeIgnorarElNodo: nodo
            devolver NULO
        finsi
        si EsIdentificadorDeVariable: nodo
            Escribir: {^^^}, nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}, (esLocal: (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {local}))
            devolver NULO
        finsi
        si ContieneYoImplícito: nodo
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {yoEstáEnElEntorno}, (esLocal: (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localYo}))
        finsi
        devolver %recur: nodo
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Devuelve un boole indicando si @pd{nid} está en el entorno.}

Obtiene el metadato @code{estáEnElEntorno}.
DOCUMENTA]
funcion EstáEnElEntorno: nid
    [ Escribir: {# Q:}, nid ]
    [ Escribir: {ES}, (nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}) ]
    devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {estáEnElEntorno}
finfuncion


[ Fin de los minipases. Ahora comienza el backend "real": ]


[ Nombre código del backend. Véase también la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Tupla (IR) Bootstrap}

[ El IR:

  El IR esta compuesto de 3 "partes": las instrucciones, las declaraciones y
  las constantes. Se asume que el órden de las instrucciones importa pero el de
  las constantes y las declaraciones no.

  Las instrucciones consisten de un arreglo de "tuplas": cada tupla es como un
  arreglo de tamaño mayor a 1, donde el primer elemento es la instrucción u
  opcode y los demás elementos son los argumentos. Cada opcode requiere sus
  propios argumentos con tipos específicos.

  Las constantes son un diccionario de un CID ("constant-ID") a la constante
  dada. El IR solo puede representar constantes numéricas (como instancias de
  números), textuales (como instancias de textos) y "prototipos" (véase más
  abajo).

  Las declaraciones actualmente solo incluyen la declaración de función, la
  cual consiste del ID de la función, sus parámetros y las instrucciones de su
  cuerpo.

  Estas 3 partes están agrupadas en una estructura llamada `Compilado`. La
  operación más fundamental de un compilado es secuenciar (`A >> B`) pero
  también tienen otras.

Prototipos:

  Los prototipos son usados para realizar llamadas a funciones variadic. Son un
  tipo especial de constantes que indican la estructura de la pila al momento
  de llamar a una función.

  Cuando llamas a un procedimiento variadic, algunos elementos en la pila son
  argumentos posicionales normales y otros tienen que ser expandidos. Por
  ejemplo, en la llamada `Hola: 1, ...2, 3, 4, ...5` los argumentos `1`, `3` y
  `4` son normales y `2` y `5` tienen que ser expandidos.

  Debido a que la pila siempre debe tener una estructura estática (más abajo
  explico por qué) no podemos simplemente "expandir" los argumentos variadic
  directamente en la pila. En cambio, mantenemos todos los argumentos como si
  ninguno fuese variadic (de forma que la pila contendrá los valores `1 2 3 4
  5`) y creamos un *prototipo* `0 1 0 0 1` que indica cuales argumentos son
  variadic (en este caso, solo el segundo y el último).

  Los prototipos son un tipo de constante: esto permite al backend-del-backend
  (el que compila el IR, llamado *lowerer* en inglés ya que "baja" el IR de su
  nivel intermedio al código final de bajo nivel) compilar y analizar de forma
  estática y eficiente estas llamadas variadic.

Semanticas:

  El IR tiene un número ilimitado de registros o variables locales (o solo
  "locales") por cada marco de activación de cada función. También tiene una
  pila que es compartida entre marcos de activación: cada función debe tener
  cuidado de mantener la pila en un estado apropiado (las funciones no pueden
  leer los elementos de la pila que fueron agregados antes de entrar a
  esta). Finalmente, una última pila, la pila de ámbitos, es usada para
  compilar `si`-`finsi` y `mientras`-`finmientras`. A diferencia de la pila
  general, esta segunda pila no es compartida por los marcos de activación lo
  que significa que no es importante asegurarse de que esté en un estado válido
  al final de la función.

  Todo esto hace que el IR sea bastante fácil de usar: variables e
  instrucciones pueden usar directamente los registros mientras que las
  expresiones utilizan la pila para guardar los valores intermediarios. Nota
  que la pila no es completamente dinámica: debido a que todas las operaciones
  tienen un "efecto" estático en la pila y el compilador tiene cuidado de que
  las partes dinámicas (como los condicionales o bucles) siempre tengan la pila
  en un estado determinado al principio y final de estos, es posible (en
  teoría) determinar estáticamente el número de elementos en la pila. Esto es
  importante porque es posible que los pases posteriores del compilador
  "desapilen" el código eliminando la pila y convirtiendo todo el código a
  registros. (Nada de esto esta implementado, pero es fundamental para que la
  máquina virtual tenga un buen rendimiento en un futuro. Creo que también
  tendré que agregar algunas anotaciones en los puntos de control de flujo para
  hacer este proceso más fácil.)

  La regla más importante al usar la pila es que al principio de todos los
  bloques básicos la pila siempre debe estar en el mismo estado
  irrelevantemente de cual salto llevó a dicho bloque.

  Finalmente: exísten algunos opcodes para saltar tanto como incondicional como
  condicionalmente. Todos están intencionalmente hechos para que los únicos
  objetivos de un salto sean etiquetas. Por ejemplo, en vez de una instrucción
  "salta si es falso" `BR <etiqueta>` hay una "salta de acuerdo a una
  condición" `CHOOSE <siVerdadero>, <siFalso>`. Gracias a esto es posible
  convertir el IR a un grafo de bloques básicos y todos los bloques con bordes
  entrantes comenzarán con una etiqueta.

  Los tipos de objetos manejados por el IR son, en su mayoría, los mismos que
  los builtins de PseudoD: números, textos y booleanos. Además, 2 tipos
  adicionales (objetos y closures) son utilizados para implementar los
  demás. Tal como el intérprete, todos los objetos en la VM son "reales":
  puedes enviar mensajes a números o closures sin problemas.

  Las closures están implementadas como un puntero a una función y un
  entorno. Los objetos son como funciones pero su puntero a función apunta a la
  función que recibirá los mensajes y su entorno contiene los atributos del
  objeto.

  Un entorno consiste de un puntero a un entorno "superior" y una lista de
  registros almacenados. Los entornos son usados para implementar closures y
  objetos. Puedes crear un entorno con las instrucciones del "marco" (*frame
  instructions*, se llaman así porque siempre aparecen al principio de las
  funciones, "reificando" los marcos de activación). Para acceder a un valor en
  un entorno necesitas una altura (el número de entornos a "saltar" desde el
  actual) y un índice (el objeto dentro del entorno seleccionado a acceder).

  Los registros especiales `ESUP` y `EACT` representan el entorno "superior" al
  actual y el entorno actual, respectivamente. `EACT` tiene que ser
  inicializado manualmente. `ESUP` es el entorno pasado a esta función de forma
  implícita.

  Como durante la compilación cada ámbito pasa a ser un entorno, es necesario
  un sistema para prevenir que las variables `EACT` y `ESUP` se confundan (por
  ejemplo, si tienes un `si` dentro de un `mientras`, el `EACT` del mientras
  debe ser distínto del `EACT` del `si`). Para esto existe la pila de ámbitos:
  cada ámbito guarda sus entornos (`EACT`) en la pila de ámbitos usando las
  instrucciones `SPUSH` y `SPOP`.

Instrucciones:

  Los prefijos significan:

  1. `C`: Índice de una constante de la lista de constantes.
  2. `N`: Constante numérica.
  3. `F`: Constante real.
  4. `L`: Índice de registro local.
  5. `E`: Entorno: un registro local o alguna de las variables especiales
     `EACT` o `ESUP`.
  6. `U`: Número positivo (mayor o igual a 0).
  7. `T`: Etiqueta.
  8. `P`: ID de un procedimiento.
  9. `?`: Combinado con `E` o `L` indica que el argumento puede ser el valor
     especial `NIL`.

  SUM    {a b -- c}
  SUB    {a b -- c}
  MUL    {a b -- c}
  DIV    {a b -- c}
    Operaciones aritméticas básicas. Operan en la pila. Equivalentes a enviar
    los mensajes `operador_+`, `operador_-`, `operador_*` y `operador_/`.

  LT     {a b -- c}
  GT     {a b -- c}
  LE     {a b -- c}
  GE     {a b -- c}
  OPEQ   {a b -- c}
    Menor/mayor que, mayor/menor o igual a e igual a. Operan en la
    pila. Equivalentes a enviar los mensajes `operador_<`, `operador_>`,
    `operador_=<`, `operador_>=` y `operador_=`.

  SAME   {a b -- c}
    Determina si `a` y `b` son el mismo objeto.

  OBJATTR       {obj n -- x}
    Obtiene el atributo #`n` del objeto `obj`.

  OBJATTRSET    {obj n val --}
    Fija el atributo #`n` del objeto `obj` al valor `val`.

  OBJSZ         {obj -- n}
    Obtiene el número de atributos de un objeto.

  Las instrucciones `OBJATTR`, `OBJATTRSET` y `OBJSZ` también se pueden usar en
  closures. En ese caso manipulan las capturas del entorno del closure.

  OBJ2CLZ       {clz -- obj}
  CLZ2OBJ       {obj -- clz}
    Convierte un closure a un objeto y viceversa.

  POP    {a --}
    Saca e ignora el elemento en la cima de la pila.

  LCONST Cx    {-- a}
    Carga la constante con el índice `Cx` y la empuja en la pila.

    No puedes cargar cualquier constante, solo las numéricas y textuales.

  ICONST Na    {-- a}
  FCONST Fa    {-- a}
    Empuja una constante numérica.

  BCONST Na    {-- a}
    Empuja una constante booleana. Si `Na` es 1, empuja `VERDADERO`. Si es
    0 empuja `FALSO`.

  LOCAL Lx
    Declara un registro local. Solo puede estár al principio de una
    lista de instrucciones.

  PARAM Lx
    Declara un parámetro. `Lx` será el registro local que contenga al parámetro
    (`Lx` es declarado automáticamente, no es necesario declararlo de nuevo con
    `LOCAL`). Solo puede estar antes que `LOCAL` en un procedimiento.

  MKCLZ Ex, Px    {-- c}
  MK0CLZ Px    {-- c}
    Crea una closure mezclando un procedimiento (`Px`) y un entorno
    (`Ex`). `MK0CLZ` es como `MKCLZ` pero utiliza un entorno vacío.

  LSET Lx    {v --}
    Saca un elemento de la pila y lo asigna a la local `Lx`.

  LGET Lx    {-- v}
    Obtiene y empuja en la pila el valor de la local `Lx`.

  LSETC Ex, Ua, Ub    {v --}
    Saca un elemento de la pila y lo asigna a la variable dada del
    entorno. `Ex` es el entorno, `Ua` es la altura de la variable y `Ub` es el
    índice de la variable.

  LGETC Ex, Ua, Ub    {-- v}
    Obtiene la variable dada del entorno y empuja su valor en la pila. `Ex` es
    el entorno, `Ua` es la altura de la variable y `Ub` es el índice de la
    variable.

  ROT Ua
    Rota los primeros `Ua + 1` elementos en la cima de la pila. Por ejemplo si
    la pila tenía 4 elementos:

      <-----T
      A B C D

    (La flecha apunta a la base de la pila.)
    Entonces ejecutar `ROT 3` dejará la pila como:

      <-----T
      B C D A

    Esto es muy útil, por ejemplo, al compilar `obj#mensaje: 1, 2, 3`: el orden
    en el que compilan las partes de la expresión anterior es:

      <-------T
      obj 1 2 3

    Pero necesitamos `1 2 3 obj` para poder invocar el mensaje con `MSG`.

    (Puedes imaginar a este opcode como un "prepara para llamar a una
    función/método con `Ua` argumentos".)

  MSG Cx, Ua, Ub
    Saca un elemento, el objeto que recibirá el mensaje. Luego le envía a este
    el mensaje indicado por la constante `Cx`. Este mensaje es llamado con `Ua`
    argumentos y se espera que devuelva `Ub` resultados.

  DYNCALL Ua, Ub
    Envía el mensaje `llamar` al objeto en la cima de la pila. Similar a `MSG`.

  MSGV Cx, Cy, Ua, Ub
  DYNCALLV Cx, Ua, Ub
    Como `MSG` y `DYNCALL`, pero aceptan sus argumentos en su forma
    variadic. `Cx` es el índice de la constante que contiene el prototipo de la
    llamada. `Cy` es la constante con el mensaje a enviar. `Ua` y `Ub` tienen
    el mismo significado que en `MSG` y `DYNCALL`.

  RETN Ua
    Devuelve `Ua` objetos (que deben estar en la pila) del procedimiento
    actual.

  OPNFRM Ex, ?Ey, Ua    {--}
    Inicializa un entorno. El nuevo entorno es guardado en `Ex`. Si `Ey` es
    especificado será el entorno superior. `Ua` es el tamaño del entorno (es
    decir, el número de variables que contiene).

  ENEW Ex, Ua    {--}
    Inicializa una variable dentro del entorno. La variable en el índice `Ua`
    del entorno `Ex` será fijada a `NULO`.

  EINIT Ex, Ua, Ly    {--}
    Inicializa una variable dentro del entorno. La variable en el índice `Ua`
    del entorno `Ex` será fijada al valor del registro `Ly`.

  CLSFRM Ex    {--}
    "Cierra" un entorno. Luego de cerrarlo, no puedes usar `EINIT` o `ENEW` con
    `Ex`. En cambio, cualquier cambio al entorno tendrá que pasar por `LSETC`.

  Entre las instrucciones `OPNFRM` y `CLSFRM` solo pueden haber instrucciones
  `ENEW` y `EINIT`.

  NAME Tx
    Declara `Tx` como una etiqueta. `Tx` debe ser único en el procedimiento
    actual.

  CHOOSE Tx, Ty    {x --}
    Saca un elemento de la pila, si es verdadero salta a `Tx`, si no salta a
    `Ty`.

  JMP Tx    {--}
    Salta incondicionalmente a `Tx`.

  MTRUE    {x --}
    Saca un objeto de la pila y falla con un error si no es verdadero. Este
    opcode implementa la instrucción `necesitas`.

  CMPEQ     {a b -- c}
  CMPNEQ    {a b -- c}
    Compara si dos objetos de la pila son iguales/diferentes, empujando
    verdadero o falso. `CMPEQ` es equivalente al opcode `OPEQ`. `CMPNEQ` es
    equivalente a enviar el mensaje `operador_no=`.

  DYNMSG    {obj msj args -- r}
    Envía el mensaje `msj` al objeto `obj` con los argumentos `args` (un
    arreglo). A diferencia de `MSG`, siempre recibe 1 valor, el cual devuelve
    como `r`.

  NOT    {a -- b}
    Invierte el boole en la cima de la pila.

  PRN    {a --}
    Escribe el texto en la cima de la pila.

  NL    {--}
    Escribe el fin de línea.

  TODO: Documenta como SPUSH debe estar seguido de OPNFRM.

  SPUSH EACT, ESUP
  SPOP EACT, ESUP
    Empuja/saca y reorganiza `EACT`/`ESUP` en la pila de ámbitos. Luego de
    `SPUSH EACT, ESUP`, `EACT` estará en la pila de ámbitos y `EACT`/`ESUP`
    serán "rotados".

    TODO: Documenta estos opcodes.

    `SPOP EACT, ESUP` revierte esto, sacando y rotando de nuevo las variables.

  EX Un
    Saca `Un` valores de la pila y exportalos desde el módulo actual. Este
    opcode solo se puede usar al final de la sección de instrucciones de un
    módulo.

Ejemplo:

  En PseudoD:

    variable X
    funcion Y: v
        devolver (v + 4) * X
    finfuncion
    fijar X a 5
    escribir Y: 3
    nl

  En bytecode (más o menos):

    Instrucciones:
      LOCAL 3
      LOCAL 4
      OPNFRM EACT, NIL, 1
      EINIT EACT, 0, 3
      CLSFRM EACT
      MKCLZ EACT, 1
      LSET 4
      ICONST 5
      LSETC EACT, 0, 0
      LGET 4
      ICONST 3
      ROT 1
      DYNCALL 1, 1
      PRN
      NL

    Procedimientos:
      PROC 1
        PARAM 2
        OPNFRM EACT, ESUP, 0
        CLSFRM EACT
        LGET 2
        ICONST 4
        SUM
        LGETC EACT, 1, 0
        MUL
        RETN 1
      ENDPROC

    Constantes:
      (nada)

]

[DOCUMENTA
@brief{Variable local que contiene al entorno superior.}

Es la constante @code{ESUP} del bytecode.
DOCUMENTA]
funcion LocalDelEntornoSuperior
    devolver {ESUP}
finfuncion

[DOCUMENTA
@brief{Variable local que contiene al entorno actual.}

Es la constante @code{EACT} del bytecode.
DOCUMENTA]
funcion LocalDelEntornoActual
    devolver {EACT}
finfuncion


[DOCUMENTA
@brief{Una tupla de opcode y los argumentos.}

La tupla tiene más de un elemento: el primero siempre es el opcode, mientras
que los demás son los argumentos.
DOCUMENTA]
clase Tupla
    [DOCUMENTA
    @brief{El opcode de esta tupla.}
    DOCUMENTA]
    atributo opcode

    [DOCUMENTA
    @brief{Los argumentos de esta tupla.}

    Es un arreglo.
    DOCUMENTA]
    atributo argumentos

    [DOCUMENTA
    @brief{Crea una nueva tupla.}
    DOCUMENTA]
    metodo estatico crear: op, ...args

    [DOCUMENTA
    @brief{Determina si es o no un opcode específico.}

    Devuelve @pd{VERDADERO} o @pd{FALSO} dependiendo de si el opcode de esta
    tupla es @pd{op}.
    DOCUMENTA]
    metodo es: op

    [DOCUMENTA
    @brief{Obtiene un argumento de la tupla.}

    Devuelve el argumento número @pd{n} de esta tupla, contando desde 0.
    DOCUMENTA]
    metodo en: n

    [DOCUMENTA
    @brief{Devuelve una representación textual de la tupla.}
    DOCUMENTA]
    metodo comoTexto

    [DOCUMENTA
    @brief{Escribe la representación textual de la tupla en el IR.}

    @pd{puertoDeEscritura} es el puerto en el que la representación textual de
    la tupla será escrita.
    DOCUMENTA]
    metodo emitirComoIR: puertoDeEscritura
finclase

metodo estatico Tupla#crear: op, ...args
    variable inst
    fijar inst a yo#_crear
    fijar inst#opcode a op
    fijar inst#argumentos a args
    devolver inst
finmetodo

metodo Tupla#es: op
    devolver yo#opcode = op
finmetodo

metodo Tupla#en: n
    devolver yo#argumentos#en: n
finmetodo

metodo Tupla#comoTexto
    devolver {(Tupla ~t ~t)}#formatear:
        yo#opcode#nombre,
        (Unir:
         (Mapear: yo#argumentos, funcion: x
              devolver x#comoTexto
          finfuncion),
         {, })
finmetodo

metodo Tupla#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: yo#opcode#nombre
    ParaCadaElementoConÍndice: yo#argumentos, procedimiento: argumento, i
        si i > 0
            puertoDeEscritura#escribirTexto: {,}
        finsi
        puertoDeEscritura#escribirTexto: { }
        puertoDeEscritura#escribirTexto: argumento#comoTexto
    finprocedimiento
    puertoDeEscritura#escribirTexto: {~%}#formatear
finmetodo

[DOCUMENTA
@brief{Crea una enumeración con valores incrementales.}

Como @pd{Enum} pero los valores de las enumeraciones no son su nombre si no un
número que se va incrementando de 1 en 1. Por ejemplo:

@ejemplo|{
variable X
fijar X a EnumConValoresIncrementales: {X},
    {A}, {B}, {C}, {D}
necesitas X#A#valor = 0
necesitas X#B#valor = 1
necesitas X#C#valor = 2
necesitas X#D#valor = 3
}|
DOCUMENTA]
funcion EnumConValoresIncrementales: nombre, ...valores
    variable pares
    fijar pares a Diccionario#vacío
    ParaCadaElementoConÍndice: valores, procedimiento: valor, i
        pares#fijarEn: valor, i
    finprocedimiento
    devolver EnumConValores: nombre, ...(Aplanar: pares#comoArreglo)
finfuncion

[DOCUMENTA
@brief{Todos los opcodes del IR.}

Esta enumeración contiene todos los opcodes del bytecode. El valor de cada
enumerado es el "código" del opcode.

Como una conveniencia, los enumerados también tienen un método @code{bytecode}
como un alias de @code{valor} (por ejemplo, @pd{Opcode#SUM#bytecode} es igual
a @pd{Opcode#SUM#valor}).
DOCUMENTA]
variable Opcode
fijar Opcode a EnumConValoresIncrementales: {Opcode},
    {LOCAL},      [ LOCAL Lx  (Solo al principio de un procedimiento) ]
    {LCONST},     [ LCONST Cx ]
    {ICONST},     [ ICONST Ia ]
    {FCONST},     [ FCONST Fa ]
    {BCONST},     [ BCONST Ia ]
    {SUM},        [ SUM ]
    {SUB},        [ SUB ]
    {MUL},        [ MUL ]
    {DIV},        [ DIV ]
    {RETN},       [ RETN Ux ]
    {MKCLZ},      [ MKCLZ Ex, Px ]
    {MK0CLZ},     [ MK0CLZ Px ]
    {OPNFRM},     [ OPNFRM Ex, ?Ey, Ua ]
    {EINIT},      [ EINIT Ex, Ua, Lx ]
    {ENEW},       [ ENEW  ]
    {CLSFRM},     [ CLSFRM Ex ]
    {LSETC},      [ LSETC Ex, Ua, Ub ]
    {LGETC},      [ LGETC Ex, Ua, Ub ]
    {LSET},       [ LSET Lx ]
    {LGET},       [ LGET Lx ]
    {POP},        [ POP ]
    {CHOOSE},     [ CHOOSE Tx, Ty ]
    {JMP},        [ JMP Tx ]
    {NAME},       [ NAME Tx ]
    {MTRUE},      [ MTRUE ]
    {CMPEQ},      [ CMPEQ ]
    {CMPNEQ},     [ CMPNEQ ]
    {CMPREFEQ},   [ CMPREFEQ ]
    {NOT},        [ NOT ]
    {ROT},        [ ROT Ua ]
    {ROTM},       [ ROTM Ua ]
    {GT},         [ GT ]
    {LT},         [ LT ]
    {GE},         [ GE ]
    {LE},         [ LE ]
    {OPEQ},       [ OPEQ ]
    {CLZ2OBJ},    [ CLZ2OBJ ]
    {OBJ2CLZ},    [ OBJ2CLZ ]
    {TMSG},       [ TMSG Cx, Ua, Ub ]
    {MSG},        [ MSG Cx, Ua, Ub ]
    {TMSGV},      [ TMSGV Cx, Cy, Ub ]
    {MSGV},       [ MSGV Cx, Cy, Ub ]
    {TDYNMSG},    [ TDYNMSG Ua, Ub ]
    {DYNMSG},     [ DYNMSG Ua, Ub ]
    {TDYNMSGV},   [ TDYNMSGV Cx, Ub ]
    {DYNMSGV},    [ DYNMSGV Cx, Ub ]
    {PRN},        [ PRN ]
    {NL},         [ NL ]
    {OPNEXP},     [ OPNEXP Ua ]
    {CLSEXP},     [ CLSEXP ]
    {EXP},        [ EXP Ux, Bx ]
    {IMPORT},     [ IMPORT Cx ]
    {SAVEIMPORT}, [ SAVEIMPORT Cx ]
    {MODULE},     [ MODULE Cx ]
    {SPUSH},      [ SPUSH EACT, ESUP ]
    {SPOP},       [ SPOP EACT, ESUP ]
    {OBJTAG},     [ OBJTAG ]
    {OBJATTR},    [ OBJATTR ]
    {OBJATTRSET}, [ OBJATTRSET ]
    {OBJSZ},      [ OBJSZ ]
    {PRAGMA}      [ PRAGMA (Texto:Nombre de la pragma), argumentos... ]

metodo Opcode#bytecode
    devolver yo#valor
finmetodo

[ El objeto `OP` es un pequeño DSL para construir tuplas. `OP#SUM: 1, 2` es lo
  mismo que `Tupla#crear: Opcode#SUM, 1, 2` ]

variable OP
si VERDADERO
    clase I
        metodo metodoNoEncontrado: mensaje, argumentos
    finclase

    metodo I#metodoNoEncontrado: mensaje, argumentos
        devolver Tupla#crear: (EnviarMensaje: Opcode, mensaje), ...argumentos
    finmetodo

    fijar OP a I#crear
finsi

[DOCUMENTA
@brief{Compila los argumentos de una pragma al IR.}

Devuelve un texto que contiene a los argumentos de la pragma compilados. Cada
argumento puede ser un @pd{Texto}, en cuyo caso será escapado mediante
@pd{EscaparParaPDVM}, o un número, en cuyo caso será emitido tal cual.
DOCUMENTA]
funcion CompilarArgumentosParaPragmaDirectamente: argumentos
    funcion escapar: valor
        si EsInstancia: valor, Texto
            devolver {"~t"}#formatear: (EscaparParaPDVM: valor)
        sino
            devolver valor#comoTexto
        finsi
    finfuncion
    devolver Unir: (Mapear: argumentos, &escapar), {, }
finfuncion

[DOCUMENTA
@brief{Una pragma del IR.}

Cada pragma controla un aspecto especial sobre el código
compilado. Generalmente las pragmas se alma
DOCUMENTA]
clase Pragma
    atributo nombre
    atributo argumentos

    metodo estatico desdeTupla: tupla
    metodo estatico crear: nombre, ...argumentos

    metodo emitirComoIR: puertoDeEscritura
finclase

metodo estatico Pragma#desdeTupla: tupla
    devolver yo#crear: (tupla#en: 0), ...(PedazoDeArreglo: tupla#argumentos, 1, -1)
finmetodo

metodo Pragma#inicializar: nombre, ...argumentos
    fijar yo#nombre a nombre
    fijar yo#argumentos a argumentos
finmetodo

metodo Pragma#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {PRAGMA }
    puertoDeEscritura#escribirTexto: yo#nombre
    puertoDeEscritura#escribirTexto: { }
    puertoDeEscritura#escribirTexto: (CompilarArgumentosParaPragmaDirectamente: yo#argumentos)
    puertoDeEscritura#escribirTexto: {~%}#formatear
finmetodo

[DOCUMENTA
@brief{Declaración de función o procedimiento dentro del bytecode.}
DOCUMENTA]
clase DeclrFunción
    [DOCUMENTA
    @brief{Nombre de la función.}

    Debe ser un número único en el programa.
    DOCUMENTA]
    atributo nombre

    [DOCUMENTA
    @brief{Los parámetros de la función.}

    Un arreglo de números: cada número es el ID de un registro local que será
    un parámetro en la función.
    DOCUMENTA]
    atributo parámetros

    [DOCUMENTA
    @brief{El parámetro variadic de la función, o @pd{NULO}.}

    Si es @pd{NULO} entonces la función no es variadic. Si no es nulo entonces
    debe ser el ID del parámetro que será variadic.

    Recuerda que, a diferencia de los demás parámetros, el parámetro variadic
    debe ser declarado con @code{LOCAL} en el cuerpo de la función.
    DOCUMENTA]
    atributo parámetroVariadic

    [DOCUMENTA
    @brief{Pragmas de la función.}

    Un arreglo de @pd{Pragma}s.
    DOCUMENTA]
    atributo pragmas

    [DOCUMENTA
    @brief{Cuerpo de la función.}

    Un arreglo de tuplas.
    DOCUMENTA]
    atributo cuerpo

    [DOCUMENTA
    @brief{Crea una nueva declaración de función.}
    DOCUMENTA]
    metodo estatico crear: nombre, parámetros, parámVariadic, cuerpo

    [DOCUMENTA
    @brief{Devuelve una representación textual de la declaración.}
    DOCUMENTA]
    metodo comoTexto

    [DOCUMENTA
    @brief{Escribe la representación textual de la declaración en el IR.}

    @pd{puertoDeEscritura} es el puerto en el que la representación textual de
    la función será escrita.
    DOCUMENTA]
    metodo emitirComoIR: puertoDeEscritura
finclase

metodo estatico DeclrFunción#crear: nombre, parámetros, parámVariadic, cuerpo
    variable pragmasYCuerpo
    fijar pragmasYCuerpo a SepararArreglo: cuerpo, funcion: tupla devolver tupla#es: Opcode#PRAGMA finfuncion, cuerpo
    devolver clonar yo#_crear con
        nombre: nombre
        parámetros: parámetros
        parámetroVariadic: parámVariadic
        pragmas: (Mapear: pragmasYCuerpo#parteVerdadera, &(Pragma#desdeTupla))
        cuerpo: pragmasYCuerpo#parteFalsa
    finclonar
finmetodo

metodo DeclrFunción#comoTexto
    devolver {(DeclrFunción ~t con ~t (~t) es ~t / ~t)}#formatear:
        yo#nombre, yo#parámetros, yo#parámetroVariadic, yo#pragmas, yo#cuerpo
finmetodo

metodo DeclrFunción#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: ({PROC ~t~%}#formatear: yo#nombre)
    ParaCadaElemento: yo#parámetros, procedimiento: param
        puertoDeEscritura#escribirTexto: ({PARAM ~t~%}#formatear: param)
    finprocedimiento
    si no EsNulo: yo#parámetroVariadic
        puertoDeEscritura#escribirTexto: ({VARIADIC ~t~%}#formatear: yo#parámetroVariadic)
    finsi
    ParaCadaElemento: yo#pragmas, procedimiento: pragma
        pragma#emitirComoIR: puertoDeEscritura
    finprocedimiento
    ParaCadaElemento: yo#cuerpo, procedimiento: tupla
        tupla#emitirComoIR: puertoDeEscritura
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDPROC~%}#formatear
finmetodo

[DOCUMENTA
@brief{Un prototipo para una llamada variadic.}

Indica cuales valores en la pila deben ser "expandidos" antes de ser usados
como argumentos.
DOCUMENTA]
clase PrototipoDeLlamada
    [DOCUMENTA
    @brief{El prototipo.}

    Es un arreglo de valores booleanos. Si un valor es @pd{VERDADERO} entonces
    su argumento correspondiente en la pila es variadic y debe ser
    expandido. Si es @pd{FALSO} entonces es un argumento normal.
    DOCUMENTA]
    atributo prototipo

    [DOCUMENTA
    @brief{Crea un nuevo prototipo.}
    DOCUMENTA]
    metodo estatico crear: prototipo

    [DOCUMENTA
    @brief{Devuelve una representación textual del prototipo.}
    DOCUMENTA]
    metodo comoTexto

    metodo emitirComoIR: puertoDeEscritura
finclase

metodo PrototipoDeLlamada#inicializar: proto
    fijar yo#prototipo a proto
finmetodo

metodo PrototipoDeLlamada#comoTexto
    devolver {(PrototipoDeLlamada ~t)}#formatear: yo#prototipo
finmetodo

metodo PrototipoDeLlamada#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {PROTOTYPE }
    ParaCadaElementoConÍndice: yo#prototipo, procedimiento: x, i
        si i > 0
            puertoDeEscritura#escribirTexto: {, }
        finsi
        puertoDeEscritura#escribirTexto: (x#escojer: {1}, {0})
    finprocedimiento
    puertoDeEscritura#escribirTexto: {~%}#formatear
finmetodo

clase TextoDelIR
    atributo valor
    metodo emitirComoIR: puertoDeEscritura
finclase

metodo TextoDelIR#inicializar: valor
    fijar yo#valor a valor
finmetodo

metodo TextoDelIR#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {STRING "}
    puertoDeEscritura#escribirTexto: (EscaparParaPDVM: yo#valor)
    puertoDeEscritura#escribirTexto: {"~%}#formatear
finmetodo

metodo TextoDelIR#comoTexto
    devolver {(TextoDelIR "~t")}#formatear: (EscaparParaPDVM: yo#valor)
finmetodo


[DOCUMENTA
@brief{Una constante en el IR.}

Representa un mapeo de un ID de constante a la constante.

Aunque nada te lo prohibe, no deberías usar constantes para representar números
"pequeños" (menores a 2^32). Para estos usa el opcode @code{ICONST}.
DOCUMENTA]
clase Constante
    [DOCUMENTA
    @brief{Id de la constante.}
    DOCUMENTA]
    atributo id

    [DOCUMENTA
    @brief{Valor de la constante.}

    Puede ser un número, un texto o un @pd{PrototipoDeLlamada}.
    DOCUMENTA]
    atributo valor

    [DOCUMENTA
    @brief{Crea una nueva constante y la devuelve.}
    DOCUMENTA]
    metodo estatico crear: id, valor

    [DOCUMENTA
    @brief{Devuelve una representación textual del mapeo de la constante.}
    DOCUMENTA]
    metodo comoTexto

    metodo emitirComoIR: puertoDeEscritura
finclase

metodo estatico Constante#crear: id, valor
    devolver clonar yo#_crear con
        id: id
        valor: valor
    finclonar
finmetodo

metodo Constante#comoTexto
    devolver {(Constante#crear: ~t, ~t)}#formatear: yo#id, yo#valor
finmetodo

metodo Constante#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {#}
    puertoDeEscritura#escribirTexto: yo#id#comoTexto
    puertoDeEscritura#escribirTexto: { }
    yo#valor#emitirComoIR: puertoDeEscritura
finmetodo


[DOCUMENTA
@brief{Un fragmento de compilación.}

Un compilado representa un fragmento de la compilación. Contiene un arreglo de
instrucciones, una secuencia de declaraciones y una secuencia de constantes. El
orden de las declaraciones y constantes no importa, pero el de las
instrucciones sí.
DOCUMENTA]
clase Compilado
    [DOCUMENTA
    @brief{Arreglo de tuplas, que son las instrucciones de este compilado.}
    DOCUMENTA]
    atributo instrucciones

    [DOCUMENTA
    @brief{Arreglo de declaraciones.}

    Actualmente la única declaración válida es @pd{DeclrFunción}.
    DOCUMENTA]
    atributo declaraciones

    [DOCUMENTA
    @brief{Constantes de este compilado.}

    Arreglo de @pd{Constante}s.
    DOCUMENTA]
    atributo constantes

    [DOCUMENTA
    @brief{Crea un compilado con los datos dados.}
    DOCUMENTA]
    metodo estatico crear: instrucciones, declaraciones, constantes

    [DOCUMENTA
    @brief{Crea un compilado sin constantes ni declaraciones.}
    DOCUMENTA]
    metodo estatico deInstrucciónes: instrucciones

    [DOCUMENTA
    @brief{Crea un compilado sin instrucciones ni constantes.}
    DOCUMENTA]
    metodo estatico deDeclaraciones: declaraciones

    [DOCUMENTA
    @brief{Crea un compilado sin instrucciones ni declaraciones.}
    DOCUMENTA]
    metodo estatico deConstantes: constantes

    [DOCUMENTA
    @brief{Secuencia dos compilados.}

    Mezcla las declaraciones y constantes de los compilados @pd{yo} y
    @pd{otro}. Además, las instrucciones de @pd{yo} son concatenadas
    @bold{antes} que las de @pd{otro}.

    El resultado de esto es un nuevo compilado cuyas instrucciones son primero
    las de @pd{yo} y después las de @pd{otro}, con todo lo demás en un orden no
    especificado.
    DOCUMENTA]
    metodo \operador_>>\: otro

    [DOCUMENTA
    @brief{Devuelve el valor de la constante con ID @pd{idDeConstante}.}
    DOCUMENTA]
    metodo valorDeLaConstante: idDeConstante

    [DOCUMENTA
    @brief{Devuelve una representación textual del compilado.}
    DOCUMENTA]
    metodo comoTexto

    metodo emitirComoIR: puertoDeEscritura
finclase

metodo estatico Compilado#crear: i, d, c
    devolver clonar yo#_crear con
        instrucciones: i
        declaraciones: d
        constantes: c
    finclonar
finmetodo

metodo estatico Compilado#deInstrucciónes: i
    devolver Compilado#crear: i, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo estatico Compilado#deDeclaraciones: d
    devolver Compilado#crear: Arreglo#vacio, d, Arreglo#vacio
finmetodo

metodo estatico Compilado#deConstantes: c
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, c
finmetodo

metodo estatico Compilado#vacío
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo Compilado#operador_>>: otro
    devolver Compilado#crear:
        (Concatenar: yo#instrucciones, otro#instrucciones),
        (Concatenar: yo#declaraciones, otro#declaraciones),
        (Concatenar: yo#constantes, otro#constantes)
finmetodo

metodo Compilado#valorDeLaConstante: idDeConstante
    variable encontrados
    fijar encontrados a Filtrar: yo#constantes, funcion: const
        devolver const#id = idDeConstante
    finfuncion
    necesitas encontrados#longitud = 1
    devolver (encontrados#en: 0)#valor
finmetodo

metodo Compilado#comoTexto
    devolver {(Compilado ds = ~t, is = ~t, cs = ~t)}#formatear: yo#declaraciones, yo#instrucciones, yo#constantes
finmetodo

metodo Compilado#emitirComoIR: puertoDeEscritura
    puertoDeEscritura#escribirTexto: {PDVM 1.0~%}#formatear
    puertoDeEscritura#escribirTexto: {PLATFORM "pdcrt"~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "code"~%}#formatear
    ParaCadaElemento: yo#instrucciones, procedimiento: instr
        instr#emitirComoIR: puertoDeEscritura
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "procedures"~%}#formatear
    ParaCadaElemento: yo#declaraciones, procedimiento: declr
        declr#emitirComoIR: puertoDeEscritura
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%~%}#formatear

    puertoDeEscritura#escribirTexto: {SECTION "constant pool"~%}#formatear
    ParaCadaElemento: yo#constantes, procedimiento: constante
        constante#emitirComoIR: puertoDeEscritura
    finprocedimiento
    puertoDeEscritura#escribirTexto: {ENDSECTION~%}#formatear
finmetodo


[DOCUMENTA
@brief{Escribe una versión "descompilada" de un compilado.}

Escribe todos los datos de un compilado de forma "bonita", como si fuese un
"assembly listing" (de allí el nombre "listado").
DOCUMENTA]
procedimiento Listado: compilado
    Escribir: {===== Constants:}
    ParaCadaElementoConÍndice: compilado#constantes, procedimiento: const, i
        Escribir: ({#~t}#formatear: i), {}, ({~t => ~t}#formatear: const#id, const#valor)
    finprocedimiento
    Escribir: {===== Code:}
    ParaCadaElementoConÍndice: compilado#instrucciones, procedimiento: tupla, i
        Escribir: ({#~t}#formatear: i), {}, ({[~t] 	~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
    finprocedimiento
    Escribir: {===== Declr:}
    ParaCadaElementoConÍndice: compilado#declaraciones, procedimiento: declr, i
        necesitas EsInstancia: declr, DeclrFunción
        Escribir: ({#~t}#formatear: i), {proc}, declr#nombre
        ParaCadaElementoConÍndice: declr#parámetros, procedimiento: p, j
            Escribir: {}, {}, ({#~t}#formatear: j), p
        finprocedimiento
        Escribir: {}, ({VARIADIC ~t}#formatear: declr#parámetroVariadic)
        ParaCadaElementoConÍndice: declr#cuerpo, procedimiento: tupla, i
            Escribir: {}, ({#~t}#formatear: i), {}, ({[~t] 	~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
        finprocedimiento
        Escribir: {}, {end}
    finprocedimiento
finprocedimiento


[DOCUMENTA
@brief{Secuencia todos los compilados.}

@pd{partes} debe ser un arreglo de compilados que serán secuenciados con
@code{>>} en orden. Devuelve el resultado de secuenciarlos.
DOCUMENTA]
funcion UnirCompilados: partes
    devolver Reducir: Compilado#vacío, (OperadorBinario: {>>}), partes
finfuncion

[DOCUMENTA
@brief{Devuelve un compilado con las instrucciones dadas.}

El compilado no tendrá ni constantes ni declaraciones.
DOCUMENTA]
funcion Instrucciones: ...Is
    devolver Compilado#deInstrucciónes: Is
finfuncion


[DOCUMENTA
@brief{Obtiene los nombres definídos sin parámetros de una
función/método/procedimiento.}

Devuelve el valor del metadato @code{nombresDefinídosSinParámetros} (con llave
@pd{RN#LLAVE_RESOLUCIÓN_DE_NOMBRES}).
DOCUMENTA]
funcion NombresDefinídosSinParámetros: ast
    devolver ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSinParámetros}
finfuncion

[DOCUMENTA
@brief{Obtiene los nombres resueltos de los parámetros de un
método/función/procedimiento.}

@pd{ast} debe ser un @pd{AST#NodoFunción}, @pd{AST#NodoFunciónAnónima},
@pd{AST#NodoMétodo} o @pd{AST#NodoDefineMétodoEnClase}. Devuelve un arreglo con
los nombres resueltos de los parámetros (en orden), excluyendo el parámetro
variadic, si existe.
DOCUMENTA]
funcion NombresDeLosParámetrosNoVariadic: ast
    devolver Mapear:
        (Filtrar: ast#parámetros,
                  funcion: param
                      devolver no EsInstancia: param, AST#NodoVariadic
                  finfuncion),
        &(RN#NombreResueltoDe)
finfuncion

[DOCUMENTA
@brief{Devuelve el parámetro variadic, o @pd{NULO} si no hay ninguno.}

@pd{ast} debe ser un @pd{AST#NodoFunción}, @pd{AST#NodoFunciónAnónima},
@pd{AST#NodoMétodo} o @pd{AST#NodoDefineMétodoEnClase}. Devuelve el
@pd{AST#NodoVariadic} o @pd{NULO}.
DOCUMENTA]
funcion ParámetroVariadic: ast
    variable variadics
    fijar variadics a Filtrar: ast#parámetros, funcion: param
        devolver EsInstancia: param, AST#NodoVariadic
    finfuncion
    si variadics#longitud = 0
        devolver NULO
    sino
        necesitas variadics#longitud = 1
        devolver variadics#en: 0
    finsi
finfuncion


[DOCUMENTA
@brief{Obtiene las locales del procedimiento.}

A pesar de lo que su nombre indica, solo funciona con nodos con el metadato
@code{localesDelProcedimiento} (funciones, métodos, procedimientos y
@pd{AST#NodoPrograma}).
DOCUMENTA]
funcion LocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
finfuncion

[DOCUMENTA
@brief{Obtiene los bindings locales del procedimiento.}

Solo funciona con los mismos nodos que @pd{LocalesDelBloque}.
DOCUMENTA]
funcion BindingsLocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}
finfuncion

variable ContadorDeEtiquetas
fijar ContadorDeEtiquetas a 0
[DOCUMENTA
@brief{Devuelve una nueva etiqueta.}

Devuelve un número único que sirve como etiqueta para las instrucciones de
control de flujo (@code{JMP} y @code{CHOOSE}).
DOCUMENTA]
procedimiento GenerarEtiqueta
    fijar ContadorDeEtiquetas a ContadorDeEtiquetas + 1
    devolver ContadorDeEtiquetas
finprocedimiento

variable ContadorDeConstantes
fijar ContadorDeConstantes a 0
[DOCUMENTA
@brief{Devuelve un nuevo ID de constante.}

Devuelve un número único que sirve como ID de constante.
DOCUMENTA]
procedimiento GenerarIdDeConstante
    fijar ContadorDeConstantes a ContadorDeConstantes + 1
    devolver ContadorDeConstantes
finprocedimiento

variable ContadorDeProcedimientos
fijar ContadorDeProcedimientos a 0
[DOCUMENTA
@brief{Devuelve un nuevo ID para un procedimiento.}

Devuelve un número único que sirve como ID de un procedimiento.
DOCUMENTA]
procedimiento GenerarIdDeProcedimiento
    fijar ContadorDeProcedimientos a ContadorDeProcedimientos + 1
    devolver ContadorDeProcedimientos
finprocedimiento

[ TODO: Renombra todas las funciones de compilación de "WASM" a "Tuplas". ]

[DOCUMENTA
@brief{Compila un arreglo de instrucciones a un compilado.}

@pd{instrucciones} debe ser un arreglo de @pd{AST#NodoInstrucción}. Esta
función automaticamente se encarga de dejar la pila en un estado apropiado
cuando se encuentra a una expresión en una posición de instrucción.

@pd{builtins} debe ser un diccionario mapeando los nombres de los builtins de
este backend a sus nombres resueltos.
DOCUMENTA]
funcion CompilarBloqueAWasm: instrucciones, builtins
    variable res
    fijar res a Compilado#vacío
    ParaCadaElemento: instrucciones, procedimiento: instr
        fijar res a res >> (CompilarAWasm: instr, builtins)
        si EsInstancia: instr, AST#NodoExpresion
            fijar res a res >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#POP))
        finsi
    finprocedimiento
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila un identificador.}

@pd{ast} debe ser el @pd{AST#NodoIdentificador} que se obtendrá.

Devuelve un compilado que obtiene la variable @pd{ast} y la empuja en la pila.
DOCUMENTA]
funcion CompilarIdentificador: ast
    variables altura, índiceDeCaptura, op, binding
    fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    fijar binding a RN#NombreResueltoDe: ast
    si EstáEnElEntorno: ast
        fijar op a OP#LGETC: LocalDelEntornoActual, altura, índiceDeCaptura
    sino
        fijar op a OP#LGET: binding
    finsi
    devolver Compilado#deInstrucciónes: (Arreglo#crearCon: op)
finfuncion

[DOCUMENTA
@brief{Compila el fijar un identificador.}

@pd{ast} debe ser el @pd{AST#NodoIdentificador} que se fijará.

Devuelve un compilado que saca un valor de la pila y fija la variable @pd{ast}
a dicho valor.
DOCUMENTA]
funcion CompilarFijarIdentificador: ast
    variables altura, índiceDeCaptura, op, binding
    Escribir: {Fijar:}, ast
    fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    fijar binding a RN#NombreResueltoDe: ast
    si EstáEnElEntorno: ast
        fijar op a OP#LSETC: LocalDelEntornoActual, altura, índiceDeCaptura
    sino
        fijar op a OP#LSET: binding
    finsi
    devolver Compilado#deInstrucciónes: (Arreglo#crearCon: op)
finfuncion

[DOCUMENTA
@brief{Compila las declaraciones de las locales de un procedimiento.}

Devuelve un arreglo con todas las declaraciones @code{LOCAL} necesarias.

@params(
@defparam(locales){Arreglo de las variables locales (generado con
@pd{EnumeraciónDeLocalesDeProcedimiento}) del bloque.}

@defparam(parámetros){Los parámetros del método, función o procedimiento como
un arreglo de bindings. Si se esta compilando un bloque que no es uno de estos,
@pd{parámetros} debería ser un arreglo vacío. Este parámetro es necesario
porque los parámetros son locales pero no deberían estar declarados con
@code{LOCAL} (excepto el parámetro variadic que si debe ser declarado con
@code{LOCAL}).}

@defparam(localYo){El local de la declaración de la variable @pd{yo} implícita
en este método. Si no se esta compilando un método, debe ser @pd{NULO}.}
)
DOCUMENTA]
funcion CompilarLocales: locales, parámetros, localYo
    variable variadics
    fijar variadics a Filtrar: parámetros, funcion: param
        devolver EsInstancia: param, AST#NodoVariadic
    finfuncion
    necesitas (variadics#longitud = 0) || (variadics#longitud = 1)
    [ Escribir: {-=-} ]
    [ ParaCadaElemento: locales, procedimiento: local ]
    [     si local#estáEnElEntorno ]
    [         Escribir: {Está en el entorno:}, local ]
    [     finsi ]
    [ finprocedimiento ]
    [ Escribir: {---} ]
    funcion índiceDeCaptura: nodo
        variable nid
        si EsInstancia: nodo, AST#NodoVariadic
            fijar nid a nodo#interno
        sino
            fijar nid a nodo
        finsi
        devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    finfuncion
    variables índices, bindingYo
    fijar índices a (Mapear: parámetros, &índiceDeCaptura)
    si no EsNulo: localYo
        fijar bindingYo a localYo#binding
    sino
        fijar bindingYo a NULO
    finsi
    devolver
        Mapear:
            (Concatenar:
                (Únicos:
                    (Mapear: (Filtrar: locales,
                                    funcion: meta
                                        devolver (no meta#estáEnElEntorno) && (no Contiene: índices, meta#índiceDeCaptura) && (no meta#binding = bindingYo)
                                    finfuncion),
                             funcion: local
                                 devolver local#binding
                             finfuncion)),
                (Mapear: variadics, funcion: variadic
                    devolver RN#NombreResueltoDe: variadic#interno
                finfuncion)),
            funcion: registro
                devolver OP#LOCAL: registro
            finfuncion
finfuncion

[DOCUMENTA
@brief{Mapea un arreglo, manteniendo solo los valores únicos de una llave
dada.}

Mapea cada elemento de @pd{arr} con @pd{func}, pero solo mantiene elementos
para los que @pd{unicos} (una función de la forma @pd{%unicos: elemento})
devuelva un valor único. Por ejemplo:

@ejemplo|{
utilizar bepd/x/adhoc (ObjetoAdHoc)

funcion Usuario: nombre, id
    devolver ObjetoAdHoc: {nombre}, nombre, {id}, id
finfuncion

variable A
fijar A a Arreglo#crearCon:
    (Usuario: {Miguel}, 1),
    (Usuario: {María}, 2),
    (Usuario: {Miguel (otra cuenta)}, 1)
necesitas (MapearÚnicos: A,
                         funcion: usuario
                             devolver usuario#id
                         finfuncion,
                         funcion: usuario
                             devolver usuario#nombre
                         finfuncion)
          =
          (Arreglo#crearCon: {Miguel}, {María})
}|

DOCUMENTA]
funcion MapearÚnicos: arr, unicos, func
    variables res, llaves
    fijar res a Arreglo#vacio
    fijar llaves a Conjunto#vacío
    ParaCadaElemento: arr, procedimiento: el
        variable llave
        fijar llave a %unicos: el
        si no (llaves#contiene: llave)
            fijar llaves a llaves#unión: (Conjunto#conValores: llave)
            res#agregarAlFinal: (%func: el)
        finsi
    finprocedimiento
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila las instrucciones @code{OPNFRM}...@code{CLSFRM} de un bloque.}

Devuelve un arreglo de instrucciones que crea e inicializa el entorno del
bloque actual, asignándolo a @code{EACT} apropiadamente.

@params(
@defparam(capturas){Un arreglo con las variables locales (producidas por
@pd{EnumeraciónDeLocalesDeProcedimiento}) que son capturadas (su atributo
@code{#esCapturado} debe ser verdadero). Puedes obtener este arreglo con
@pd{VariablesLocalesCapturadas}.}

@defparam(localesEnElEntorno){Las locales del entorno, tal como fueron
devueltas por @pd{LocalesDelBloque}.}

@defparam(localesInmediatas){Arreglo con las locales inmediatas del bloque.}

@defparam(exísteMarcoSuperior){@pd{Boole} que indica si exíste
@code{ESUP}. Determina si el entorno tendrá marco superior.}

@defparam(profundidad){Profundidad en el programa en la que el ámbito se
encuentra.}
)
DOCUMENTA]
funcion CompilarEntornoDelÁmbito: parámetros, localesEnElEntorno, localesInmediatas, exísteMarcoSuperior, profundidad
    funcion índiceDeCaptura: nid
        devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    finfuncion

    variables ops, máximoÍndiceDeLocalEnElEntorno, localesSiSonParámetros, nrsParámetros
    fijar ops a Arreglo#vacio
    fijar máximoÍndiceDeLocalEnElEntorno a Reducir: -1, &Max, (Mapear: (Filtrar: localesInmediatas, &EstáEnElEntorno), &índiceDeCaptura)
    [ máximoÍndiceDeLocalEnElEntorno es el máximo ind. de los locales
      capturados, o -1 si no hay ninguno. De esta forma,
      máximoÍndiceDeLocalCapturado + 1 es el tamaño mínimo necesario para el
      marco de activación ("marco de llamada" o "call-frame") ]
    ops#agregarAlFinal: (OP#OPNFRM: LocalDelEntornoActual, (exísteMarcoSuperior#escojer: LocalDelEntornoSuperior, {NIL}), (máximoÍndiceDeLocalEnElEntorno + 1))
    fijar nrsParámetros a Mapear: parámetros, funcion: param
        si EsInstancia: param, AST#NodoVariadic
            devolver RN#NombreResueltoDe: param#interno
        sino
            devolver RN#NombreResueltoDe: param
        finsi
    finfuncion
    fijar localesSiSonParámetros a SepararArreglo: localesInmediatas, funcion: local
        devolver Contiene: nrsParámetros, (RN#NombreResueltoDe: local)
    finfuncion
    ops#agregarAlFinal: (MapearÚnicos: (Filtrar: localesSiSonParámetros#parteVerdadera, &EstáEnElEntorno),
                                       funcion: local
                                           devolver índiceDeCaptura: local
                                       finfuncion,
                                       funcion: local
                                           devolver OP#EINIT: LocalDelEntornoActual, (índiceDeCaptura: local), (RN#NombreResueltoDe: local)
                                       finfuncion)
    ops#agregarAlFinal: (MapearÚnicos: (Filtrar: localesSiSonParámetros#parteFalsa, &EstáEnElEntorno),
                                       funcion: local
                                           devolver índiceDeCaptura: local
                                       finfuncion,
                                       funcion: local
                                           devolver OP#ENEW: LocalDelEntornoActual, (índiceDeCaptura: local)
                                       finfuncion)
    ops#agregarAlFinal: (OP#CLSFRM: LocalDelEntornoActual)
    devolver ops
finfuncion

[DOCUMENTA
@brief{Filtra un arreglo de locales para obtener las capturas de un bloque.}

Devuelve un arreglo con las variables locales capturadas.
DOCUMENTA]
funcion VariablesLocalesCapturadas: locales
    devolver Únicos: (Filtrar: locales, (MétodoComoFunción: {esCapturado}))
finfuncion

[DOCUMENTA
@brief{Filtra un arreglo de locales para obtener las que están en el entorno.}

Devuelve un arreglo con las locales que están en el entorno de la
función/método/procedimiento.
DOCUMENTA]
funcion VariablesEnElEntorno: locales
    devolver Únicos: (Filtrar: locales, (MétodoComoFunción: {estáEnElEntorno}))
finfuncion

[DOCUMENTA
@brief{Compila los locales y el entorno de un bloque.}

Llama a @pd{CompilarLocales} y @pd{CompilarEntornoDelÁmbito}, acumulando sus
resultados. Devuelve un arreglo de instrucciones que sirve como "inicio" o
"preludio" de un bloque.
DOCUMENTA]
funcion CompilarLocalesYClosure: locales, localesEnElEntorno, localesInmediatas, parámetros, exísteMarcoSuperior, profundidad, localYo
    devolver Concatenar:
        (CompilarLocales: locales, parámetros, localYo),
        (CompilarEntornoDelÁmbito: parámetros, localesEnElEntorno, localesInmediatas, exísteMarcoSuperior, profundidad)
finfuncion

[DOCUMENTA
@brief{Escribe dos valores pero devuelve uno.}

Escribe tanto @pd{A} como @pd{B} y devuelve @pd{B}.
DOCUMENTA]
funcion Inspeccionar: A, B
    Escribir: A, B
    devolver B
finfuncion

[DOCUMENTA
@brief{Compila los argumentos de una llamada a función.}

@pd{argumentos} es el arreglo con los @pd{AST#NodoExpresion}s a
compilar. @pd{compilarExpr} es una función que se llamará sobre cada argumento
para compilarlo.

Devuelve un objeto con los siguientes atributos:

@itemlist(

@item{@code{compilado}: el compilado del código que prepara la pila para la
llamada a la función.}

@item{@code{numValoresEnLaPila}: el número de valores que está en la pila antes
de llamar a la función. Dicho de otra forma: el número de valores que el
compilado devuelto empujo a la pila.}

@item{@code{variadics}: un booleano indicando si se debe realizar una llamada
variadic o no. Si es @pd{VERDADERO} debes usar los opcodes
@code{MSGV}/@code{DYNMSGV}/etc. Si es @pd{FALSO} debes usar los opcodes
@code{MSG}/@code{DYNMSG}/etc.}

@item{@code{prototipo}: Este atributo solo existe si @code{variadics} es
@pd{VERDADERO}. Es el índice de la constante que contiene al prototipo de la
llamada.}

)
DOCUMENTA]
funcion CompilarArgumentos: argumentos, compilarExpr
    variable bloques
    fijar bloques a Mapear: argumentos, funcion: arg
        si EsInstancia: arg, AST#NodoVariadic
            devolver ObjetoAdHoc: {variadic}, VERDADERO,
                                  {compilado}, (%compilarExpr: arg#interno)
        sino
            devolver ObjetoAdHoc: {variadic}, FALSO,
                                  {compilado}, (%compilarExpr: arg)
        finsi
    finfuncion

    variables compilado, prototipo, variadics
    fijar prototipo a PrototipoDeLlamada#crear: (Mapear: bloques, funcion: bloque
        devolver bloque#variadic
    finfuncion)
    fijar compilado a Reducir: Compilado#vacío, funcion: acc, bloque
        devolver acc >> bloque#compilado
    finfuncion, bloques
    fijar compilado a compilado >> (Instrucciones: (OP#ROT: argumentos#longitud))
    fijar variadics a Filtrar: argumentos, funcion: arg
        devolver EsInstancia: arg, AST#NodoVariadic
    finfuncion

    si variadics#longitud = 0
        devolver ObjetoAdHoc: {compilado}, compilado,
                              {variadics}, FALSO,
                              {numValoresEnLaPila}, argumentos#longitud
    sino
        devolver ObjetoAdHoc: {compilado}, compilado,
                              {variadics}, VERDADERO,
                              {numValoresEnLaPila}, argumentos#longitud,
                              {prototipo}, prototipo
    finsi
finfuncion

funcion CompilarLlamadaAFunción: argumentos, opLlamar, opLlamarVrd, numResultados, builtins
    variables argumentosCompilados, op
    fijar argumentosCompilados a CompilarArgumentos: argumentos, funcion: expr
        devolver CompilarAWasm: expr, builtins
    finfuncion
    si argumentosCompilados#variadics
        variable constPrototipo
        fijar constPrototipo a GenerarIdDeConstante
        fijar op a (%opLlamarVrd: argumentosCompilados#numValoresEnLaPila, constPrototipo, argumentosCompilados#prototipo, numResultados)
                >> (Compilado#deConstantes:
                        (Arreglo#crearCon:
                            (Constante#crear: constPrototipo, argumentosCompilados#prototipo)))
    sino
        fijar op a %opLlamar: argumentosCompilados#numValoresEnLaPila, numResultados
    finsi
    devolver argumentosCompilados#compilado >> op
finfuncion

[DOCUMENTA
@brief{Crea un compilado que agrega un atributo a una clase.}

@pd{compiladoParaObtenerClase} debe ser el compilado que empuja en la pila la
clase a la que se le agregará el atributo. @pd{nombreDelAtributo} es un
@pd{Texto} que es el nombre del atributo a agregar.
DOCUMENTA]
funcion CompilarAgregarAtributo: compiladoParaObtenerClase, nombreDelAtributo
    variables constAtributo, constAgregarAtributo
    fijar constAtributo a GenerarIdDeConstante
    fijar constAgregarAtributo a GenerarIdDeConstante
    devolver (Compilado#deConstantes:
                 (Arreglo#crearCon:
                     (Constante#crear: constAtributo, (TextoDelIR#crear: nombreDelAtributo)),
                     (Constante#crear: constAgregarAtributo, (TextoDelIR#crear: {agregarAtributo}))))
          >> compiladoParaObtenerClase
          >> (Instrucciones: (OP#LCONST: constAtributo),
                             (OP#ROT: 1),
                             (OP#MSG: constAgregarAtributo, 1, 0))
finfuncion


[DOCUMENTA
@brief{Obtiene todas las declaraciones de una lista de nodos.}

@devuelve{Aquellos nodos de @pd{nodos} que declaren algún nombre.}
DOCUMENTA]
funcion DeclaracionesEn: nodos
    variable DECLARACIONES
    fijar DECLARACIONES a Arreglo#crearCon:
        AST#NodoVariable, AST#NodoFunción, AST#NodoClase
    funcion esDeclaración: nodo
        devolver Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo))
    finfuncion
    devolver Filtrar: nodos, funcion: nodo devolver esDeclaración: nodo finfuncion
finfuncion

[DOCUMENTA
@brief{Obtiene los nombres declarados en todos los @pd{nodos}.}

@devuelve{Un arreglo con todos los nodos identificadores
(@pd{AST#NodoIdentificador}) que fueron declarados en @pd{nodos}.}
DOCUMENTA]
funcion NombresDeclaradosEn: nodos
    variable declrs
    fijar declrs a DeclaracionesEn: nodos
    devolver Aplanar: (Mapear: declrs, funcion: nodo
        si EsInstancia: nodo, AST#NodoVariable
            devolver nodo#nombres
        finsi
        si (EsInstancia: nodo, AST#NodoFunción) || (EsInstancia: nodo, AST#NodoClase)
            devolver Arreglo#crearCon: nodo#nombre
        finsi
        Inalcanzable
    finfuncion)
finfuncion

[DOCUMENTA
@brief{Compila una instrucción o expresión a un compilado.}

Devuelve un @pd{Compilado} con el resultado de compilar @pd{ast}. Si @pd{ast}
es un @pd{AST#NodoExpresion} entonces el compilado dejará en la pila el
resultado de la expresión. Si es un @pd{AST#NodoInstrucción} entonces no dejará
valores en la pila.
DOCUMENTA]
funcion CompilarAWasm: ast, builtins
    si EsInstancia: ast, AST#NodoPrograma
        variables locales, localesEnElEntorno, profundidad, localesInmediatas,
                  exportaciones, identificadoresDefinídos,
                  ámbito, constNombreDelMódulo, nombreDelMódulo
        fijar locales a LocalesDelBloque: ast
        fijar localesEnElEntorno a VariablesEnElEntorno: locales
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar localesInmediatas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}
        fijar exportaciones a Compilado#vacío
        fijar ámbito a RN#ObtenerNombresDefinídos: ast
        fijar identificadoresDefinídos a NombresDeclaradosEn: ast#instrucciones
        ParaCadaElementoConÍndice: identificadoresDefinídos, procedimiento: nid, índice
            variable esAutoejecutable
            Escribir: {$$$$$}, nid
            fijar esAutoejecutable a ámbito#esAutoejecutable: nid#nombre
            fijar exportaciones a exportaciones
                               >> (CompilarIdentificador: nid)
                               >> (Instrucciones: (OP#EXP: índice, (esAutoejecutable#escojer: 1, 0)))
        finprocedimiento
        fijar constNombreDelMódulo a GenerarIdDeConstante
        fijar nombreDelMódulo a (ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {llaveDelMódulo})#nombreCompletoDelArchivo
        devolver (Compilado#deInstrucciónes:
                     (Aplanar:
                         (CompilarLocalesYClosure: locales,
                                                   localesEnElEntorno,
                                                   localesInmediatas,
                                                   Arreglo#vacio,
                                                   FALSO,
                                                   profundidad,
                                                   NULO)))
              >> (Instrucciones: (OP#MODULE: constNombreDelMódulo))
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: constNombreDelMódulo, (TextoDelIR#crear: nombreDelMódulo))))
              >> (CompilarBloqueAWasm: ast#instrucciones, builtins)
              >> (Instrucciones: (OP#OPNEXP: identificadoresDefinídos#longitud))
              >> exportaciones
              >> (Instrucciones: OP#CLSEXP,
                                 (OP#RETN: 1))
    finsi
    si EsInstancia: ast, AST#NodoNumeroLiteral
        si EsNúmeroEntero: ast#valor
            devolver Instrucciones: (OP#ICONST: ast#valor)
        sino
            devolver Instrucciones: (OP#FCONST: ast#valor)
        finsi
    finsi
    si EsInstancia: ast, AST#NodoTextoLiteral
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (Instrucciones: (OP#LCONST: cid))
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: cid, (TextoDelIR#crear: ast#valor))))
    finsi
    si EsInstancia: ast, AST#NodoOperador
        variables lhs, rhs
        fijar lhs a CompilarAWasm: ast#lhs, builtins
        fijar rhs a CompilarAWasm: ast#rhs, builtins
        si ast#op#op = {+}
            devolver lhs >> rhs >> (Instrucciones: OP#SUM)
        finsi
        si ast#op#op = {-}
            devolver lhs >> rhs >> (Instrucciones: OP#SUB)
        finsi
        si ast#op#op = {*}
            devolver lhs >> rhs >> (Instrucciones: OP#MUL)
        finsi
        si ast#op#op = {/}
            devolver lhs >> rhs >> (Instrucciones: OP#DIV)
        finsi
        si ast#op#op = {=}
            devolver lhs >> rhs >> (Instrucciones: OP#OPEQ)
        finsi
        si ast#op#op = {<}
            devolver lhs >> rhs >> (Instrucciones: OP#LT)
        finsi
        si ast#op#op = {=<}
            devolver lhs >> rhs >> (Instrucciones: OP#LE)
        finsi
        si ast#op#op = {>}
            devolver lhs >> rhs >> (Instrucciones: OP#GT)
        finsi
        si ast#op#op = {>=}
            devolver lhs >> rhs >> (Instrucciones: OP#GE)
        finsi
        variables cid, optxt
        fijar cid a GenerarIdDeConstante
        fijar optxt a {operador_}#concatenar: ast#op#op
        devolver (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: cid, (TextoDelIR#crear: optxt))))
              >> lhs >> rhs
              >> (Instrucciones: (OP#ROT: 1),
                                 (OP#MSG: cid, 2, 1))
    finsi
    si EsInstancia: ast, AST#NodoIdentificador
        si (RN#NombreResueltoDe: ast) = (builtins#en: {__EACT})
            devolver Instrucciones: (OP#LGET: LocalDelEntornoActual)
        sino
            variable res
            fijar res a CompilarIdentificador: ast
            si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
                variable constLlamar
                fijar constLlamar a GenerarIdDeConstante
                fijar res a res >> (Instrucciones: (OP#MSG: constLlamar, 0, 1))
                                >> (Compilado#deConstantes:
                                       (Arreglo#crearCon:
                                           (Constante#crear: constLlamar, (TextoDelIR#crear: {llamar}))))
            finsi
            devolver res
        finsi
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        si ast#mensajes#longitud = 0
            devolver CompilarIdentificador: ast#base
        sino
            NoImplementado
        finsi
    finsi
    si EsInstancia: ast, AST#NodoEnviarMensaje
        si EsInstancia: ast#objeto, AST#NodoIdentificador
            si (RN#NombreResueltoDe: ast#objeto) = (builtins#en: {__Tupla})
                [ Si el mensaje comienza con `i`, es un opcode que no empuja nada
                  (`iPOP`, `iLSET`). Si por el contrario comienza con `e`, entonces
                  si empuja algo (`eLGET`, `eMKARR`). ]
                variable argumentos
                fijar argumentos a Mapear: ast#argumentos, funcion: arg
                    necesitas (EsInstancia: arg, AST#NodoTextoLiteral) || (EsInstancia: arg, AST#NodoNumeroLiteral)
                    devolver arg#valor
                finfuncion
                si (ast#mensaje#longitud > 1) && ((ast#mensaje#subTexto: 0, 1) = {i})
                    variable opcode
                    fijar opcode a ast#mensaje#subTexto: 1, (ast#mensaje#longitud - 1)
                    devolver Instrucciones: (__EnviarMensaje: OP, opcode, argumentos),
                                            [ Empujamos un valor cualquiera. Recuerda que todas
                                              las expresiones deben dejar un valor en la pila,
                                              pero este opcode no empuja nada. ]
                                            (OP#BCONST: 0)
                finsi
                si (ast#mensaje#longitud > 1) && ((ast#mensaje#subTexto: 0, 1) = {e})
                    variable opcode
                    fijar opcode a ast#mensaje#subTexto: 1, (ast#mensaje#longitud - 1)
                    devolver Instrucciones: (__EnviarMensaje: OP, opcode, argumentos)
                finsi
                si (ast#mensaje#longitud > {PRAGMA_}#longitud) && ((ast#mensaje#subTexto: 0, {PRAGMA_}#longitud) = {PRAGMA_})
                    variable pragma
                    fijar pragma a ast#mensaje#subTexto: {PRAGMA_}#longitud, (ast#mensaje#longitud - {PRAGMA_}#longitud)
                    devolver Instrucciones: (OP#PRAGMA: pragma, ...argumentos),
                                            (OP#BCONST: 0)
                finsi
                __FallarConMensaje: ({No se esperaba el mensaje a __Tupla: ~t}#formatear: ast#mensaje)
            finsi
        finsi
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (CompilarAWasm: ast#objeto, builtins)
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: cid, (TextoDelIR#crear: ast#mensaje))))
              >> (CompilarLlamadaAFunción:
                      ast#argumentos,
                      funcion: numValoresEnLaPila, numResultados
                          devolver Instrucciones: (OP#MSG: cid, numValoresEnLaPila, numResultados)
                      finfuncion,
                      funcion: numValoresEnLaPila, constPrototipo, prototipo, numResultados
                          devolver Instrucciones: (OP#MSGV: cid, constPrototipo, numResultados)
                      finfuncion,
                      1,
                      builtins)
    finsi
    si EsInstancia: ast, AST#NodoLlamarProcedimiento
        variable procnr
        fijar procnr a RN#NombreResueltoDe: ast#proc
        funcion ArgumentosCompilados
            devolver UnirCompilados: (Mapear: ast#argumentos, funcion: nodo
                         necesitas no EsInstancia: nodo, AST#NodoVariadic
                         devolver CompilarAWasm: nodo, builtins
                     finfuncion)
        finfuncion

        si procnr = (builtins#en: {__SonElMismoObjeto})
            necesitas ast#argumentos#longitud = 2
            devolver ArgumentosCompilados >> (Instrucciones: OP#CMPREFEQ)
        finsi
        si procnr = (builtins#en: {__ObtenerAtributo})
            necesitas ast#argumentos#longitud = 2
            devolver ArgumentosCompilados >> (Instrucciones: OP#OBJATTR)
        finsi
        si procnr = (builtins#en: {__FijarAtributo})
            necesitas ast#argumentos#longitud = 3
            devolver ArgumentosCompilados >> (Instrucciones: OP#OBJATTRSET, (OP#BCONST: 0))
        finsi
        si procnr = (builtins#en: {__NúmeroDeAtributos})
            necesitas ast#argumentos#longitud = 1
            devolver ArgumentosCompilados >> (Instrucciones: OP#OBJSZ)
        finsi
        si procnr = (builtins#en: {__CódigoDeObjeto})
            necesitas ast#argumentos#longitud = 1
            devolver ArgumentosCompilados >> (Instrucciones: OP#OBJ2CLZ)
        finsi
        si procnr = (builtins#en: {__EM})
            necesitas ast#argumentos#longitud = 3
            variables constPrototipo, prototipo
            fijar constPrototipo a GenerarIdDeConstante
            fijar prototipo a PrototipoDeLlamada#crear: (Arreglo#crearCon: VERDADERO)
            devolver ArgumentosCompilados
                  >> (Instrucciones: (OP#ROTM: 1),
                                     (OP#DYNMSGV: constPrototipo, 1))
                  >> (Compilado#deConstantes:
                         (Arreglo#crearCon:
                             (Constante#crear: constPrototipo, prototipo)))
        finsi

        variable constLlamar
        fijar constLlamar a GenerarIdDeConstante
        devolver (CompilarIdentificador: ast#proc)
              >> (CompilarLlamadaAFunción:
                     ast#argumentos,
                     funcion: numValoresEnLaPila, numResultados
                         devolver Instrucciones: (OP#MSG: constLlamar, numValoresEnLaPila, numResultados)
                     finfuncion,
                     funcion: numValoresEnLaPila, constPrototipo, prototipo, numResultados
                         devolver Instrucciones: (OP#MSGV: constLlamar, constPrototipo, numResultados)
                     finfuncion,
                     1,
                     builtins)
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: constLlamar, (TextoDelIR#crear: {llamar}))))
    finsi
    si EsInstancia: ast, AST#NodoAutoejecutar
        variable constLlamar
        fijar constLlamar a GenerarIdDeConstante
        devolver (CompilarAWasm: ast#expr, builtins)
              >> (CompilarLlamadaAFunción:
                     ast#argumentos,
                     funcion: numValoresEnLaPila, numResultados
                         devolver Instrucciones: (OP#MSG: constLlamar, numValoresEnLaPila, numResultados)
                     finfuncion,
                     funcion: numValoresEnLaPila, constPrototipo, prototipo, numResultados
                         devolver Instrucciones: (OP#MSGV: constLlamar, constPrototipo, numResultados)
                     finfuncion,
                     1,
                     builtins)
              >> (Compilado#deConstantes:
                     (Arreglo#crearCon:
                         (Constante#crear: constLlamar, (TextoDelIR#crear: {llamar}))))
    finsi
    si EsInstancia: ast, AST#NodoVariable
        devolver Compilado#vacío
    finsi
    si EsInstancia: ast, AST#NodoFijar
        si EsInstancia: ast#objetivo, AST#NodoEnviarMensaje
            necesitas ast#objetivo#argumentos#longitud = 0
            variable cid
            fijar cid a GenerarIdDeConstante
            devolver (CompilarAWasm: ast#objetivo#objeto, builtins)
                  >> (CompilarAWasm: ast#valor, builtins)
                  >> (Instrucciones: (OP#ROT: 1),
                                     (OP#MSG: cid, 1, 0))
                  >> (Compilado#deConstantes:
                         (Arreglo#crearCon:
                             (Constante#crear: cid, (TextoDelIR#crear: ({fijar_}#concatenar: ast#objetivo#mensaje)))))
        sino
            devolver (CompilarAWasm: ast#valor, builtins)
                  >> (CompilarFijarIdentificador: ast#objetivo)
        finsi
    finsi
    si EsInstancia: ast, AST#NodoSi
        variables etiqSi, etiqSino, etiqFinsi, localesEnElEntornoSiVerdadero,
                  localesEnElEntornoSiFalso, localesSiVerdadero, localesSiFalso,
                  localesInmediatasSiVerdadero, localesInmediatasSiFalso, profundidad
        fijar etiqSi a GenerarEtiqueta
        fijar etiqSino a GenerarEtiqueta
        fijar etiqFinsi a GenerarEtiqueta

        fijar localesSiVerdadero a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiVerdadero}
        fijar localesEnElEntornoSiVerdadero a VariablesEnElEntorno: localesSiVerdadero
        fijar localesSiFalso a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiFalso}
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar localesInmediatasSiVerdadero a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiVerdadero}
        fijar localesInmediatasSiFalso a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatasSiFalso}
        fijar localesEnElEntornoSiFalso a VariablesEnElEntorno: localesSiFalso

        devolver (CompilarAWasm: ast#condicional, builtins)
              >> (Instrucciones: (OP#CHOOSE: etiqSi, etiqSino),
                                 (OP#NAME: etiqSi),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntornoSiVerdadero, localesInmediatasSiVerdadero, VERDADERO, profundidad)))
              >> (CompilarBloqueAWasm: ast#siVerdadero, builtins)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqFinsi),
                                 (OP#NAME: etiqSino),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntornoSiFalso, localesInmediatasSiFalso, VERDADERO, profundidad)))
              >> (CompilarBloqueAWasm: ast#siFalso, builtins)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#NAME: etiqFinsi))
    finsi
    si EsInstancia: ast, AST#NodoMientras
        variables etiqInicio, etiqCont, etiqFinmientras, locales, localesEnElEntorno, localesInmediatas, nombresLibres, profundidad
        fijar etiqInicio a GenerarEtiqueta
        fijar etiqCont a GenerarEtiqueta
        fijar etiqFinmientras a GenerarEtiqueta

        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar locales a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelNodo}
        fijar localesInmediatas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}
        fijar localesEnElEntorno a VariablesEnElEntorno: locales

        devolver (Instrucciones: (OP#NAME: etiqInicio))
              >> (CompilarAWasm: ast#condicional, builtins)
              >> (Instrucciones: (OP#CHOOSE: etiqCont, etiqFinmientras),
                                 (OP#NAME: etiqCont),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: Arreglo#vacio, localesEnElEntorno, localesInmediatas, VERDADERO, profundidad)))
              >> (CompilarBloqueAWasm: ast#cuerpo, builtins)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqInicio),
                                 (OP#NAME: etiqFinmientras))
    finsi
    si EsInstancia: ast, AST#NodoNecesitas
        devolver (CompilarAWasm: ast#expresión, builtins)
              >> (Instrucciones: OP#MTRUE)
    finsi
    si EsInstancia: ast, AST#NodoDevolver
        devolver (CompilarAWasm: ast#expresión, builtins)
              >> (Instrucciones: (OP#RETN: 1))
    finsi
    si (EsInstancia: ast, AST#NodoFunción) || (EsInstancia: ast, AST#NodoFunciónAnónima) || (EsInstancia: ast, AST#NodoMétodo)
        variables nrsParámetros, parámetroVrd, preludio, cuerpo, fn,
                  nombresLibres, inicDeClosure, locales, localesEnElEntorno,
                  profundidad, localesInmediatas, procid, localYo, pragmas

        fijar preludio a Arreglo#vacio
        [ params ]
        fijar nrsParámetros a NombresDeLosParámetrosNoVariadic: ast
        fijar parámetroVrd a ParámetroVariadic: ast
        si no EsNulo: parámetroVrd
            fijar parámetroVrd a RN#NombreResueltoDe: parámetroVrd#interno
        finsi
        [ locales ]
        fijar locales a LocalesDelBloque: ast
        fijar localesEnElEntorno a VariablesEnElEntorno: locales
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar localesInmediatas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesInmediatas}
        fijar nombresLibres a NombresLibres: ast

        si ContieneYoImplícito: ast
            variable yos
            fijar yos a Filtrar: locales, funcion: local
                devolver (local#binding = NombreResueltoDelYoImplícito: ast) && (EsInstancia: local, YoLocalDelProcedimiento)
            finfuncion
            Escribir: {$$$$$$}, yos
            necesitas yos#longitud = 1
            fijar localYo a yos#en: 0
            fijar nrsParámetros a Concatenar: (Arreglo#crearCon: localYo#binding), nrsParámetros
        sino
            fijar localYo a NULO
        finsi

        fijar preludio a Concatenar: preludio, (CompilarLocalesYClosure: locales, localesEnElEntorno, localesInmediatas, ast#parámetros, VERDADERO, profundidad, localYo)

        fijar procid a GenerarIdDeProcedimiento
        fijar inicDeClosure a (Instrucciones: (OP#MKCLZ: LocalDelEntornoActual, procid))
        si EsInstancia: ast, AST#NodoFunción
            fijar inicDeClosure a inicDeClosure >> (CompilarFijarIdentificador: ast#nombre)
        finsi
        si EsInstancia: ast, AST#NodoMétodo
            variables constAgregarMétodo, agregarMétodo
            fijar constAgregarMétodo a GenerarIdDeConstante
            fijar agregarMétodo a ast#esEstático#escojer: {agregarMétodoEstático}, {agregarMétodo}
            fijar inicDeClosure a (CompilarIdentificador: ast#deClase)
                               >> inicDeClosure
                               >> (Instrucciones: (OP#ROT: 1),
                                                  (OP#MSG: constAgregarMétodo, 1, 0))
                               >> (Compilado#deConstantes:
                                      (Arreglo#crearCon:
                                          (Constante#crear: constAgregarMétodo, (TextoDelIR#crear: agregarMétodo))))
        finsi

        fijar cuerpo a (Compilado#deInstrucciónes: (Aplanar: preludio)) >> (CompilarBloqueAWasm: ast#cuerpo, builtins)

        fijar fn a DeclrFunción#crear: procid, nrsParámetros, parámetroVrd, cuerpo#instrucciones
        devolver inicDeClosure
             >> (Compilado#deDeclaraciones: cuerpo#declaraciones)
             >> (Compilado#deDeclaraciones: (Arreglo#crearCon: fn))
             >> (Compilado#deConstantes: cuerpo#constantes)
    finsi
    si EsInstancia: ast, AST#NodoSonIguales
        variable cmp
        si ast#tipoIgualdad = AST#TipoIgualdad#IGUALES
            fijar cmp a Instrucciones: OP#CMPEQ
        sino
            fijar cmp a Instrucciones: OP#CMPNEQ
        finsi
        devolver (CompilarAWasm: ast#lhs, builtins)
              >> (CompilarAWasm: ast#rhs, builtins)
              >> cmp
    finsi
    si EsInstancia: ast, AST#NodoNo
        devolver (CompilarAWasm: ast#expresión, builtins)
              >> (Instrucciones: OP#NOT)
    finsi
    si EsInstancia: ast, AST#NodoEscribir
        devolver (CompilarAWasm: ast#valor, builtins)
              >> (Instrucciones: OP#PRN)
    finsi
    si EsInstancia: ast, AST#NodoNl
        devolver Instrucciones: OP#NL
    finsi
    si EsInstancia: ast, AST#NodoClonar
        NoImplementado
    finsi
    si EsInstancia: ast, AST#NodoUtilizar
        NoImplementado
    finsi
    si EsInstancia: ast, AST#NodoClase
        variables constSubclase, constNombre, constFijarNombre, constantes, agregarAtributos
        fijar constSubclase a GenerarIdDeConstante
        fijar constNombre a GenerarIdDeConstante
        fijar constFijarNombre a GenerarIdDeConstante
        fijar constantes a Compilado#deConstantes:
            (Arreglo#crearCon:
                (Constante#crear: constSubclase, (TextoDelIR#crear: {subclase})),
                (Constante#crear: constNombre, (TextoDelIR#crear: ast#nombre#nombre)),
                (Constante#crear: constFijarNombre, (TextoDelIR#crear: {fijar_nombre})))
        si EsNulo: ast#claseBase
            NoImplementado
        finsi

        fijar agregarAtributos a
            UnirCompilados:
                (Mapear: (Filtrar: ast#declaraciones,
                                   funcion: D
                                       devolver EsInstancia: D, AST#NodoDeclaraciónDeAtributosEnClase
                                   finfuncion),
                         funcion: nodo
                             devolver UnirCompilados:
                                 (Mapear: nodo#nombres,
                                          funcion: nombre
                                              devolver CompilarAgregarAtributo: (CompilarIdentificador: ast#nombre), nombre#nombre
                                          finfuncion)
                         finfuncion)
        devolver constantes
              >> (CompilarAWasm: ast#claseBase, builtins)
              >> (Instrucciones: (OP#MSG: constSubclase, 0, 1))
              >> (CompilarFijarIdentificador: ast#nombre)
              >> (CompilarIdentificador: ast#nombre)
              >> (Instrucciones: (OP#LCONST: constNombre),
                                 (OP#ROT: 1),
                                 (OP#MSG: constFijarNombre, 1, 0))
              >> agregarAtributos
    finsi
    si EsInstancia: ast, AST#NodoAtributos
        variable deClase
        fijar deClase a CompilarAWasm: ast#deClase, builtins
        devolver (UnirCompilados:
                     (Mapear: ast#nombres,
                              funcion: nombre
                                  devolver CompilarAgregarAtributo: deClase, nombre#nombre
                              finfuncion))
    finsi

    Inalcanzable
finfuncion

[DOCUMENTA
@brief{Normaliza los IDs de las constantes de un compilado.}

El proceso de compilación puede generar muchas constantes duplicadas, esto pone
estrés en el backend que asume que las constantes son únicas. Esta función
devuelve un nuevo @pd{Compilado} que es como @pd{compilado}, pero no solo no
tiene constantes duplicadas, si no que también tiene "parches" que arreglan
todas las referencias ya existentes a constantes. El resultado es un compilado
que es semánticamente identico al original pero con menos constantes.
DOCUMENTA]
funcion NormalizaLosIdsDeConstantes: compilado
    variables constantes, índiceDeConstantes
    fijar constantes a Diccionario#vacío
    fijar índiceDeConstantes a 0

    procedimiento normalizarInstrucciones: instrs
        devolver Mapear: instrs, procedimiento: tupla
            si (tupla#es: Opcode#LCONST) || (tupla#es: Opcode#MSG) || (tupla#es: Opcode#MODULE)
                [ Tanto LCONST como MSG y los MODULE tienen su CID en el primer argumento. ]
                variables cid, cv, clon, cidReal
                fijar cid a tupla#en: 0
                fijar cv a compilado#valorDeLaConstante: cid
                fijar clon a clonar tupla con finclonar
                si no (constantes#contiene: cv)
                    fijar cidReal a índiceDeConstantes
                    constantes#fijarEn: cv, cidReal
                    fijar índiceDeConstantes a índiceDeConstantes + 1
                sino
                    fijar cidReal a constantes#en: cv
                finsi
                clon#argumentos#fijarEn: 0, cidReal [ <= parchea el CID ]
                devolver clon
            sino
                [ Ningun otro opcode tiene un CID. ]
                devolver tupla
            finsi
        finprocedimiento
    finprocedimiento

    variables nuevasInstrs, nuevasConstantes, nuevasDeclrs
    fijar nuevasInstrs a normalizarInstrucciones: compilado#instrucciones
    fijar nuevasDeclrs a Mapear: compilado#declaraciones, funcion: declr
        devolver clonar declr con
            cuerpo: normalizarInstrucciones: declr#cuerpo
        finclonar
    finfuncion
    fijar nuevasConstantes a Arreglo#vacio
    constantes#paraCadaPar: procedimiento: constv, cid
        nuevasConstantes#agregarAlFinal: (Constante#crear: cid, constv)
    finprocedimiento
    devolver Compilado#crear: nuevasInstrs, nuevasDeclrs, nuevasConstantes
finfuncion

[DOCUMENTA
@brief{Extráe los primeros elementos de @pd{arr} que satisfagan @pd{pred}.}

Por ejemplo:

@ejemplo|{
variable arr, res
funcion MenorA5: X
    devolver X < 5
finfuncion
fijar arr a Arreglo#crearCon: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -2, -3, -4
fijar res a ExtráeInicioMientras: arr, &MenorA5
necesitas res = (Arreglo#crearCon: 0, 1, 2, 3, 4)
}|
DOCUMENTA]
funcion ExtráeInicioMientras: arr, pred
    variable últimoÍndiceVálido
    fijar últimoÍndiceVálido a LlamarConEC: procedimiento: salir
        ParaCadaElementoConÍndice: arr, procedimiento: el, i
            si no %pred: el
                %salir: i
            finsi
        finprocedimiento
        %salir: arr#longitud
    finprocedimiento
    devolver PedazoDeArreglo: arr, 0, (últimoÍndiceVálido + 1)
finfuncion

[DOCUMENTA
@brief{Normaliza los IDs de las variables locales.}

Los índices de los registros locales en el IR deben ser "lineales": deben
comenzar en 0 y avanzar ascendentemente sin "huecos". Esta funcion toma
@pd{compilado} y normaliza todos los IDs de las variables locales para que
cumplan con esta condición.

Devuelve el nuevo compilado normalizado.
DOCUMENTA]
funcion NormalizaLosIdsDeLocales: compilado
    funcion normalizaLasLocales: parámetros, parámetroVariadic, instrucciones
        variables nuevasLocales, locales, nuevasInstrucciones, nuevosParámetros, nuevoParámetroVariadic, índiceLocal
        fijar nuevasLocales a Diccionario#vacío

        fijar índiceLocal a 0
        procedimiento generarÍndiceLocal
            variable res
            fijar res a índiceLocal
            fijar índiceLocal a índiceLocal + 1
            devolver res
        finprocedimiento

        fijar locales a Filtrar: instrucciones, funcion: tupla
            devolver tupla#es: Opcode#LOCAL
        finfuncion
        ParaCadaElementoConÍndice: parámetros, procedimiento: param, i
            nuevasLocales#fijarEn: param, generarÍndiceLocal
        finprocedimiento
        ParaCadaElementoConÍndice: locales, procedimiento: tupla, i
            nuevasLocales#fijarEn: (tupla#en: 0), generarÍndiceLocal
        finprocedimiento
        si no EsNulo: parámetroVariadic
            fijar nuevoParámetroVariadic a nuevasLocales#en: parámetroVariadic
        sino
            fijar nuevoParámetroVariadic a NULO
        finsi

        [ Estas locales nunca cambian, podría tener tres condicionales abajo
          pero creo que es más fácil simplemente agregarlas al diccionario. ]
        nuevasLocales#fijarEn: LocalDelEntornoActual, LocalDelEntornoActual
        nuevasLocales#fijarEn: LocalDelEntornoSuperior, LocalDelEntornoSuperior
        nuevasLocales#fijarEn: {NIL}, {NIL}

        fijar nuevasInstrucciones a Mapear: instrucciones, funcion: tupla
            [ Todos estos opcodes tienen su única referencia a una variable
              local en su primer argumento ]
            si (tupla#es: Opcode#LOCAL)
            || (tupla#es: Opcode#LSET)  || (tupla#es: Opcode#LGET)
            || (tupla#es: Opcode#LSETC) || (tupla#es: Opcode#LGETC)
            || (tupla#es: Opcode#MKCLZ) || (tupla#es: Opcode#CLSFRM)
            || (tupla#es: Opcode#ENEW)
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                devolver clon
            finsi
            si tupla#es: Opcode#OPNFRM
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                clon#argumentos#fijarEn: 1, (nuevasLocales#en: (clon#argumentos#en: 1))
                devolver clon
            finsi
            si tupla#es: Opcode#EINIT
                variable clon
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, (nuevasLocales#en: (clon#argumentos#en: 0))
                clon#argumentos#fijarEn: 2, (nuevasLocales#en: (clon#argumentos#en: 2))
                devolver clon
            finsi
            [ Los demás opcodes no tienen referencias a locales ]
            devolver tupla
        finfuncion
        fijar nuevosParámetros a Mapear: parámetros, &(nuevasLocales#en)

        devolver ObjetoAdHoc: {parámetros}, nuevosParámetros,
                              {parámetroVariadic}, nuevoParámetroVariadic,
                              {instrucciones}, nuevasInstrucciones
    finfuncion

    devolver Compilado#crear:
        (normalizaLasLocales: Arreglo#vacio, NULO, compilado#instrucciones)#instrucciones,
        (Mapear: compilado#declaraciones, funcion: declr
            variable parámetrosYCuerpo
            fijar parámetrosYCuerpo a normalizaLasLocales: declr#parámetros, declr#parámetroVariadic, declr#cuerpo
            devolver clonar declr con
                parámetros: parámetrosYCuerpo#parámetros
                parámetroVariadic: parámetrosYCuerpo#parámetroVariadic
                cuerpo: parámetrosYCuerpo#instrucciones
            finclonar
        finfuncion),
        compilado#constantes
finfuncion

[DOCUMENTA
@brief{Escapa un texto para que sea válido en la representación textual del
IR.}

El texto devuelto puede ser rodeado por comillas @code{""} y será una literal
textual válida del IR.
DOCUMENTA]
funcion EscaparParaPDVM: texto
    devolver MapearTexto: texto, funcion: car
        si car = {\}
            devolver {\\}
        finsi
        si car = {~q}#formatear
            devolver {\~q}#formatear
        finsi
        si car = {~%}#formatear
            devolver {\n}
        finsi
        devolver car
    finfuncion
finfuncion

[DOCUMENTA
@brief{Emite la representación textual de un compilado.}

Utiliza la sintaxis del ensamblador en vez de la otra representación usada por
@pd{Listado} que es más fácil de leer pero no puede ser compilada.

@pd{puertoDeEscritura} es el puerto de escritura en el cual se escribirá el
compilado.
DOCUMENTA]
procedimiento EmitirCompilado: compilado, puertoDeEscritura
    compilado#emitirComoIR: puertoDeEscritura
finprocedimiento

funcion ParsearYDefunc: programa
    variables ast, builtins, autoejecutables
    fijar ast a Parser#CrearAST: programa

    fijar builtins a Diccionario#desdePares:
        {__EACT}, RN#GenerarIdDeNombre,
        {__RT}, RN#GenerarIdDeNombre,
        {__Tupla}, RN#GenerarIdDeNombre,
        {__SonElMismoObjeto}, RN#GenerarIdDeNombre,
        {__ObtenerAtributo}, RN#GenerarIdDeNombre,
        {__FijarAtributo}, RN#GenerarIdDeNombre,
        {__NúmeroDeAtributos}, RN#GenerarIdDeNombre,
        {__EM}, RN#GenerarIdDeNombre,
        {__CódigoDeObjeto}, RN#GenerarIdDeNombre
    fijar autoejecutables a Arreglo#crearCon:
        {__SonElMismoObjeto}, {__ObtenerAtributo}, {__FijarAtributo},
        {__NúmeroDeAtributos}, {__CódigoDeObjeto}, {__EM}

    variable ámbitoPrincipal
    fijar ámbitoPrincipal a RN#ResolverNombres:
        ast,
        procedimiento: nombreDelMódulo
            Inalcanzable
        finprocedimiento,
        procedimiento: ámbito
            builtins#paraCadaPar: procedimiento: nombre, binding
                ámbito#agregar: nombre, binding
            finprocedimiento
            ParaCadaElemento: autoejecutables, procedimiento: nombre
                ámbito#marcarComoAutoejecutable: nombre
            finprocedimiento
        finprocedimiento,
        procedimiento: ámbito finprocedimiento
    Defun#Defuncionalizar: ast

    devolver ObjetoAdHoc: {ast}, ast, {builtins}, builtins
finfuncion

[DOCUMENTA
@brief{Anota el @pd{AST#NodoPrograma} con la llave del módulo.}

@pd{llave} debe ser la llave del módulo a usar. Este procedimiento anota
@bold{todos} los @pd{AST#NodoPrograma}s en el @pd{ast}, pero no anota aquellos
que estén dentro de otros @pd{AST#NodoPrograma}.
DOCUMENTA]
procedimiento AnotarElProgramaConSuLlaveDeMódulo: ast, llave
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoPrograma
    finfuncion, procedimiento: nodo
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {llaveDelMódulo}, llave
    finprocedimiento
finprocedimiento

[{

funcion Q
    2 * 3 - 20 / 4
finfuncion

funcion W: X, Y
    funcion J: K
        funcion Ñ: L
            L - K - X
        finfuncion
        K + X + Y
    finfuncion
    X + Y
finfuncion

variables X, Y, Z
fijar X a 4
fijar Y a X * 2 - Q * 2
fijar Z a Y * Y
Z / 2
Q

}]

variables ast, resP, programa, cc, llaveMod
Escribir: ({Leyendo: ~t}#formatear: (__Argv#en: 0))
Escribir: ({Escribiendo: ~t}#formatear: (__Argv#en: 1))
fijar programa a SistemaDeArchivos#LeerArchivo: (__Argv#en: 0)
fijar resP a ParsearYDefunc: programa
fijar ast a resP#ast
Escribir: {AnotarIdentificadoresTextuales}
AnotarIdentificadoresTextuales: ast
Escribir: {AnotaciónDeCapturas}
AnotaciónDeCapturas: ast
Escribir: {EnumeraciónDeCapturas}
EnumeraciónDeCapturas: ast, (EstadoDeEnumeraciónDeCapturas#desdeBuiltins: resP#builtins)
Escribir: {EnumeraciónDeLocalesDeProcedimiento}
EnumeraciónDeLocalesDeProcedimiento: ast, (RN#ObtenerNombresDefinídos: ast)
Escribir: {AnotarBindingsLocales}
AnotarBindingsLocales: ast
Escribir: {AnotarLocalesInmediatas}
AnotarLocalesInmediatas: ast
Escribir: {MarcaVariablesLocalesEnSubámbitos}
MarcaVariablesLocalesEnSubámbitos: ast
Escribir: {MarcaVariablesQueEstánEnElEntorno}
MarcaVariablesQueEstánEnElEntorno: ast
Escribir: {AnotarElProgramaConSuLlaveDeMódulo}
AnotarElProgramaConSuLlaveDeMódulo: ast, (Módulos#LlaveDeMódulo#crear: {./hola}, {ejemplo}, {pd})
Escribir: {CompilarAWasm}
fijar cc a CompilarAWasm: ast, resP#builtins
variable ncc
Escribir: {NormalizaLosIdsDeConstantes}
fijar ncc a NormalizaLosIdsDeConstantes: cc
Listado: ncc
Escribir: {====================}
variable ptesc
fijar ptesc a PDA#PuertoDeArchivoDeEscritura#abrir: (__Argv#en: 1)
EmitirCompilado: (NormalizaLosIdsDeLocales: ncc), ptesc
ptesc#cerrar
