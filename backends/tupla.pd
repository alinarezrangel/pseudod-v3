utilizar bepd/builtins
utilizar bepd/x/adhoc (ObjetoAdHoc)
utilizar bepd/datos/conjunto (Conjunto)
utilizar bepd/datos/diccionario (Diccionario)
utilizar bepd/x/puerto/conPosición (PosiciónTextual)
utilizar bepd/utilidades/texto
utilizar bepd/x/enum (Enum, EnumConValores)

utilizar tokens como Tokens
utilizar ast como AST
utilizar parser como Parser
utilizar resoluciónDeNombres como RN
utilizar defuncionalización como Defun



[ Pase de anotación de capturas

  Anota cada identificador en su punto de declaración con un metadato
  `capturado` (boole) que indica si el identificador fue capturado o no.

]

funcion Parcial: proc, ...argumentos
    devolver funcion: ...másArgumentos
        devolver %proc: ...argumentos, ...másArgumentos
    finfuncion
finfuncion

funcion MétodoComoFunción: ...args
    si args#longitud = 1
        devolver funcion: obj, ...resto
            devolver EnviarMensaje: obj, (args#en: 0), ...resto
        finfuncion
    sino
        necesitas args#longitud = 2
        devolver funcion: ...resto
            devolver EnviarMensaje: (args#en: 0), (args#en: 1), ...resto
        finfuncion
    finsi
finfuncion

funcion BinOp: op
    devolver funcion: lhs, rhs
        devolver EnviarMensaje: lhs, ({operador_}#concatenar: op), rhs
    finfuncion
finfuncion

funcion Únicos: arr
    devolver (Conjunto#desdeArreglo: arr)#comoArreglo
finfuncion


funcion Caminar: nodo, filtro, cuerpo
    si %filtro: nodo
        devolver %cuerpo: nodo, funcion: cont
            devolver Caminar: cont, filtro, cuerpo
        finfuncion
    finsi

    funcion recur: nodo
        devolver Caminar: nodo, filtro, cuerpo
    finfuncion

    si EsInstancia: nodo, AST#NodoPrograma
        devolver ParaCadaElemento: nodo#instrucciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoVariable
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFijar
        recur: nodo#objetivo
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoEscribir
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoNl
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoClase
        recur: nodo#nombre
        si no EsNulo: nodo#claseBase
            recur: nodo#claseBase
        finsi
        ParaCadaElemento: nodo#extiendeClases, &recur
        ParaCadaElemento: nodo#implementaClases, &recur
        devolver ParaCadaElemento: nodo#declaraciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#parámetros, &recur
    finsi
    si EsInstancia: nodo, AST#NodoImplementa
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#definiciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineMétodoEnClase
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunción
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoNecesitas
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoDevolver
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoSi
        recur: nodo#condicional
        ParaCadaElemento: nodo#siVerdadero, &recur
        devolver ParaCadaElemento: nodo#siFalso, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMientras
        recur: nodo#condicional
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMétodo
        si no EsNulo: nodo#deClase
            recur: nodo#deClase
        finsi
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoAtributos
        recur: nodo#deClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoUtilizar
        NoImplementado
    finsi

    si EsInstancia: nodo, AST#NodoIdentificador
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoNumeroLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoTextoLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoLlamarProcedimiento
        recur: nodo#proc
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoEnviarMensaje
        recur: nodo#objeto
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoOperador
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoNoLlamar
        devolver recur: nodo#base
    finsi
    si EsInstancia: nodo, AST#NodoAutoejecutar
        recur: nodo#expr
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunciónAnónima
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoSonIguales
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoReferenciar
        devolver recur: nodo#nombre
    finsi
    si EsInstancia: nodo, AST#NodoNo
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoClonar
        recur: nodo#expresiónAClonar
        devolver ParaCadaElemento: nodo#campos, funcion: campo
            devolver recur: (campo#en: 1)
        finfuncion
    finsi

    si EsInstancia: nodo, AST#NodoVariadic
        devolver recur: nodo#interno
    finsi

    [ Nunca se llega hasta aquí. ]
    Escribir: ({Caminar no implementado para ~t}#formatear: (TipoDe: nodo))
    Inalcanzable
finfuncion


clase LlaveAnotaciónDeCapturas
    metodo comoTexto
finclase

metodo LlaveAnotaciónDeCapturas#comoTexto
    devolver {LLAVE_ANOTACIÓN_DE_CAPTURAS}
finmetodo

variable LLAVE_ANOTACIÓN_DE_CAPTURAS
fijar LLAVE_ANOTACIÓN_DE_CAPTURAS a LlaveAnotaciónDeCapturas#crear

funcion NombresLibres: nodo
    si EsInstancia: nodo, AST#NodoPrograma
        devolver Arreglo#vacio
    sino
        devolver nodo#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres}
    finsi
finfuncion

procedimiento AnotaciónDeCapturas: ast
    variable nombresCapturadosAcc, nombresCapturados
    fijar nombresCapturadosAcc a Arreglo#vacio
    Caminar: ast, funcion: nodo
        variable declaraciones
        fijar declaraciones a Arreglo#crearCon:
            AST#NodoVariable, AST#NodoFunción, AST#NodoClase, AST#NodoMétodo, AST#NodoFunciónAnónima
        devolver Algún: (Mapear: declaraciones, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoFunción
            nombresCapturadosAcc#agregarAlFinal: (NombresLibres: nodo)
            ParaCadaElemento: nodo#cuerpo, procedimiento: cn
                devolver %recur: cn
            finprocedimiento
            devolver NULO
        finsi
    finprocedimiento
    fijar nombresCapturados a Reducir: Conjunto#vacío, (MétodoComoFunción: {unión}), nombresCapturadosAcc
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoIdentificador
    finfuncion, procedimiento: nodo, recur
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}, (nombresCapturados#contiene: (RN#NombreResueltoDe: nodo))
    finprocedimiento
finprocedimiento

procedimiento EnumeraciónDeLocalesDeProcedimiento: ast, obtenerMetadatosAdicionales
    variable locales
    fijar locales a Arreglo#vacio
    Caminar: ast, funcion: nodo
        devolver ((EsInstancia: nodo, AST#NodoIdentificador) || (EsInstancia: nodo, AST#NodoFunción))
    finfuncion, procedimiento: nodo, recur
        si (Defun#SonElMismoObjeto: nodo, ast) && (EsInstancia: nodo, AST#NodoFunción)
            ParaCadaElemento: nodo#parámetros, &(locales#agregarAlFinal)
            ParaCadaElemento: nodo#cuerpo, recur
            devolver NULO
        finsi
        si (no Defun#SonElMismoObjeto: nodo, ast) && (EsInstancia: nodo, AST#NodoFunción)
            locales#agregarAlFinal: nodo#nombre
            devolver EnumeraciónDeLocalesDeProcedimiento: nodo, obtenerMetadatosAdicionales
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            locales#agregarAlFinal: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}, (Conjunto#desdeArreglo: (Mapear: locales, &(RN#NombreResueltoDe)))
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}, (Mapear: locales, obtenerMetadatosAdicionales)
finprocedimiento

procedimiento EnumeraciónDeCapturas: ast, informaciónDeCapturas
    variables acc, DECLARACIONES, asoc
    fijar DECLARACIONES a Arreglo#crearCon: AST#NodoVariable, AST#NodoFunción, AST#NodoIdentificador
    fijar acc a 0
    fijar asoc a Diccionario#vacío

    procedimiento marcarÍndiceCapturaEnDeclaración: nid
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, 0
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, acc
        asoc#fijarEn: (RN#NombreResueltoDe: nid), acc
        fijar acc a acc + 1
    finprocedimiento

    funcion miInformaciónDeCapturas: nid
        si asoc#contiene: (RN#NombreResueltoDe: nid)
            devolver ObjetoAdHoc: {altura}, 0, {índiceDeCaptura}, (asoc#en: (RN#NombreResueltoDe: nid))
        sino
            variable dt
            fijar dt a %informaciónDeCapturas: nid
            devolver clonar dt con
                altura: dt#altura + 1
            finclonar
        finsi
    finfuncion

    funcion marcarÍndiceCapturaEnUso: nid
        variable dt
        fijar dt a miInformaciónDeCapturas: nid
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, dt#altura
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, dt#índiceDeCaptura
    finfuncion

    Caminar: ast, funcion: nodo
        devolver Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si (EsInstancia: nodo, AST#NodoFunción) && (Defun#SonElMismoObjeto: nodo, ast)
            ParaCadaElemento: nodo#parámetros, &marcarÍndiceCapturaEnDeclaración
            ParaCadaElemento: nodo#cuerpo, recur
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            ParaCadaElemento: nodo#nombres, &marcarÍndiceCapturaEnDeclaración
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            necesitas no Defun#SonElMismoObjeto: nodo, ast
            marcarÍndiceCapturaEnDeclaración: nodo#nombre
            EnumeraciónDeCapturas: nodo, &miInformaciónDeCapturas
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            marcarÍndiceCapturaEnUso: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento

    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {númeroDeCapturas}, acc
finprocedimiento

procedimiento AnotarÍndiceEnEntorno: ast, capturasAnteriores
    variables númeroDeCapturas, caps
    fijar númeroDeCapturas a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {númeroDeCapturas}
    fijar caps a clonar capturasAnteriores con finclonar
    caps#agregarAlFinal: númeroDeCapturas
    funcion obtenerÍndiceEnEntorno: nid
        variables altura, índice
        fijar altura a nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índice a nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        devolver (Reducir: 0, (BinOp: {+}), (PedazoDeArreglo: caps, 0, ((caps#longitud - altura) - 1))) + índice
    finfuncion
    procedimiento marcarÍndice: nid
        nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceEnEntorno}, (obtenerÍndiceEnEntorno: nid)
    finprocedimiento
    Caminar: ast, funcion: nodo
        devolver (no Defun#SonElMismoObjeto: nodo, ast) && ((EsInstancia: nodo, AST#NodoIdentificador) || (EsInstancia: nodo, AST#NodoFunción))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoIdentificador
            marcarÍndice: nodo
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            marcarÍndice: nodo#nombre
            AnotarÍndiceEnEntorno: nodo, caps
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento


[ Nombre código del backend. Véase también la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Tupla (IR) Bootstrap}

funcion NombreEnIR: identOBinding
    si EsInstancia: identOBinding, AST#NodoIdentificador
        fijar identOBinding a RN#NombreResueltoDe: identOBinding
    finsi
    devolver identOBinding
finfuncion

funcion LocalDelEntornoSuperior
    devolver {ESUP}
finfuncion

funcion LocalDelEntornoActual
    devolver {EACT}
finfuncion


clase Tupla
    atributos opcode, argumentos

    metodo estatico crear: op, ...args
    metodo es: op
    metodo en: n
    metodo comoTexto
finclase

metodo estatico Tupla#crear: op, ...args
    variable inst
    fijar inst a yo#_crear
    fijar inst#opcode a op
    fijar inst#argumentos a args
    devolver inst
finmetodo

metodo Tupla#es: op
    devolver yo#op = op
finmetodo

metodo Tupla#en: n
    devolver yo#argumentos#en: n
finmetodo

metodo Tupla#comoTexto
    devolver {(Tupla ~t ~t)}#formatear:
        yo#opcode#nombre,
        (Unir:
         (Mapear: yo#argumentos, funcion: x
              devolver x#comoTexto
          finfuncion),
         {, })
finmetodo

funcion EnumConValoresIncrementales: nombre, ...valores
    variable pares
    fijar pares a Diccionario#vacío
    ParaCadaElementoConÍndice: valores, procedimiento: valor, i
        pares#fijarEn: valor, i
    finprocedimiento
    devolver EnumConValores: nombre, ...(Aplanar: pares#comoArreglo)
finfuncion

variable Opcode
fijar Opcode a EnumConValoresIncrementales: {Opcode},
    {SUM},     [ SUM ]
    {SUB},     [ SUB ]
    {MUL},     [ MUL ]
    {DIV},     [ DIV ]
    {LT},      [ LT ]
    {GT},      [ GT ]
    {LE},      [ LE ]
    {GE},      [ GE ]
    {POP},     [ POP ]
    {LCONST},  [ LCONST Cx ]
    {ICONST},  [ ICONST Na ]
    {FCONST},  [ FCONST Fa ]
    {LOCAL},   [ LOCAL Lx  (Solo al principio de un procedimiento) ]
    {PARAM},   [ PARAM Lx  (Solo antes que LOCAL en un procedimiento) ]
    {MKCLZ},   [ MKCLZ Ex, Px ]
    {MK0CLZ},  [ MK0CLZ Px ]
    {LSET},    [ LSET Lx ]
    {LGET},    [ LGET Lx ]
    {EGET},    [ EGET Lx, Na ]
    {ESET},    [ ESET Lx, Na ]
    {LSETC},   [ LSETC Ex, Ua, Ub ]
    {LGETC},   [ LGETC Ex, Ua, Ub ]
    {ROT},     [ ROT Ua ]
    {DYNCALL}, [ DYNCALL Ua, Ub ]
    {RETN},    [ RETN Ua ]
    {EINIT},   [ EINIT Lx, Ua, Ly ]
    {OPNFRM},  [ OPNFRM Ex, ?Ey, Ly ]
    {CLSFRM},  [ CLSFRM Ex ]
    {CHOOSE},  [ CHOOSE Tx, Ty ]
    {JMP},     [ JMP Tx ]
    {NAME},    [ NAME Tx ]
    {MTRUE},   [ MTRUE ]
    {CMPEQ},   [ CMPEQ ]
    {CMPNEQ},  [ CMPNEQ ]
    {NOT},     [ NOT ]
    {MSG},     [ MSG Cx, Ua, Ub ]
    {PRN},     [ PRN ]
    {NL}       [ NL ]

metodo Opcode#bytecode
    devolver yo#valor
finmetodo

variable OP
si VERDADERO
    clase I
        metodo metodoNoEncontrado: mensaje, argumentos
    finclase

    metodo I#metodoNoEncontrado: mensaje, argumentos
        devolver Tupla#crear: (EnviarMensaje: Opcode, mensaje), ...argumentos
    finmetodo

    fijar OP a I#crear
finsi

clase DeclrFunción
    atributos nombre, parámetros, cuerpo
finclase

metodo estatico DeclrFunción#crear: nom, par, cuer
    devolver clonar yo#_crear con
        nombre: nom
        parámetros: par
        cuerpo: cuer
    finclonar
finmetodo

metodo DeclrFunción#comoTexto
    devolver {(DeclrFunción ~t con ~t es ~t)}#formatear: yo#nombre, yo#parámetros, yo#cuerpo
finmetodo

clase Constante
    atributos id, valor
finclase

metodo estatico Constante#crear: id, valor
    devolver clonar yo#_crear con
        id: id
        valor: valor
    finclonar
finmetodo

metodo Constante#comoTexto
    devolver {(Constante#crear: ~t, ~t)}#formatear: yo#id, yo#valor
finmetodo


clase Compilado
    atributos instrucciones, declaraciones, constantes
finclase

metodo estatico Compilado#crear: i, d, c
    devolver clonar yo#_crear con
        instrucciones: i
        declaraciones: d
        constantes: c
    finclonar
finmetodo

metodo estatico Compilado#deInstrucciónes: i
    devolver Compilado#crear: i, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo estatico Compilado#deDeclaraciones: d
    devolver Compilado#crear: Arreglo#vacio, d, Arreglo#vacio
finmetodo

metodo estatico Compilado#deConstantes: c
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, c
finmetodo

metodo estatico Compilado#vacío
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo Compilado#operador_>>: otro
    devolver Compilado#crear:
        (Concatenar: yo#instrucciones, otro#instrucciones),
        (Concatenar: yo#declaraciones, otro#declaraciones),
        (Concatenar: yo#constantes, otro#constantes)
finmetodo

metodo Compilado#comoTexto
    devolver {(Compilado ds = ~t, is = ~t, cs = ~t)}#formatear: yo#declaraciones, yo#instrucciones, yo#constantes
finmetodo


procedimiento Listado: compilado
    Escribir: {===== Constants:}
    ParaCadaElementoConÍndice: compilado#constantes, procedimiento: const, i
        Escribir: ({#~t}#formatear: i), {}, ({~t => ~t}#formatear: const#id, const#valor)
    finprocedimiento
    Escribir: {===== Code:}
    ParaCadaElementoConÍndice: compilado#instrucciones, procedimiento: tupla, i
        Escribir: ({#~t}#formatear: i), {}, ({[~t] ~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
    finprocedimiento
    Escribir: {===== Declr:}
    ParaCadaElementoConÍndice: compilado#declaraciones, procedimiento: declr, i
        necesitas EsInstancia: declr, DeclrFunción
        Escribir: ({#~t}#formatear: i), {proc}, declr#nombre
        ParaCadaElementoConÍndice: declr#parámetros, procedimiento: p, j
            Escribir: {}, {}, ({#~t}#formatear: j), p
        finprocedimiento
        ParaCadaElementoConÍndice: declr#cuerpo, procedimiento: tupla, i
            Escribir: {}, ({#~t}#formatear: i), {}, ({[~t] ~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
        finprocedimiento
        Escribir: {}, {end}
    finprocedimiento
finprocedimiento


funcion UnirCompilados: partes
    devolver Reducir: Compilado#vacío, (BinOp: {>>}), partes
finfuncion


funcion NombresDefinídosSinParámetros: ast
    devolver ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSinParámetros}
finfuncion

funcion NombresDeLosParámetros: ast
    devolver Mapear: ast#parámetros, &(RN#NombreResueltoDe)
finfuncion


funcion LocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
finfuncion

funcion RemapeosDelBloque: locales, nombresLibres
    variable i
    fijar i a 0
    devolver Diccionario#desdeArreglo: (Mapear: locales, funcion: metalocal
        variable nuevoBinding
        fijar nuevoBinding a i
        fijar i a i + 1
        devolver Arreglo#crearCon: (NombreEnIR: metalocal#binding), nuevoBinding
    finfuncion)
finfuncion

variable ContadorDeEtiquetas
fijar ContadorDeEtiquetas a 0
procedimiento GenerarEtiqueta
    fijar ContadorDeEtiquetas a ContadorDeEtiquetas + 1
    devolver ContadorDeEtiquetas
finprocedimiento

variable ContadorDeConstantes
fijar ContadorDeConstantes a 0
procedimiento GenerarIdDeConstante
    fijar ContadorDeConstantes a ContadorDeConstantes + 1
    devolver ContadorDeConstantes
finprocedimiento

funcion CompilarBloqueAWasm: instrucciones
    variable res
    fijar res a Compilado#vacío
    ParaCadaElemento: instrucciones, procedimiento: instr
        fijar res a res >> (CompilarAWasm: instr)
        si EsInstancia: instr, AST#NodoExpresion
            fijar res a res >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#POP))
        finsi
    finprocedimiento
    devolver res
finfuncion

funcion CompilarIdentificador: ast
    variables id, nombreIR, esCaptura, índiceEnEntorno, altura, índiceDeCaptura, res
    fijar nombreIR a NombreEnIR: ast
    fijar índiceEnEntorno a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceEnEntorno}
    fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    fijar esCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
    si esCaptura || (altura > 0)
        fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGETC: LocalDelEntornoActual, altura, índiceDeCaptura))
    sino
        fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGET: índiceDeCaptura))
    finsi
    devolver res
finfuncion

funcion CompilarLocalesYClosure: locales, capturas, parámetros, exísteMarcoSuperior
    variables preludio, máximoÍndiceDeLocalCapturado
    fijar preludio a Arreglo#vacio
    [ Inicializa las locales ]
    preludio#agregarAlFinal: (Mapear: (Únicos:
        (Filtrar: (Filtrar: locales, (MétodoComoFunción: {esLocal})), funcion: meta
            devolver no Contiene: parámetros, meta#índiceDeCaptura
        finfuncion)),
        funcion: metalocal
            devolver OP#LOCAL: metalocal#índiceDeCaptura
        finfuncion)
    [ Crea el entorno de este procedimiento ]
    fijar máximoÍndiceDeLocalCapturado a Reducir: -1, &Max, (Mapear: capturas, (MétodoComoFunción: {índiceDeCaptura}))
    [ máximoÍndiceDeLocalCapturado es el máximo ind. de los locales capturados,
      o -1 si no hay ninguno. De esta forma, máximoÍndiceDeLocalCapturado + 1
      es el tamaño mínimo necesario para el marco de activación ("marco de
      llamada" o "call-frame") ]
    preludio#agregarAlFinal: (OP#OPNFRM: LocalDelEntornoActual, (exísteMarcoSuperior#escojer: LocalDelEntornoSuperior, {NIL}), (máximoÍndiceDeLocalCapturado + 1))
    preludio#agregarAlFinal: (Mapear: capturas, funcion: metalocal
        devolver OP#EINIT: LocalDelEntornoActual, metalocal#índiceDeCaptura, metalocal#índiceDeCaptura
    finfuncion)
    preludio#agregarAlFinal: (OP#CLSFRM: LocalDelEntornoActual)
    devolver preludio
finfuncion

funcion Inspeccionar: A, B
    Escribir: A, B
    devolver B
finfuncion

funcion CompilarAWasm: ast
    funcion Instrucciones: ...Is
        devolver Compilado#deInstrucciónes: Is
    finfuncion

    si EsInstancia: ast, AST#NodoPrograma
        variables locales, capturas
        fijar locales a LocalesDelBloque: ast
        fijar capturas a Únicos: (Filtrar: locales, funcion: metalocal
            devolver metalocal#esLocal && metalocal#esCapturado
        finfuncion)
        devolver (Compilado#deInstrucciónes: (Aplanar: (CompilarLocalesYClosure: locales, capturas, Arreglo#vacio, FALSO)))
              >> (CompilarBloqueAWasm: ast#instrucciones)
    finsi
    si EsInstancia: ast, AST#NodoNumeroLiteral
        devolver Instrucciones: (OP#ICONST: ast#valor)
    finsi
    si EsInstancia: ast, AST#NodoTextoLiteral
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (Instrucciones: (OP#LCONST: cid))
              >> (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, ast#valor)))
    finsi
    si EsInstancia: ast, AST#NodoOperador
        variables lhs, rhs
        fijar lhs a CompilarAWasm: ast#lhs
        fijar rhs a CompilarAWasm: ast#rhs
        si ast#op#op = {+}
            devolver lhs >> rhs >> (Instrucciones: OP#SUM)
        finsi
        si ast#op#op = {-}
            devolver lhs >> rhs >> (Instrucciones: OP#SUB)
        finsi
        si ast#op#op = {*}
            devolver lhs >> rhs >> (Instrucciones: OP#MUL)
        finsi
        si ast#op#op = {/}
            devolver lhs >> rhs >> (Instrucciones: OP#DIV)
        finsi
        si ast#op#op = {<}
            devolver lhs >> rhs >> (Instrucciones: OP#LT)
        finsi
        si ast#op#op = {=<}
            devolver lhs >> rhs >> (Instrucciones: OP#LE)
        finsi
        si ast#op#op = {>}
            devolver lhs >> rhs >> (Instrucciones: OP#GT)
        finsi
        si ast#op#op = {>=}
            devolver lhs >> rhs >> (Instrucciones: OP#GE)
        finsi
        variables cid, optxt
        fijar cid a GenerarIdDeConstante
        fijar optxt a {operador_}#concatenar: ast#op#op
        devolver (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, optxt)))
              >> (Instrucciones: (OP#OP: cid))
    finsi
    si EsInstancia: ast, AST#NodoIdentificador
        variable res
        fijar res a CompilarIdentificador: ast
        si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
            fijar res a res >> (Instrucciones: (OP#DYNCALL: 0, 1))
        finsi
        devolver res
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        si ast#mensajes#longitud = 0
            devolver CompilarIdentificador: ast#base
        sino
            NoImplementado
        finsi
    finsi
    si EsInstancia: ast, AST#NodoEnviarMensaje
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (CompilarAWasm: ast#objeto)
              >> (UnirCompilados: (Mapear: ast#argumentos, &CompilarAWasm))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#MSG: cid, ast#argumentos#longitud, 1))
              >> (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, ast#mensaje)))
    finsi
    si EsInstancia: ast, AST#NodoLlamarProcedimiento
        devolver (CompilarIdentificador: ast#proc)
              >> (UnirCompilados: (Mapear: ast#argumentos, &CompilarAWasm))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#DYNCALL: ast#argumentos#longitud, 1))
    finsi
    si EsInstancia: ast, AST#NodoAutoejecutar
        devolver (CompilarAWasm: ast#expr)
              >> (UnirCompilados: (Mapear: ast#argumentos, &CompilarAWasm))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#DYNCALL: ast#argumentos#longitud, 1))
    finsi
    si EsInstancia: ast, AST#NodoVariable
        devolver Compilado#vacío
    finsi
    si EsInstancia: ast, AST#NodoFijar
        variables val, altura, índiceDeCaptura, op, esCaptura
        fijar altura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índiceDeCaptura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        fijar esCaptura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        si esCaptura || (altura > 0)
            fijar op a OP#LSETC: LocalDelEntornoActual, altura, índiceDeCaptura
        sino
            fijar op a OP#LSET: índiceDeCaptura
        finsi
        fijar val a CompilarAWasm: ast#valor
        devolver val >> (Instrucciones: op)
    finsi
    si EsInstancia: ast, AST#NodoSi
        variables etiqSi, etiqSino, etiqFinsi
        fijar etiqSi a GenerarEtiqueta
        fijar etiqSino a GenerarEtiqueta
        fijar etiqFinsi a GenerarEtiqueta
        devolver (CompilarAWasm: ast#condicional)
              >> (Instrucciones: (OP#CHOOSE: etiqSi, etiqSino),
                                 (OP#NAME: etiqSi))
              >> (CompilarBloqueAWasm: ast#siVerdadero)
              >> (Instrucciones: (OP#JMP: etiqFinsi),
                                 (OP#NAME: etiqSino))
              >> (CompilarBloqueAWasm: ast#siFalso)
              >> (Instrucciones: (OP#NAME: etiqFinsi))
    finsi
    si EsInstancia: ast, AST#NodoMientras
        variables etiqInicio, etiqCont, etiqFinmientras
        fijar etiqInicio a GenerarEtiqueta
        fijar etiqCont a GenerarEtiqueta
        fijar etiqFinmientras a GenerarEtiqueta
        devolver (Instrucciones: (OP#NAME: etiqInicio))
              >> (CompilarAWasm: ast#condicional)
              >> (Instrucciones: (OP#CHOOSE: etiqCont, etiqFinmientras),
                                 (OP#NAME: etiqCont))
              >> (CompilarBloqueAWasm: ast#cuerpo)
              >> (Instrucciones: (OP#JMP: etiqInicio),
                                 (OP#NAME: etiqFinmientras))
    finsi
    si EsInstancia: ast, AST#NodoNecesitas
        devolver (CompilarAWasm: ast#expresión) >> (Instrucciones: OP#MTRUE)
    finsi
    si EsInstancia: ast, AST#NodoDevolver
        devolver (CompilarAWasm: ast#expresión) >> (Instrucciones: (OP#RETN: 1))
    finsi
    si EsInstancia: ast, AST#NodoFunción
        variables id, parámetros, preludio, cuerpo, fn, remapeos, nombresLibres, inicDeClosure, locales, capturas
        fijar id a NombreEnIR: ast#nombre

        fijar preludio a Arreglo#vacio
        [ params ]
        fijar parámetros a Mapear: ast#parámetros, funcion: nid
            devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        finfuncion
        preludio#agregarAlFinal: (OP#PARAM: LocalDelEntornoSuperior)
        preludio#agregarAlFinal: (Mapear: parámetros, funcion: idx devolver OP#PARAM: idx finfuncion)
        [ locales ]
        fijar locales a LocalesDelBloque: ast
        fijar capturas a Únicos: (Filtrar: locales, funcion: metalocal
            devolver metalocal#esLocal && metalocal#esCapturado
        finfuncion)
        fijar preludio a Concatenar: preludio, (CompilarLocalesYClosure: locales, capturas, parámetros, VERDADERO)

        fijar nombresLibres a NombresLibres: ast
        fijar remapeos a RemapeosDelBloque: locales, nombresLibres

        fijar inicDeClosure a Instrucciones: (OP#MKCLZ: LocalDelEntornoActual, id)
        si (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado})
            fijar inicDeClosure a inicDeClosure >> (Instrucciones:
                (OP#LSETC:
                    LocalDelEntornoActual,
                    (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}),
                    (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura})))
        sino
            fijar inicDeClosure a inicDeClosure >> (Instrucciones:
                (OP#LSET: (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura})))
        finsi

        fijar cuerpo a (Compilado#deInstrucciónes: (Aplanar: preludio)) >> (CompilarBloqueAWasm: ast#cuerpo, remapeos)
        fijar fn a DeclrFunción#crear: id, parámetros, cuerpo#instrucciones
        devolver inicDeClosure
             >> (Compilado#deDeclaraciones: cuerpo#declaraciones)
             >> (Compilado#deDeclaraciones: (Arreglo#crearCon: fn))
             >> (Compilado#deConstantes: cuerpo#constantes)
    finsi
    si EsInstancia: ast, AST#NodoSonIguales
        variable cmp
        si ast#tipoIgualdad = AST#TipoIgualdad#IGUALES
            fijar cmp a Instrucciones: OP#CMPEQ
        sino
            fijar cmp a Instrucciones: OP#CMPNEQ
        finsi
        devolver (CompilarAWasm: ast#lhs)
              >> (CompilarAWasm: ast#rhs)
              >> cmp
    finsi
    si EsInstancia: ast, AST#NodoNo
        devolver Instrucciones: OP#NOT
    finsi
    si EsInstancia: ast, AST#NodoEscribir
        devolver (CompilarAWasm: ast#valor) >> (Instrucciones: OP#PRN)
    finsi
    si EsInstancia: ast, AST#NodoNl
        devolver Instrucciones: OP#NL
    finsi

    Inalcanzable
finfuncion

funcion ParsearYDefunc: programa
    variable ast
    fijar ast a Parser#CrearAST: programa

    variable ámbitoPrincipal
    fijar ámbitoPrincipal a RN#ResolverNombres:
        ast,
        procedimiento: nombreDelMódulo
            Inalcanzable
        finprocedimiento,
        procedimiento: ámbito finprocedimiento,
        procedimiento: ámbito finprocedimiento
    Defun#Defuncionalizar: ast
    devolver ast
finfuncion

variables ast, programa, cc
fijar programa a {

funcion Fib: N
    si N < 2
        devolver 1
    sino
        devolver (Fib: (N - 1)) + (Fib: (N - 2))
    finsi
finfuncion

escribir (Fib: 7)#comoTexto
nl

}

[{

funcion Q
    2 * 3 - 20 / 4
finfuncion

funcion W: X, Y
    funcion J: K
        funcion Ñ: L
            L - K - X
        finfuncion
        K + X + Y
    finfuncion
    X + Y
finfuncion

variables X, Y, Z
fijar X a 4
fijar Y a X * 2 - Q * 2
fijar Z a Y * Y
Z / 2
Q

}]

clase XD
    atributos esCapturado, binding, índiceDeCaptura, esLocal, altura
    metodo comoTexto
finclase

metodo XD#comoTexto
    devolver {(XD binding = ~t, índiceDeCaptura = ~t, altura = ~t, esCapturado = ~t, esLocal = ~t)}#formatear: yo#binding, yo#índiceDeCaptura, yo#altura, yo#esCapturado, yo#esLocal
finmetodo

fijar ast a ParsearYDefunc: programa
AnotaciónDeCapturas: ast
EnumeraciónDeCapturas: ast, funcion: nid Escribir: {INALC}, nid Inalcanzable finfuncion
AnotarÍndiceEnEntorno: ast, (Arreglo#crearCon: 0)
EnumeraciónDeLocalesDeProcedimiento: ast, funcion: nid
    devolver clonar XD#crear con
        esCapturado: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        binding: RN#NombreResueltoDe: nid
        índiceDeCaptura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        altura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        esLocal: (nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}) = 0
    finclonar
finfuncion
fijar cc a CompilarAWasm: ast [(RemapeosDelBloque: (LocalesDelBloque: ast), (NombresLibres: ast))]
Listado: cc
[fijar cc a CompilarAWasm: ast, Diccionario#vacío

Escribir: ({~t :: ~t :: ~t}#formatear: (TipoDe: cc), (TipoDe: cc#declaraciones), (TipoDe: cc#instrucciones))
Escribir: ({~t~%~t}#formatear: cc#declaraciones, cc#instrucciones)
Listado: cc]
[__Lua: {rt.inspectobj}, cc]
