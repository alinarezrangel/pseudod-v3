utilizar bepd/builtins
utilizar bepd/x/adhoc (ObjetoAdHoc)
utilizar bepd/datos/conjunto (Conjunto)
utilizar bepd/datos/diccionario (Diccionario)
utilizar bepd/x/puerto/conPosición (PosiciónTextual)
utilizar bepd/utilidades/texto
utilizar bepd/x/enum (Enum, EnumConValores)

utilizar tokens como Tokens
utilizar ast como AST
utilizar parser como Parser
utilizar resoluciónDeNombres como RN
utilizar defuncionalización como Defun



[DOCUMENTA
@brief{Devuelve un arreglo sin duplicados.}

Devuelve un arreglo como @pd{arr} pero sin elementos duplicados. Además, el
órden de los elementos no está especificado.
DOCUMENTA]
funcion Únicos: arr
    devolver (Conjunto#desdeArreglo: arr)#comoArreglo
finfuncion


[DOCUMENTA
@brief{Camina un AST.}

Cada nodo del AST es visitado de forma recursiva. Si @pd{filtro} (una función
de la forma @pd{filtro: nodo}) devuelve verdadero entonces la recursión es
terminada y @pd{cuerpo} es llamado con dos valores: el nodo que @pd{filtro}
seleccionó y una función @pd{cont: nodo} que "continúa" con la caminata,
visitando de nuevo (de forma recursiva) @pd{nodo}. Si @pd{filtro} devuelve
falso para un nodo, @pd{cuerpo} no es llamado, en cambio, @pd{Caminar}
automáticamente se llama a si mismo sobre los campos recursivos de ese nodo.

Todo esto básicamente hace que @pd{Caminar} sea una versión más cómoda y más
fácil de usar que @pd{CaminaNodos}.
DOCUMENTA]
funcion Caminar: nodo, filtro, cuerpo
    si %filtro: nodo
        devolver %cuerpo: nodo, funcion: cont
            devolver Caminar: cont, filtro, cuerpo
        finfuncion
    finsi

    funcion recur: nodo
        devolver Caminar: nodo, filtro, cuerpo
    finfuncion

    si EsInstancia: nodo, AST#NodoPrograma
        devolver ParaCadaElemento: nodo#instrucciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoVariable
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFijar
        recur: nodo#objetivo
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoEscribir
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoNl
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoClase
        recur: nodo#nombre
        si no EsNulo: nodo#claseBase
            recur: nodo#claseBase
        finsi
        ParaCadaElemento: nodo#extiendeClases, &recur
        ParaCadaElemento: nodo#implementaClases, &recur
        devolver ParaCadaElemento: nodo#declaraciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#parámetros, &recur
    finsi
    si EsInstancia: nodo, AST#NodoImplementa
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#definiciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineMétodoEnClase
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunción
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoNecesitas
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoDevolver
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoSi
        recur: nodo#condicional
        ParaCadaElemento: nodo#siVerdadero, &recur
        devolver ParaCadaElemento: nodo#siFalso, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMientras
        recur: nodo#condicional
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMétodo
        si no EsNulo: nodo#deClase
            recur: nodo#deClase
        finsi
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoAtributos
        recur: nodo#deClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoUtilizar
        NoImplementado
    finsi

    si EsInstancia: nodo, AST#NodoIdentificador
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoNumeroLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoTextoLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoLlamarProcedimiento
        recur: nodo#proc
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoEnviarMensaje
        recur: nodo#objeto
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoOperador
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoNoLlamar
        devolver recur: nodo#base
    finsi
    si EsInstancia: nodo, AST#NodoAutoejecutar
        recur: nodo#expr
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunciónAnónima
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoSonIguales
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoReferenciar
        devolver recur: nodo#nombre
    finsi
    si EsInstancia: nodo, AST#NodoNo
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoClonar
        recur: nodo#expresiónAClonar
        devolver ParaCadaElemento: nodo#campos, funcion: campo
            devolver recur: (campo#en: 1)
        finfuncion
    finsi

    si EsInstancia: nodo, AST#NodoVariadic
        devolver recur: nodo#interno
    finsi

    [ Nunca se llega hasta aquí. ]
    Escribir: ({Caminar no implementado para ~t}#formatear: (TipoDe: nodo))
    Inalcanzable
finfuncion


[ Este backend consiste de varios "mini-pases". Actualmente se encuentran en
  este mismo archivo, quizás deba moverlos a sus propios archivos después.

  Todos estos minipases usan la llave de anotación de capturas. ]


clase LlaveAnotaciónDeCapturas
    metodo comoTexto
finclase

metodo LlaveAnotaciónDeCapturas#comoTexto
    devolver {LLAVE_ANOTACIÓN_DE_CAPTURAS}
finmetodo

variable LLAVE_ANOTACIÓN_DE_CAPTURAS
fijar LLAVE_ANOTACIÓN_DE_CAPTURAS a LlaveAnotaciónDeCapturas#crear

[DOCUMENTA
@brief{Obtiene los nombres libres de un nodo.}

Véase el pase de defuncionalización (@pd{Defuncionalizar}).
DOCUMENTA]
funcion NombresLibres: nodo
    si EsInstancia: nodo, AST#NodoPrograma
        devolver Arreglo#vacio
    sino
        devolver nodo#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres}
    finsi
finfuncion

[DOCUMENTA
@brief{Pase de anotación de capturas.}

Anota todos los @pd{AST#NodoIdentificador} del AST con un metadato
@code{esCapturado} (con llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un
@pd{Boole} indicando si ese identificador es capturado o no por una closure.
DOCUMENTA]
procedimiento AnotaciónDeCapturas: ast
    variable nombresCapturadosAcc, nombresCapturados
    fijar nombresCapturadosAcc a Arreglo#vacio
    Caminar: ast, funcion: nodo
        variable declaraciones
        fijar declaraciones a Arreglo#crearCon:
            AST#NodoVariable, AST#NodoFunción, AST#NodoClase, AST#NodoMétodo, AST#NodoFunciónAnónima
        devolver Algún: (Mapear: declaraciones, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoFunción
            nombresCapturadosAcc#agregarAlFinal: (NombresLibres: nodo)
            ParaCadaElemento: nodo#cuerpo, procedimiento: cn
                devolver %recur: cn
            finprocedimiento
            devolver NULO
        finsi
    finprocedimiento
    fijar nombresCapturados a Reducir: Conjunto#vacío, (MétodoComoFunción: {unión}), nombresCapturadosAcc
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoIdentificador
    finfuncion, procedimiento: nodo, recur
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}, (nombresCapturados#contiene: (RN#NombreResueltoDe: nodo))
    finprocedimiento
finprocedimiento


[DOCUMENTA
@brief{Pase de enumeración de locales del procedimiento.}

Acumula las variables locales de todos los ámbitos del
AST. @pd{ámbitoContenedor} es el ámbito que contiene a @pd{ast}.

A medida que acumula las variables, va agregando el resultado de
@pd{%obtenerMetadatosAdicionales: nodoIdentificador} a los siguientes metadatos
de todos los nodos del AST que contienen un ámbito y al identificador
encontrado:

@itemlist(
@item{@pd{AST#NodoPrograma}: @code{localesDelNodo'}.}

@item{@pd{AST#NodoSi}: @code{localesSiVerdadero} y @code{localesSiFalso}.}

@item{@pd{AST#NodoMientras}: @code{localesDelNodo}.}

@item{@pd{AST#NodoPrograma} y @pd{AST#NodoFunción}: @code{localesDelProcedimiento}.}
)

Además, para los @pd{AST#NodoPrograma} y @pd{AST#NodoFunción} el metadato
@code{bindingsLocalesDelProcedimiento} será agregado con los bindings de todas
las variables locales del ámbito.

Todos los metadatos son agregados con la llave de anotación de capturas
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}.
DOCUMENTA]
procedimiento EnumeraciónDeLocalesDeProcedimiento: ast, ámbitoContenedor, obtenerMetadatosAdicionales
    necesitas (EsInstancia: ast, AST#NodoFunción) || (EsInstancia: ast, AST#NodoPrograma)
    variables locales, ámbitosLocales, nodosLocales
    fijar locales a Arreglo#vacio
    fijar ámbitosLocales a Pila#vacía
    fijar nodosLocales a Pila#vacía

    procedimiento AgregarLocal: nid
        locales#agregarAlFinal: nid
        necesitas ámbitosLocales#_elementos#longitud = nodosLocales#_elementos#longitud
        ParaCadaElemento: nodosLocales#_elementos, procedimiento: agregador
            devolver %agregador: nid
        finprocedimiento
    finprocedimiento

    procedimiento CreaAgregador: nodo, metadato
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato, Arreglo#vacio
        devolver procedimiento: nid
            (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato)#agregarAlFinal: (%obtenerMetadatosAdicionales: nid)
        finprocedimiento
    finprocedimiento

    ámbitosLocales#apilar: ámbitoContenedor
    nodosLocales#apilar: (CreaAgregador: ast, {localesDelNodo'})

    Caminar: ast, funcion: nodo
        devolver (EsInstancia: nodo, AST#NodoIdentificador)
              || (EsInstancia: nodo, AST#NodoFunción)
              || (EsInstancia: nodo, AST#NodoSi)
              || (EsInstancia: nodo, AST#NodoMientras)
    finfuncion, procedimiento: nodo, recur
        si (Defun#SonElMismoObjeto: nodo, ast) && (EsInstancia: nodo, AST#NodoFunción)
            ParaCadaElemento: nodo#parámetros, &(locales#agregarAlFinal)
            ParaCadaElemento: nodo#cuerpo, recur
            devolver NULO
        finsi
        si (no Defun#SonElMismoObjeto: nodo, ast) && (EsInstancia: nodo, AST#NodoFunción)
            AgregarLocal: nodo#nombre
            devolver EnumeraciónDeLocalesDeProcedimiento: nodo, (RN#ObtenerNombresDefinídos: nodo), obtenerMetadatosAdicionales
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            si Defun#EsLocalEntre: ámbitoContenedor, ámbitosLocales#últimoValorApilado, nodo
                Escribir: {Nodo es local:}, nodo
                AgregarLocal: nodo
            sino
                Escribir: {Nodo NO es local:}, nodo
            finsi
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            %recur: nodo#condicional
            ámbitosLocales#apilar: (RN#ObtenerNombresDefinídos: nodo)
            nodosLocales#apilar: (CreaAgregador: nodo, {localesDelNodo})
            ParaCadaElemento: nodo#cuerpo, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            %recur: nodo#condicional
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiVerdadero})
            ParaCadaElemento: nodo#siVerdadero, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiFalso})
            ParaCadaElemento: nodo#siFalso, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}, (Conjunto#desdeArreglo: (Mapear: locales, &(RN#NombreResueltoDe)))
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}, (Mapear: locales, obtenerMetadatosAdicionales)
finprocedimiento


clase EstadoDeEnumeraciónDeCapturas
    [ asoc: Diccionario de los bindings a sus informaciones de capturas. ]
    [ acc: Número de capturas. ]
    atributos asoc, acc, estadoSuperior

    metodo estatico inicial
    metodo estatico desdeEstado: estado

    metodo marcarÍndiceCapturaEnDeclaración: nid
    metodo marcarÍndiceCapturaEnUso: nid
    metodo informaciónDeLaCaptura: nid

    metodo profundidad
finclase

metodo estatico EstadoDeEnumeraciónDeCapturas#inicial
    devolver yo#crear
finmetodo

metodo estatico EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
    devolver clonar yo#crear con
        estadoSuperior: estado
    finclonar
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#inicializar
    fijar yo#asoc a Diccionario#vacío
    fijar yo#acc a 0
    fijar yo#estadoSuperior a NULO
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnDeclaración: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, 0
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, yo#acc
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, yo#profundidad
    yo#asoc#fijarEn: (RN#NombreResueltoDe: nid), yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#informaciónDeLaCaptura: nid
    si yo#asoc#contiene: (RN#NombreResueltoDe: nid)
        devolver ObjetoAdHoc: {altura}, 0,
                              {índiceDeCaptura}, (yo#asoc#en: (RN#NombreResueltoDe: nid)),
                              {profundidad}, yo#profundidad
    sino
        variable dt
        fijar dt a yo#estadoSuperior#informaciónDeLaCaptura: nid
        devolver clonar dt con
            altura: dt#altura + 1
        finclonar
    finsi
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnUso: nid
    variable dt
    fijar dt a yo#informaciónDeLaCaptura: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, dt#altura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, dt#índiceDeCaptura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, dt#profundidad
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#profundidad
    si EsNulo: yo#estadoSuperior
        devolver 0
    sino
        devolver 1 + yo#estadoSuperior#profundidad
    finsi
finmetodo

[DOCUMENTA
@brief{Anota los identificadores del programa con su información de captura.}

Cada identificador es anotado con los metadatos @code{altura},
@code{profundidad} e @code{índiceDeCaptura} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}).

@code{altura} es el número de entornos que se debe "saltar".

@code{índiceDeCaptura} es el índice dentro del entorno seleccionado. Asume que
cada ámbito es compilado a un entorno en el IR.

@code{profundidad} es un número que indica la profundidad dentro del programa
en la que se declaró la variable
DOCUMENTA]
procedimiento EnumeraciónDeCapturas: ast, estado
    variable DECLARACIONES
    fijar DECLARACIONES a Arreglo#crearCon: AST#NodoVariable, AST#NodoFunción, AST#NodoIdentificador, AST#NodoSi, AST#NodoMientras, AST#NodoPrograma

    Caminar: ast, funcion: nodo
        devolver Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoPrograma
            ParaCadaElemento: nodo#instrucciones, recur
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, estado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoVariable
            ParaCadaElemento: nodo#nombres, &(estado#marcarÍndiceCapturaEnDeclaración)
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            variable subestado
            estado#marcarÍndiceCapturaEnDeclaración: nodo#nombre
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#parámetros, &(subestado#marcarÍndiceCapturaEnDeclaración)
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            variable subestado
            %recur: nodo#condicional
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestado#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            variables subestadoSiVerdadero, subestadoSiFalso
            %recur: nodo#condicional
            fijar subestadoSiVerdadero a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siVerdadero, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestadoSiVerdadero
            finprocedimiento
            fijar subestadoSiFalso a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siFalso, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestadoSiFalso
            finprocedimiento
            necesitas subestadoSiVerdadero#profundidad = subestadoSiFalso#profundidad
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}, subestadoSiFalso#profundidad
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            estado#marcarÍndiceCapturaEnUso: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Anota los bindings locales de un ámbito.}

Agrega a cada nodo identificador un metadato @code{esLocal} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un @pd{Boole} indicando si el
identificador es "local" a su posición: es decir, si fue declarado en la
función en la que se encuentra.
DOCUMENTA]
procedimiento AnotarBindingsLocales: ast
    necesitas (EsInstancia: ast, AST#NodoFunción) || (EsInstancia: ast, AST#NodoPrograma)
    variable bindings
    fijar bindings a BindingsLocalesDelBloque: ast
    Caminar: ast, funcion: nodo
        devolver (no Defun#SonElMismoObjeto: nodo, ast) && ((EsInstancia: nodo, AST#NodoIdentificador) || (EsInstancia: nodo, AST#NodoFunción))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoIdentificador
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}, (bindings#contiene: (RN#NombreResueltoDe: nodo))
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            nodo#nombre#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}, (bindings#contiene: (RN#NombreResueltoDe: nodo#nombre))
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento


[ Fin de los minipases. Ahora comienza el backend "real": ]


[ Nombre código del backend. Véase también la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Tupla (IR) Bootstrap}

[ El IR:

  El IR esta compuesto de 3 "partes": las instrucciones, las declaraciones y
  las constantes. Se asume que el órden de las instrucciones importa pero el de
  las constantes y las declaraciones no.

  Las instrucciones consisten de un arreglo de "tuplas": cada tupla es como un
  arreglo de tamaño mayor a 1, donde el primer elemento es la instrucción u
  opcode y los demás elementos son los argumentos. Cada opcode requiere sus
  propios argumentos con tipos específicos.

  Las constantes son un diccionario de un CID ("constant-ID") a la constante
  dada. El IR solo puede representar constantes numéricas (como instancias de
  números) y textuales (como instancias de textos).

  Las declaraciones actualmente solo incluyen la declaración de función, la
  cual consiste del ID de la función, sus parámetros y las instrucciones de su
  cuerpo.

  Estas 3 partes están agrupadas en una estructura llamada `Compilado`. La
  operación más fundamental de un compilado es secuenciar (`A >> B`) pero
  también tienen otras.

Semanticas:

  El IR tiene un número ilimitado de registros o variables locales (o solo
  "locales") por cada marco de activación de cada función. También tiene una
  pila que es compartida entre marcos de activación: cada función debe tener
  cuidado de mantener la pila en un estado apropiado (las funciones no pueden
  leer los elementos de la pila que fueron agregados antes de entrar a
  esta). Finalmente, una última pila, la pila de ámbitos, es usada para
  compilar `si`-`finsi` y `mientras`-`finmientras`. A diferencia de la pila
  general, esta segunda pila no es compartida por los marcos de activación lo
  que significa que no es importante asegurarse de que esté en un estado válido
  al final de la función.

  Todo esto hace que el IR sea bastante fácil de usar: variables e
  instrucciones pueden usar directamente los registros mientras que las
  expresiones utilizan la pila para guardar los valores intermediarios. Nota
  que la pila no es completamente dinámica: siempre está vacía entre
  instrucciones. Esto es importante porque es posible que para mayor eficiencia
  que pases posteriores del compilador "desapilen" el código eliminando la pila
  y convirtiendo todo el código a registros.

  Finalmente: exísten algunos opcodes para saltar tanto como incondicional como
  condicionalmente. Todos están intencionalmente hechos para que los únicos
  objetivos de un salto sean etiquetas. Por ejemplo, en vez de una instrucción
  "salta si es falso" `BR <etiqueta>` hay una "salta de acuerdo a una
  condición" `CHOOSE <siVerdadero>, <siFalso>`. Gracias a esto es posible
  convertir el IR a un grafo de bloques básicos y todos los bloques con bordes
  entrantes comenzarán con una etiqueta.

  Los tipos de objetos manejados por el IR son, en su mayoría, los mismos que
  los builtins de PseudoD: números, textos y booleanos. Además, 2 tipos
  adicionales (objetos y closures) son utilizados para implementar los
  demás. Tal como el intérprete, todos los objetos en la VM son "reales":
  puedes enviar mensajes a números o closures sin problemas.

  Las closures están implementadas como un puntero a una función y un
  entorno. Los objetos son como funciones pero su puntero a función apunta a la
  función que recibirá los mensajes y su entorno contiene los atributos del
  objeto.

  Un entorno consiste de un puntero a un entorno "superior" y una lista de
  registros almacenados. Los entornos son usados para implementar closures y
  objetos. Puedes crear un entorno con las instrucciones de "marco" (*frame
  instructions*, se llaman así porque siempre aparecen al principio de las
  funciones, "reificando" los marcos de activación). Para acceder a un valor en
  un entorno necesitas una altura (el número de entornos a "saltar" desde el
  actual) y un índice (el objeto dentro del entorno seleccionado a acceder).

  Cuando se llama a una closure, su entorno es pasado como primer argumento.

  Los registros especiales `ESUP` y `EACT` representan el entorno "superior" al
  actual y el entorno actual, respectivamente. `EACT` tiene que ser
  inicializado manualmente. `ESUP` es el entorno pasado a esta función
  (recuerda, el primer argumento es especial).

  Como durante la compilación cada ámbito pasa a ser un entorno, un sistema es
  necesario para prevenir que las variables `EACT` y `ESUP` se confundan (por
  ejemplo, si tienes un `si` dentro de un `mientras`, el `EACT` del mientras
  debe ser distínto del `EACT` del `si`). Para esto existe la pila de ámbitos:
  cada ámbito guarda sus entornos (`EACT`) en la pila de ámbitos.

Instrucciones:

  Los prefijos significan:

  1. `C`: Índice de constante de la lista de constantes.
  2. `N`: Constante numérica.
  3. `F`: Constante real.
  4. `L`: Índice de registro local.
  5. `E`: Entorno: un registro local o alguna de las variables especiales
     `EACT` o `ESUP`.
  6. `U`: Número positivo (mayor o igual a 0).
  7. `T`: Etiqueta.
  8. `P`: ID de un procedimiento.
  9. `?`: Combinado con `E` o `L` indica que el argumento puede ser el valor
     especial `NIL`.

  SUM    {a b -- c}
  SUB    {a b -- c}
  MUL    {a b -- c}
  DIV    {a b -- c}
    Operaciones aritméticas básicas. Operan en la pila.

  LT     {a b -- c}
  GT     {a b -- c}
  LE     {a b -- c}
  GE     {a b -- c}
    Menor/mayor que, mayor/menor o igual a. Operan en la pila.

  POP    {a --}
    Saca e ignora el elemento en la cima de la pila.

  LCONST Cx    {-- a}
    Carga la constante con el índice `Cx` y la empuja en la pila.

  ICONST Na    {-- a}
  FCONST Fa    {-- a}
    Empuja una constante numérica.

  LOCAL Lx
    Declara un registro local. Solo puede estár al principio de una
    lista de instrucciones.

  PARAM Lx
    Declara un parámetro. `Lx` será el registro local que contenga al parámetro
    (`Lx` es declarado automáticamente, no es necesario declararlo de nuevo con
    `LOCAL`). Solo puede estar antes que `LOCAL` en un procedimiento.

  MKCLZ Ex, Px    {-- c}
  MK0CLZ Px    {-- c}
    Crea una closure mezclando un procedimiento (`Px`) y un entorno
    (`Ex`). `MK0CLZ` es como `MKCLZ` pero utiliza un entorno vacío.

  LSET Lx    {v --}
    Saca un elemento de la pila y lo asigna a la local `Lx`.

  LGET Lx    {-- v}
    Obtiene y empuja en la pila el valor de la local `Lx`.

  LSETC Ex, Ua, Ub    {v --}
    Saca un elemento de la pila y lo asigna a la variable dada del
    entorno. `Ex` es el entorno, `Ua` es la altura de la variable y `Ub` es el
    índice de la variable.

  LGETC Ex, Ua, Ub    {-- v}
    Obtiene la variable dada del entorno y empuja su valor en la pila. `Ex` es
    el entorno, `Ua` es la altura de la variable y `Ub` es el índice de la
    variable.

  ROT Ua
    Rota los primeros `Ua` elementos en la cima de la pila. Por ejemplo si la
    pila tenía 4 elementos:

      <-----T
      A B C D

    (La flecha apunta a la base de la pila.)
    Entonces ejecutar `ROT 4` dejará la pila como:

      <-----T
      B C D A

    Esto es muy útil, por ejemplo, al compilar `obj#mensaje: 1, 2, 3`: el orden
    en el que compilan las partes de la expresión anterior es:

      <-------T
      obj 1 2 3

    Pero necesitamos `1 2 3 obj` para poder invocar el mensaje con `MSG`.

  MSG Cx, Ua, Ub
    Saca un elemento, el objeto que recibirá el mensaje. Luego le envía a este
    el mensaje indicado por la constante `Cx`. Este mensaje es llamado con `Ua`
    argumentos y se espera que devuelva `Ub` resultados.

  DYNCALL Ua, Ub
    Envía el mensaje `llamar` al objeto en la cima de la pila. Similar a `MSG`.

  RETN Ua
    Devuelve `Ua` objetos (que deben estar en la pila) del procedimiento
    actual.

  OPNFRM Ex, ?Ey, Ua    {--}
    Inicializa un entorno. El nuevo entorno es guardado en `Ex`. Si `Ey` es
    especificado será el entorno superior. `Ua` es el tamaño del entorno, es
    decir, el número de variables que contiene.

  EINIT Ex, Ua, Ly    {--}
    Inicializa una variable dentro del entorno. La variable en el índice `Ua`
    del entorno `Ex` será fijada al valor del registro `Ly`.

  CLSFRM Ex    {--}
    "Cierra" un entorno. Luego de cerrarlo, no puedes usar `EINIT` con `Ex`. En
    cambio, cualquier cambio al entorno tendrá que pasar por `LSETC`.

  NAME Tx
    Declara `Tx` como una etiqueta. `Tx` debe ser único en el procedimiento
    actual.

  CHOOSE Tx, Ty    {x --}
    Saca un elemento de la pila, si es verdadero salta a `Tx`, si no salta a
    `Ty`.

  JMP Tx    {--}
    Salta incondicionalmente a `Tx`.

  MTRUE    {x --}
    Saca un objeto de la pila y falla con un error si no es verdadero. Este
    opcode implementa la instrucción `necesitas`.

  CMPEQ    {a b -- c}
  CMPNEQ    {a b -- c}
    Compara si dos objetos de la pila son iguales/diferentes, empujando
    verdadero o falso.

  NOT    {a -- b}
    Niega el boole en la cima de la pila.

  PRN    {a --}
    Escribe el texto en la cima de la pila.

  NL    {--}
    Escribe el fin de línea.

  SPUSH EACT, ESUP
  SPOP EACT, ESUP
    Empuja/saca y reorganiza `EACT`/`ESUP` en la pila de ámbitos. Luego de
    `SPUSH EACT, ESUP`, `EACT` estará en la pila de ámbitos y `EACT`/`ESUP`
    serán "rotados", de forma que `EACT` será el entorno superior de `EACT` y
    `ESUP` será el entorno superior de `ESUP`.

    `SPOP EACT, ESUP` revierte esto, sacando y rotando de nuevo las variables.

Ejemplo:

  Equivalente (más o menos) en PseudoD:

    variable X
    funcion Y: v
        devolver (v + 4) * X
    finfuncion
    fijar X a 5
    escribir Y: 3
    nl

  En bytecode:

    Instrucciones:
      LOCAL 3
      LOCAL 4
      OPNFRM EACT, NIL, 1
      EINIT EACT, 0, 3
      CLSFRM EACT
      MKCLZ EACT, 1
      LSET 4
      ICONST 5
      LSETC EACT, 0, 0
      LGET 4
      ICONST 3
      ROT 1
      DYNCALL 1, 1
      PRN
      NL

    Procedimientos:
      PROC 1
        PARAM ESUP
        PARAM 2
        OPNFRM EACT, ESUP, 0
        CLSFRM EACT
        LGET 2
        ICONST 4
        SUM
        LGETC EACT, 1, 0
        MUL
        RETN 1
      ENDPROC

    Constantes:
      (nada)

]

[DOCUMENTA
@brief{Variable local que contiene al entorno superior.}

Es la constante @code{ESUP} del bytecode.
DOCUMENTA]
funcion LocalDelEntornoSuperior
    devolver {ESUP}
finfuncion

[DOCUMENTA
@brief{Variable local que contiene al entorno actual.}

Es la constante @code{EACT} del bytecode.
DOCUMENTA]
funcion LocalDelEntornoActual
    devolver {EACT}
finfuncion


[DOCUMENTA
@brief{Una tupla de opcode y los argumentos.}

La tupla tiene más de un elemento: el primero siempre es el opcode, mientras
que los demás son los argumentos.
DOCUMENTA]
clase Tupla
    [DOCUMENTA
    @brief{El opcode de esta tupla.}
    DOCUMENTA]
    atributo opcode

    [DOCUMENTA
    @brief{Los argumentos de esta tupla.}

    Es un arreglo.
    DOCUMENTA]
    atributo argumentos

    [DOCUMENTA
    @brief{Crea una nueva tupla.}
    DOCUMENTA]
    metodo estatico crear: op, ...args

    [DOCUMENTA
    @brief{Determina si es o no un opcode específico.}

    Devuelve @pd{VERDADERO} o @pd{FALSO} dependiendo de si el opcode de esta
    tupla es @pd{op}.
    DOCUMENTA]
    metodo es: op

    [DOCUMENTA
    @brief{Obtiene un argumento de la tupla.}

    Devuelve el argumento número @pd{n} de esta tupla, contando desde 0.
    DOCUMENTA]
    metodo en: n

    [DOCUMENTA
    @brief{Devuelve una representación textual de la tupla.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico Tupla#crear: op, ...args
    variable inst
    fijar inst a yo#_crear
    fijar inst#opcode a op
    fijar inst#argumentos a args
    devolver inst
finmetodo

metodo Tupla#es: op
    devolver yo#opcode = op
finmetodo

metodo Tupla#en: n
    devolver yo#argumentos#en: n
finmetodo

metodo Tupla#comoTexto
    devolver {(Tupla ~t ~t)}#formatear:
        yo#opcode#nombre,
        (Unir:
         (Mapear: yo#argumentos, funcion: x
              devolver x#comoTexto
          finfuncion),
         {, })
finmetodo

[DOCUMENTA
@brief{Crea una enumeración con valores incrementales.}

Como @pd{Enum} pero los valores de las enumeraciones no son su nombre si no un
número que se va incrementando de 1 en 1. Por ejemplo:

@ejemplo|{
variable X
fijar X a EnumConValoresIncrementales: {X},
    {A}, {B}, {C}, {D}
necesitas X#A#valor = 0
necesitas X#B#valor = 1
necesitas X#C#valor = 2
necesitas X#D#valor = 3
}|
DOCUMENTA]
funcion EnumConValoresIncrementales: nombre, ...valores
    variable pares
    fijar pares a Diccionario#vacío
    ParaCadaElementoConÍndice: valores, procedimiento: valor, i
        pares#fijarEn: valor, i
    finprocedimiento
    devolver EnumConValores: nombre, ...(Aplanar: pares#comoArreglo)
finfuncion

[DOCUMENTA
@brief{Todos los opcodes del bytecode.}

Esta enumeración contiene todos los opcodes del bytecode. El valor de cada
enumerado es el "código" del opcode.

Como una conveniencia, los enumerados también tienen un método @code{bytecode}
como un alias de @code{valor} (por ejemplo, @pd{Opcode#SUM#bytecode} es igual
que @pd{Opcode#SUM#valor}).
DOCUMENTA]
variable Opcode
fijar Opcode a EnumConValoresIncrementales: {Opcode},
    {SUM},     [ SUM ]
    {SUB},     [ SUB ]
    {MUL},     [ MUL ]
    {DIV},     [ DIV ]
    {LT},      [ LT ]
    {GT},      [ GT ]
    {LE},      [ LE ]
    {GE},      [ GE ]
    {POP},     [ POP ]
    {LCONST},  [ LCONST Cx ]
    {ICONST},  [ ICONST Na ]
    {FCONST},  [ FCONST Fa ]
    {LOCAL},   [ LOCAL Lx  (Solo al principio de un procedimiento) ]
    {PARAM},   [ PARAM Lx  (Solo antes que LOCAL en un procedimiento) ]
    {MKCLZ},   [ MKCLZ Ex, Px ]
    {MK0CLZ},  [ MK0CLZ Px ]
    {LSET},    [ LSET Lx ]
    {LGET},    [ LGET Lx ]
    {LSETC},   [ LSETC Ex, Ua, Ub ]
    {LGETC},   [ LGETC Ex, Ua, Ub ]
    {ROT},     [ ROT Ua ]
    {DYNCALL}, [ DYNCALL Ua, Ub ]
    {RETN},    [ RETN Ua ]
    {EINIT},   [ EINIT Lx, Ua, Ly ]
    {OPNFRM},  [ OPNFRM Ex, ?Ey, Ua ]
    {CLSFRM},  [ CLSFRM Ex ]
    {CHOOSE},  [ CHOOSE Tx, Ty ]
    {JMP},     [ JMP Tx ]
    {NAME},    [ NAME Tx ]
    {MTRUE},   [ MTRUE ]
    {CMPEQ},   [ CMPEQ ]
    {CMPNEQ},  [ CMPNEQ ]
    {NOT},     [ NOT ]
    {MSG},     [ MSG Cx, Ua, Ub ]
    {PRN},     [ PRN ]
    {NL},      [ NL ]
    {SPUSH},   [ SPUSH EACT ]
    {SPOP}     [ SPOP EACT ]

metodo Opcode#bytecode
    devolver yo#valor
finmetodo

[ El objeto `OP` es un pequeño DSL para construir tuplas. `OP#SUM: 1, 2` es lo
  mismo que `Tupla#crear: Opcode#SUM, 1, 2` ]

variable OP
si VERDADERO
    clase I
        metodo metodoNoEncontrado: mensaje, argumentos
    finclase

    metodo I#metodoNoEncontrado: mensaje, argumentos
        devolver Tupla#crear: (EnviarMensaje: Opcode, mensaje), ...argumentos
    finmetodo

    fijar OP a I#crear
finsi

[DOCUMENTA
@brief{Declaración de función o procedimiento dentro del bytecode.}
DOCUMENTA]
clase DeclrFunción
    [DOCUMENTA
    @brief{Nombre de la función.}

    Debe ser un número único en el programa.
    DOCUMENTA]
    atributo nombre

    [DOCUMENTA
    @brief{Los parámetros de la función.}

    Un arreglo de números: cada número es el ID de un registro local que será
    el parámetro en la función. Opcionalmente @pd{LocalDelEntornoSuperior}
    puede aparecer como primer elemento.
    DOCUMENTA]
    atributo parámetros

    [DOCUMENTA
    @brief{Cuerpo de la función.}

    Un arreglo de tuplas.
    DOCUMENTA]
    atributo cuerpo

    [DOCUMENTA
    @brief{Crea una nueva declaración de función.}
    DOCUMENTA]
    metodo estatico crear: nombre, parámetros, cuerpo

    [DOCUMENTA
    @brief{Devuelve una representación textual de la declaración.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico DeclrFunción#crear: nombre, parámetros, cuerpo
    devolver clonar yo#_crear con
        nombre: nombre
        parámetros: parámetros
        cuerpo: cuerpo
    finclonar
finmetodo

metodo DeclrFunción#comoTexto
    devolver {(DeclrFunción ~t con ~t es ~t)}#formatear: yo#nombre, yo#parámetros, yo#cuerpo
finmetodo

[DOCUMENTA
@brief{Una constante en el IR.}

Representa un mapeo de un ID de constante a la constante.

Aunque nada te lo prohibe, no deberías usar constantes para representar números
"pequeños" (menores a 2^32). Para estos usa el opcode @code{ICONST}.
DOCUMENTA]
clase Constante
    [DOCUMENTA
    @brief{Id de la constante.}
    DOCUMENTA]
    atributo id

    [DOCUMENTA
    @brief{Valor de la constante.}

    Solo puede ser un número o un texto.
    DOCUMENTA]
    atributo valor

    [DOCUMENTA
    @brief{Crea una nueva constante y la devuelve.}
    DOCUMENTA]
    metodo estatico crear: id, valor

    [DOCUMENTA
    @brief{Devuelve una representación textual del mapeo de la constante.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico Constante#crear: id, valor
    devolver clonar yo#_crear con
        id: id
        valor: valor
    finclonar
finmetodo

metodo Constante#comoTexto
    devolver {(Constante#crear: ~t, ~t)}#formatear: yo#id, yo#valor
finmetodo


[DOCUMENTA
@brief{Un fragmento de compilación.}

Un compilado representa un fragmento de la compilación. Contiene un arreglo de
instrucciones, una secuencia de declaraciones y una secuencia de constantes. El
orden de las declaraciones y constantes no importa, pero el de las
instrucciones sí.
DOCUMENTA]
clase Compilado
    [DOCUMENTA
    @brief{Arreglo de tuplas, que son las instrucciones de este compilado.}
    DOCUMENTA]
    atributo instrucciones

    [DOCUMENTA
    @brief{Arreglo de declaraciones.}

    Actualmente la única declaración válida es @pd{DeclrFunción}.
    DOCUMENTA]
    atributo declaraciones

    [DOCUMENTA
    @brief{Constantes de este compilado.}

    Arreglo de @pd{Constante}.
    DOCUMENTA]
    atributo constantes

    [DOCUMENTA
    @brief{Crea un compilado con los datos dados.}
    DOCUMENTA]
    metodo estatico crear: instrucciones, declaraciones, constantes

    [DOCUMENTA
    @brief{Crea un compilado sin constantes ni declaraciones.}
    DOCUMENTA]
    metodo estatico deInstrucciónes: instrucciones

    [DOCUMENTA
    @brief{Crea un compilado sin instrucciones ni constantes.}
    DOCUMENTA]
    metodo estatico deDeclaraciones: declaraciones

    [DOCUMENTA
    @brief{Crea un compilado sin instrucciones ni declaraciones.}
    DOCUMENTA]
    metodo estatico deConstantes: constantes

    [DOCUMENTA
    @brief{Secuencia dos compilados.}

    Mezcla las declaraciones y constantes de los compilados @pd{yo} y
    @pd{otro}. Además, las instrucciones de @pd{yo} son concatenadas
    @bold{antes} que las de @pd{otro}.

    El resultado de esto es un nuevo compilado cuyas instrucciones son primero
    las de @pd{yo} y después las de @pd{otro}, con todo lo demás en un orden no
    especificado.
    DOCUMENTA]
    metodo \operador_>>\: otro

    [DOCUMENTA
    @brief{Devuelve el valor de la constante con ID @pd{idDeConstante}.}
    DOCUMENTA]
    metodo valorDeConstante: idDeConstante

    [DOCUMENTA
    @brief{Devuelve una representación textual del compilado.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico Compilado#crear: i, d, c
    devolver clonar yo#_crear con
        instrucciones: i
        declaraciones: d
        constantes: c
    finclonar
finmetodo

metodo estatico Compilado#deInstrucciónes: i
    devolver Compilado#crear: i, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo estatico Compilado#deDeclaraciones: d
    devolver Compilado#crear: Arreglo#vacio, d, Arreglo#vacio
finmetodo

metodo estatico Compilado#deConstantes: c
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, c
finmetodo

metodo estatico Compilado#vacío
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo Compilado#operador_>>: otro
    devolver Compilado#crear:
        (Concatenar: yo#instrucciones, otro#instrucciones),
        (Concatenar: yo#declaraciones, otro#declaraciones),
        (Concatenar: yo#constantes, otro#constantes)
finmetodo

metodo Compilado#valorDeConstante: idDeConstante
    variable encontrados
    fijar encontrados a Filtrar: yo#constantes, funcion: const
        devolver const#id = idDeConstante
    finfuncion
    necesitas encontrados#longitud = 1
    devolver (encontrados#en: 0)#valor
finmetodo

metodo Compilado#comoTexto
    devolver {(Compilado ds = ~t, is = ~t, cs = ~t)}#formatear: yo#declaraciones, yo#instrucciones, yo#constantes
finmetodo


[DOCUMENTA
@brief{Escribe una versión "descompilada" de un compilado.}

Escribe todos los datos de un compilado de forma "bonita", como si fuese un
"assembly listing" (de allí el nombre "listado").
DOCUMENTA]
procedimiento Listado: compilado
    Escribir: {===== Constants:}
    ParaCadaElementoConÍndice: compilado#constantes, procedimiento: const, i
        Escribir: ({#~t}#formatear: i), {}, ({~t => ~t}#formatear: const#id, const#valor)
    finprocedimiento
    Escribir: {===== Code:}
    ParaCadaElementoConÍndice: compilado#instrucciones, procedimiento: tupla, i
        Escribir: ({#~t}#formatear: i), {}, ({[~t] 	~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
    finprocedimiento
    Escribir: {===== Declr:}
    ParaCadaElementoConÍndice: compilado#declaraciones, procedimiento: declr, i
        necesitas EsInstancia: declr, DeclrFunción
        Escribir: ({#~t}#formatear: i), {proc}, declr#nombre
        ParaCadaElementoConÍndice: declr#parámetros, procedimiento: p, j
            Escribir: {}, {}, ({#~t}#formatear: j), p
        finprocedimiento
        ParaCadaElementoConÍndice: declr#cuerpo, procedimiento: tupla, i
            Escribir: {}, ({#~t}#formatear: i), {}, ({[~t] 	~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
        finprocedimiento
        Escribir: {}, {end}
    finprocedimiento
finprocedimiento


[DOCUMENTA
@brief{Secuencia todos los compilados.}

@pd{partes} debe ser un arreglo de compilados que serán secuenciados con
@code{>>} en orden. Devuelve el resultado de secuenciarlos.
DOCUMENTA]
funcion UnirCompilados: partes
    devolver Reducir: Compilado#vacío, (OperadorBinario: {>>}), partes
finfuncion


[DOCUMENTA
@brief{Obtiene los nombres definídos sin parámetros de una
función/método/procedimiento.}

Devuelve el valor del metadato @code{nombresDefinídosSinParámetros} (con llave
@pd{RN#LLAVE_RESOLUCIÓN_DE_NOMBRES}).
DOCUMENTA]
funcion NombresDefinídosSinParámetros: ast
    devolver ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSinParámetros}
finfuncion

[DOCUMENTA
@brief{Obtiene los nombres resueltos de los parámetros de un
método/función/procedimiento.}

@pd{ast} debe ser un @pd{AST#NodoFunción}, @pd{AST#NodoFunciónAnónima},
@pd{AST#NodoMétodo} o @pd{AST#NodoDefineMétodoEnClase}. Devuelve un arreglo con
los nombres resueltos de los parámetros (en orden).
DOCUMENTA]
funcion NombresDeLosParámetros: ast
    devolver Mapear: ast#parámetros, &(RN#NombreResueltoDe)
finfuncion


[DOCUMENTA
@brief{Obtiene las locales del procedimiento.}

A pesar de lo que su nombre indica, solo funciona con nodos con el metadato
@code{localesDelProcedimiento} (funciones, métodos, procedimientos y
@pd{AST#NodoPrograma}).
DOCUMENTA]
funcion LocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
finfuncion

[DOCUMENTA
@brief{Obtiene los bindings locales del procedimiento.}

Solo funciona con los mismos nodos que @pd{LocalesDelBloque}.
DOCUMENTA]
funcion BindingsLocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}
finfuncion

[DOCUMENTA
@brief{Obtiene los remapeos del procedimiento/programa.}

Cada registro local del IR requiere un ID. Podría parecer que el metadato
@code{índiceDeCaptura}, que es un número que va desde 0 por cada local del
ámbito podría ser usado para esto, pero @code{índiceDeCaptura} es local por
cada ámbito del programa, mientras que nosotros estamos compilando cada
función/método/procedimiento individualmente. Para esto un diccionario (el
diccionario de remapeos) "mapea" cada binding a un ID único local.

@params(
@defparam(locales){Los locales de la función, método, procedimiento o programa
que se esta compilando. Nota que con locales me refiero a todas las variables
de todos los ámbitos excepto subfunciones (véase
@pd{EnumeraciónDeLocalesDeProcedimiento})}

@defparam(nombresLibres){El @pd{Conjunto} con los nombres libres del bloque
(véase el pase de desfuncionalización).}
)

@devuelve{El diccionario que mapea cada binding a su ID de registro local.}
DOCUMENTA]
funcion RemapeosDelBloque: locales, nombresLibres
    variable i
    fijar i a 0
    Escribir: {REMAPEOS:::}, locales
    Escribir: {###########}, nombresLibres
    devolver Diccionario#desdeArreglo: (Mapear: locales, funcion: metalocal
        variable nuevoBinding
        fijar nuevoBinding a i
        fijar i a i + 1
        devolver Arreglo#crearCon: metalocal#binding, nuevoBinding
    finfuncion)
finfuncion

variable ContadorDeEtiquetas
fijar ContadorDeEtiquetas a 0
[DOCUMENTA
@brief{Devuelve una nueva etiqueta.}

Devuelve un número único que sirve como etiqueta para las instrucciones de
control de flujo (@code{JMP} y @code{CHOOSE}).
DOCUMENTA]
procedimiento GenerarEtiqueta
    fijar ContadorDeEtiquetas a ContadorDeEtiquetas + 1
    devolver ContadorDeEtiquetas
finprocedimiento

variable ContadorDeConstantes
fijar ContadorDeConstantes a 0
[DOCUMENTA
@brief{Devuelve un nuevo ID de constante.}

Devuelve un número único que sirve como ID de constante.
DOCUMENTA]
procedimiento GenerarIdDeConstante
    fijar ContadorDeConstantes a ContadorDeConstantes + 1
    devolver ContadorDeConstantes
finprocedimiento

[ TODO: Renombra todas las funciones de compilación de "WASM" a "Tuplas". ]

[DOCUMENTA
@brief{Compila un arreglo de instrucciones a un compilado.}

@pd{instrucciones} debe ser un arreglo de
@pd{AST#NodoInstrucción}. @pd{remapeos} debe ser los remapeos de este
bloque. Esta función automaticamente se encarga de dejar la pila en un estado
apropiado cuando se encuentra a una expresión en una posición de instrucción.
DOCUMENTA]
funcion CompilarBloqueAWasm: instrucciones, remapeos
    variable res
    fijar res a Compilado#vacío
    ParaCadaElemento: instrucciones, procedimiento: instr
        fijar res a res >> (CompilarAWasm: instr, remapeos)
        si EsInstancia: instr, AST#NodoExpresion
            fijar res a res >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#POP))
        finsi
    finprocedimiento
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila un identificador.}

@pd{ast} debe ser el @pd{AST#NodoIdentificador} y @pd{remapeos} los remapeos
del bloque.

Devuelve un compilado que obtiene la variable @pd{ast} y la empuja en la pila.
DOCUMENTA]
funcion CompilarIdentificador: ast, remapeos
    variables id, esCaptura, altura, índiceDeCaptura, esLocal, res, binding
    fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    fijar esCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
    fijar esLocal a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
    fijar binding a RN#NombreResueltoDe: ast
    si esCaptura || no esLocal
        fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGETC: LocalDelEntornoActual, altura, índiceDeCaptura))
    sino
        fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGET: (remapeos#en: binding)))
    finsi
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila las declaraciones de las locales de un procedimiento.}

Devuelve un arreglo con todas las declaraciones @code{LOCAL} necesarias.

@params(
@defparam(locales){Arreglo de las variables locales (generado con
@pd{EnumeraciónDeLocalesDeProcedimiento}) del bloque.}

@defparam(parámetros){Los parámetros del método, función o procedimiento como
un arreglo de bindings. Si se esta compilando un bloque que no es uno de estos,
@pd{parámetros} debería ser un arreglo vacío. Este parámetro es necesario
porque los parámetros son locales pero no deberían estar declarados con
@code{LOCAL} si no con @code{PARAM}.}

@defparam(remapeos){Los remapeos del bloque.}
)
DOCUMENTA]
funcion CompilarLocales: locales, parámetros, remapeos
    devolver
        Mapear:
            (Únicos:
                (Mapear: (Filtrar: locales,
                                   funcion: meta
                                       devolver meta#esLocal && (no Contiene: parámetros, meta#índiceDeCaptura)
                                   finfuncion),
                         funcion: local
                             devolver remapeos#en: local#binding
                         finfuncion)),
            funcion: registro
                devolver OP#LOCAL: registro
            finfuncion
finfuncion

[DOCUMENTA
@brief{Mapea un arreglo, manteniendo solo los valores únicos de una llave
dada.}

Mapea cada elemento de @pd{arr} con @pd{func}, pero solo mantiene elementos
para los que @pd{unicos} (una función de la forma @pd{%unicos: elemento})
devuelva un valor único. Por ejemplo:

@ejemplo|{
utilizar bepd/x/adhoc (ObjetoAdHoc)

funcion Usuario: nombre, id
    devolver ObjetoAdHoc: {nombre}, nombre, {id}, id
finfuncion

variable A
fijar A a Arreglo#crearCon:
    (Usuario: {Miguel}, 1),
    (Usuario: {María}, 2),
    (Usuario: {Miguel (otra cuenta)}, 1)
necesitas (MapearÚnicos: A,
                         funcion: usuario
                             devolver usuario#id
                         finfuncion,
                         funcion: usuario
                             devolver usuario#nombre
                         finfuncion)
          =
          (Arreglo#crearCon: {Miguel}, {María})
}|

DOCUMENTA]
funcion MapearÚnicos: arr, unicos, func
    variables res, llaves
    fijar res a Arreglo#vacio
    fijar llaves a Conjunto#vacío
    ParaCadaElemento: arr, procedimiento: el
        variable llave
        fijar llave a %unicos: el
        si no (llaves#contiene: llave)
            fijar llaves a llaves#unión: (Conjunto#conValores: llave)
            res#agregarAlFinal: (%func: el)
        finsi
    finprocedimiento
    devolver res
finfuncion

[DOCUMENTA
@brief{Compila las instrucciones @code{OPNFRM}...@code{CLSFRM} de un bloque.}

Devuelve un arreglo de instrucciones que crea e inicializa el entorno del
bloque actual, asignándolo a @code{EACT} apropiadamente.

@params(
@defparam(capturas){Un arreglo con las variables locales (producidas por
@pd{EnumeraciónDeLocalesDeProcedimiento}) que son capturadas (su atributo
@code{#esCapturado} debe ser verdadero). Puedes obtener este arreglo con
@pd{VariablesLocalesCapturadas}.}

@defparam(exísteMarcoSuperior){@pd{Boole} que indica si exíste
@code{ESUP}. Determina si el entorno tendrá marco superior.}

@defparam(remapeos){Los remapeos del bloque.}
)
DOCUMENTA]
funcion CompilarEntornoDelÁmbito: capturas, exísteMarcoSuperior, remapeos, profundidad
    variables ops, máximoÍndiceDeLocalCapturado
    fijar ops a Arreglo#vacio
    fijar máximoÍndiceDeLocalCapturado a Reducir: -1, &Max, (Mapear: capturas, (MétodoComoFunción: {índiceDeCaptura}))
    [ máximoÍndiceDeLocalCapturado es el máximo ind. de los locales capturados,
      o -1 si no hay ninguno. De esta forma, máximoÍndiceDeLocalCapturado + 1
      es el tamaño mínimo necesario para el marco de activación ("marco de
      llamada" o "call-frame") ]
    ops#agregarAlFinal: (OP#OPNFRM: LocalDelEntornoActual, (exísteMarcoSuperior#escojer: LocalDelEntornoSuperior, {NIL}), (máximoÍndiceDeLocalCapturado + 1))
    ops#agregarAlFinal: (MapearÚnicos: (Filtrar: capturas, funcion: c devolver c#profundidad = profundidad finfuncion), funcion: captura
        devolver captura#binding
    finfuncion, funcion: captura
        Escribir: {->}, captura, (remapeos#en: captura#binding)
        devolver OP#EINIT: LocalDelEntornoActual, captura#índiceDeCaptura, (remapeos#en: captura#binding)
    finfuncion)
    ops#agregarAlFinal: (OP#CLSFRM: LocalDelEntornoActual)
    devolver ops
finfuncion

[DOCUMENTA
@brief{Filtra un arreglo de locales para obtener las capturas de un bloque.}

Devuelve un arreglo con las variables locales capturadas.
DOCUMENTA]
funcion VariablesLocalesCapturadas: locales
    devolver Únicos: (Filtrar: locales, funcion: metalocal
        devolver metalocal#esCapturado
    finfuncion)
finfuncion

[DOCUMENTA
@brief{Compila los locales y el entorno de un bloque.}

Llama a @pd{CompilarLocales} y @pd{CompilarEntornoDelÁmbito}, acumulando sus
resultados. Devuelve un arreglo de instrucciones que sirve como "inicio" o
"preludio" de un bloque.
DOCUMENTA]
funcion CompilarLocalesYClosure: locales, capturas, parámetros, exísteMarcoSuperior, remapeos, profundidad
    devolver Concatenar:
        (CompilarLocales: locales, parámetros, remapeos),
        (CompilarEntornoDelÁmbito: capturas, exísteMarcoSuperior, remapeos, profundidad)
finfuncion

funcion Inspeccionar: A, B
    Escribir: A, B
    devolver B
finfuncion

[DOCUMENTA
@brief{Compila una instrucción o expresión a un compilado.}

Devuelve un @pd{Compilado} con el resultado de compilar @pd{ast}. Si @pd{ast}
es un @pd{AST#NodoExpresion} entonces el compilado dejará en la pila el
resultado de la expresión. Si es un @pd{AST#NodoInstrucción} entonces no dejará
valores en la pila.

@pd{remapeos} son los remapeos del bloque.
DOCUMENTA]
funcion CompilarAWasm: ast, remapeos
    funcion Instrucciones: ...Is
        devolver Compilado#deInstrucciónes: Is
    finfuncion

    si EsInstancia: ast, AST#NodoPrograma
        variables locales, capturas, profundidad
        fijar locales a LocalesDelBloque: ast
        fijar capturas a VariablesLocalesCapturadas: locales
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        Escribir: {locales=}, locales
        Escribir: {capturas=}, capturas
        devolver (Compilado#deInstrucciónes: (Aplanar: (CompilarLocalesYClosure: locales, capturas, Arreglo#vacio, FALSO, remapeos, profundidad)))
              >> (CompilarBloqueAWasm: ast#instrucciones, remapeos)
    finsi
    si EsInstancia: ast, AST#NodoNumeroLiteral
        devolver Instrucciones: (OP#ICONST: ast#valor)
    finsi
    si EsInstancia: ast, AST#NodoTextoLiteral
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (Instrucciones: (OP#LCONST: cid))
              >> (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, ast#valor)))
    finsi
    si EsInstancia: ast, AST#NodoOperador
        variables lhs, rhs
        fijar lhs a CompilarAWasm: ast#lhs, remapeos
        fijar rhs a CompilarAWasm: ast#rhs, remapeos
        si ast#op#op = {+}
            devolver lhs >> rhs >> (Instrucciones: OP#SUM)
        finsi
        si ast#op#op = {-}
            devolver lhs >> rhs >> (Instrucciones: OP#SUB)
        finsi
        si ast#op#op = {*}
            devolver lhs >> rhs >> (Instrucciones: OP#MUL)
        finsi
        si ast#op#op = {/}
            devolver lhs >> rhs >> (Instrucciones: OP#DIV)
        finsi
        si ast#op#op = {<}
            devolver lhs >> rhs >> (Instrucciones: OP#LT)
        finsi
        si ast#op#op = {=<}
            devolver lhs >> rhs >> (Instrucciones: OP#LE)
        finsi
        si ast#op#op = {>}
            devolver lhs >> rhs >> (Instrucciones: OP#GT)
        finsi
        si ast#op#op = {>=}
            devolver lhs >> rhs >> (Instrucciones: OP#GE)
        finsi
        variables cid, optxt
        fijar cid a GenerarIdDeConstante
        fijar optxt a {operador_}#concatenar: ast#op#op
        devolver (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, optxt)))
              >> lhs >> rhs
              >> (Instrucciones: (OP#ROT: 2),
                                 (OP#MSG: cid, 2, 1))
    finsi
    si EsInstancia: ast, AST#NodoIdentificador
        variable res
        fijar res a CompilarIdentificador: ast, remapeos
        si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
            fijar res a res >> (Instrucciones: (OP#DYNCALL: 0, 1))
        finsi
        devolver res
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        si ast#mensajes#longitud = 0
            devolver CompilarIdentificador: ast#base, remapeos
        sino
            NoImplementado
        finsi
    finsi
    si EsInstancia: ast, AST#NodoEnviarMensaje
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (CompilarAWasm: ast#objeto, remapeos)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos, remapeos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#MSG: cid, ast#argumentos#longitud, 1))
              >> (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, ast#mensaje)))
    finsi
    si EsInstancia: ast, AST#NodoLlamarProcedimiento
        devolver (CompilarIdentificador: ast#proc, remapeos)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos, remapeos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#DYNCALL: ast#argumentos#longitud, 1))
    finsi
    si EsInstancia: ast, AST#NodoAutoejecutar
        devolver (CompilarAWasm: ast#expr, remapeos)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos, remapeos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#DYNCALL: ast#argumentos#longitud, 1))
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        necesitas ast#mensajes#longitud = 0
        devolver CompilarIdentificador: ast, remapeos
    finsi
    si EsInstancia: ast, AST#NodoVariable
        devolver Compilado#vacío
    finsi
    si EsInstancia: ast, AST#NodoFijar
        variables val, altura, índiceDeCaptura, op, esCaptura, binding
        fijar altura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índiceDeCaptura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        fijar esCaptura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        fijar binding a RN#NombreResueltoDe: ast#objetivo
        si esCaptura || (altura > 0)
            fijar op a OP#LSETC: LocalDelEntornoActual, altura, índiceDeCaptura
        sino
            fijar op a OP#LSET: (remapeos#en: binding)
        finsi
        fijar val a CompilarAWasm: ast#valor, remapeos
        devolver val >> (Instrucciones: op)
    finsi
    si EsInstancia: ast, AST#NodoSi
        variables etiqSi, etiqSino, etiqFinsi, capturasSiVerdadero, capturasSiFalso, localesSiVerdadero, localesSiFalso, profundidad
        fijar etiqSi a GenerarEtiqueta
        fijar etiqSino a GenerarEtiqueta
        fijar etiqFinsi a GenerarEtiqueta

        fijar localesSiVerdadero a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiVerdadero}
        fijar capturasSiVerdadero a VariablesLocalesCapturadas: localesSiVerdadero
        fijar localesSiFalso a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiFalso}
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar capturasSiFalso a VariablesLocalesCapturadas: localesSiFalso

        devolver (CompilarAWasm: ast#condicional, remapeos)
              >> (Instrucciones: (OP#CHOOSE: etiqSi, etiqSino),
                                 (OP#NAME: etiqSi),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: capturasSiVerdadero, VERDADERO, remapeos, profundidad)))
              >> (CompilarBloqueAWasm: ast#siVerdadero, remapeos)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqFinsi),
                                 (OP#NAME: etiqSino),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: capturasSiFalso, VERDADERO, remapeos, profundidad)))
              >> (CompilarBloqueAWasm: ast#siFalso, remapeos)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#NAME: etiqFinsi))
    finsi
    si EsInstancia: ast, AST#NodoMientras
        variables etiqInicio, etiqCont, etiqFinmientras, locales, capturas, nombresLibres, profundidad
        fijar etiqInicio a GenerarEtiqueta
        fijar etiqCont a GenerarEtiqueta
        fijar etiqFinmientras a GenerarEtiqueta

        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        fijar locales a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelNodo}
        fijar capturas a VariablesLocalesCapturadas: locales

        devolver (Instrucciones: (OP#NAME: etiqInicio))
              >> (CompilarAWasm: ast#condicional, remapeos)
              >> (Instrucciones: (OP#CHOOSE: etiqCont, etiqFinmientras),
                                 (OP#NAME: etiqCont),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: capturas, VERDADERO, remapeos, profundidad)))
              >> (CompilarBloqueAWasm: ast#cuerpo, remapeos)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqInicio),
                                 (OP#NAME: etiqFinmientras))
    finsi
    si EsInstancia: ast, AST#NodoNecesitas
        devolver (CompilarAWasm: ast#expresión, remapeos) >> (Instrucciones: OP#MTRUE)
    finsi
    si EsInstancia: ast, AST#NodoDevolver
        devolver (CompilarAWasm: ast#expresión, remapeos) >> (Instrucciones: (OP#RETN: 1))
    finsi
    si EsInstancia: ast, AST#NodoFunción
        variables id, parámetros, preludio, cuerpo, fn, subremapeos, nombresLibres, inicDeClosure, locales, capturas, profundidad
        fijar id a RN#NombreResueltoDe: ast#nombre

        fijar preludio a Arreglo#vacio
        [ params ]
        fijar parámetros a Mapear: ast#parámetros, funcion: nid
            devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        finfuncion
        preludio#agregarAlFinal: (OP#PARAM: LocalDelEntornoSuperior)
        preludio#agregarAlFinal: (Mapear: parámetros, funcion: idx devolver OP#PARAM: idx finfuncion)
        [ locales ]
        fijar locales a LocalesDelBloque: ast
        fijar capturas a VariablesLocalesCapturadas: locales
        fijar profundidad a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
        Escribir: {proc locales=}, locales
        Escribir: {proc capturas=}, capturas
        fijar nombresLibres a NombresLibres: ast
        fijar subremapeos a RemapeosDelBloque: locales, nombresLibres

        fijar preludio a Concatenar: preludio, (CompilarLocalesYClosure: locales, capturas, parámetros, VERDADERO, subremapeos, profundidad)

        fijar inicDeClosure a Instrucciones: (OP#MKCLZ: LocalDelEntornoActual, id)
        si (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado})
            fijar inicDeClosure a inicDeClosure >> (Instrucciones:
                (OP#LSETC:
                    LocalDelEntornoActual,
                    (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}),
                    (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura})))
        sino
            fijar inicDeClosure a inicDeClosure >> (Instrucciones:
                (OP#LSET: (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura})))
        finsi

        fijar cuerpo a (Compilado#deInstrucciónes: (Aplanar: preludio)) >> (CompilarBloqueAWasm: ast#cuerpo, subremapeos)
        fijar fn a DeclrFunción#crear: id, parámetros, cuerpo#instrucciones
        devolver inicDeClosure
             >> (Compilado#deDeclaraciones: cuerpo#declaraciones)
             >> (Compilado#deDeclaraciones: (Arreglo#crearCon: fn))
             >> (Compilado#deConstantes: cuerpo#constantes)
    finsi
    si EsInstancia: ast, AST#NodoSonIguales
        variable cmp
        si ast#tipoIgualdad = AST#TipoIgualdad#IGUALES
            fijar cmp a Instrucciones: OP#CMPEQ
        sino
            fijar cmp a Instrucciones: OP#CMPNEQ
        finsi
        devolver (CompilarAWasm: ast#lhs, remapeos)
              >> (CompilarAWasm: ast#rhs, remapeos)
              >> cmp
    finsi
    si EsInstancia: ast, AST#NodoNo
        devolver Instrucciones: OP#NOT
    finsi
    si EsInstancia: ast, AST#NodoEscribir
        devolver (CompilarAWasm: ast#valor, remapeos) >> (Instrucciones: OP#PRN)
    finsi
    si EsInstancia: ast, AST#NodoNl
        devolver Instrucciones: OP#NL
    finsi

    Inalcanzable
finfuncion

[DOCUMENTA
@brief{Normaliza los IDs de las constantes de un compilado.}

El proceso de compilación puede generar muchas constantes duplicadas, esto pone
estrés en el backend que asume que las constantes son únicas. Esta función
devuelve un nuevo @pd{Compilado} que es como @pd{compilado}, pero no solo no
tiene constantes duplicadas, si no que también tiene "parches" que arreglan
todas las referencias ya existentes a constantes. El resultado es un compilado
que es semánticamente identico al original pero con menos constantes.
DOCUMENTA]
funcion NormalizaLosIdsDeConstantes: compilado
    variable constantes
    fijar constantes a Diccionario#vacío

    procedimiento normalizarInstrucciones: instrs
        devolver Mapear: instrs, procedimiento: tupla
            si (tupla#es: Opcode#LCONST) || (tupla#es: Opcode#MSG)
                [ Tanto LCONST como MSG tienen su CID en el primer argumento. ]
                variables cid, cv, clon
                fijar cid a tupla#en: 0
                fijar cv a compilado#valorDeConstante: cid
                fijar clon a clonar tupla con finclonar
                clon#argumentos#fijarEn: 0, cid [ <= parchea el CID ]
                si no (constantes#contiene: cv)
                    constantes#fijarEn: cv, cid
                finsi
                devolver clon
            sino
                [ Ningun otro opcode tiene un CID. ]
                devolver tupla
            finsi
        finprocedimiento
    finprocedimiento

    variables nuevasInstrs, nuevasConstantes, nuevasDeclrs
    fijar nuevasInstrs a normalizarInstrucciones: compilado#instrucciones
    fijar nuevasDeclrs a Mapear: compilado#declaraciones, funcion: declr
        devolver clonar declr con
            cuerpo: normalizarInstrucciones: declr#cuerpo
        finclonar
    finfuncion
    fijar nuevasConstantes a Arreglo#vacio
    constantes#paraCadaPar: procedimiento: constv, cid
        nuevasConstantes#agregarAlFinal: (Constante#crear: cid, constv)
    finprocedimiento
    devolver Compilado#crear: nuevasInstrs, nuevasDeclrs, nuevasConstantes
finfuncion

funcion ParsearYDefunc: programa
    variable ast
    fijar ast a Parser#CrearAST: programa

    variable ámbitoPrincipal
    fijar ámbitoPrincipal a RN#ResolverNombres:
        ast,
        procedimiento: nombreDelMódulo
            Inalcanzable
        finprocedimiento,
        procedimiento: ámbito finprocedimiento,
        procedimiento: ámbito finprocedimiento
    Defun#Defuncionalizar: ast
    devolver ast
finfuncion

variables ast, programa, cc
fijar programa a {

variables i, A, B
fijar i a 0
mientras i < 2
    variable j
    fijar i a i + 1
    fijar j a i * 5

    funcion EscribirIJ
        si 1 = 1
            variable W
            fijar W a i / j
            escribir W
            nl

            funcion CapturaW
                W
            finfuncion
        finsi
    finfuncion

    si i = 0
        fijar A a &EscribirIJ
    sino
        fijar B a &EscribirIJ
    finsi
finmientras

A#\llamar\
B#\llamar\

}

[{

funcion Q
    2 * 3 - 20 / 4
finfuncion

funcion W: X, Y
    funcion J: K
        funcion Ñ: L
            L - K - X
        finfuncion
        K + X + Y
    finfuncion
    X + Y
finfuncion

variables X, Y, Z
fijar X a 4
fijar Y a X * 2 - Q * 2
fijar Z a Y * Y
Z / 2
Q

}]

clase XD
    atributos esCapturado, binding, índiceDeCaptura, esLocal, altura, profundidad
    metodo comoTexto
finclase

metodo XD#comoTexto
    devolver {(XD binding = ~t, índiceDeCaptura = ~t, altura = ~t, profundidad = ~t, esCapturado = ~t, esLocal = ~t)}#formatear: yo#binding, yo#índiceDeCaptura, yo#altura, yo#profundidad, yo#esCapturado, yo#esLocal
finmetodo

fijar ast a ParsearYDefunc: programa
AnotaciónDeCapturas: ast
[AnotarProfundidadDeIdentificadorEnBloque: ast, 0]
EnumeraciónDeCapturas: ast, EstadoDeEnumeraciónDeCapturas#inicial
EnumeraciónDeLocalesDeProcedimiento: ast, (RN#ObtenerNombresDefinídos: ast), funcion: nid devolver NULO finfuncion
AnotarBindingsLocales: ast
EnumeraciónDeLocalesDeProcedimiento: ast, (RN#ObtenerNombresDefinídos: ast), funcion: nid
    devolver clonar XD#crear con
        esCapturado: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        binding: RN#NombreResueltoDe: nid
        índiceDeCaptura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        altura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        esLocal: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
        profundidad: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {profundidad}
    finclonar
finfuncion
fijar cc a CompilarAWasm: ast, (RemapeosDelBloque: (LocalesDelBloque: ast), (NombresLibres: ast))
Listado: (NormalizaLosIdsDeConstantes: cc)
[fijar cc a CompilarAWasm: ast, Diccionario#vacío

Escribir: ({~t :: ~t :: ~t}#formatear: (TipoDe: cc), (TipoDe: cc#declaraciones), (TipoDe: cc#instrucciones))
Escribir: ({~t~%~t}#formatear: cc#declaraciones, cc#instrucciones)
Listado: cc]
[__Lua: {rt.inspectobj}, cc]
