utilizar bepd/builtins
utilizar bepd/x/adhoc (ObjetoAdHoc)
utilizar bepd/datos/conjunto (Conjunto)
utilizar bepd/datos/diccionario (Diccionario)
utilizar bepd/x/puerto/conPosición (PosiciónTextual)
utilizar bepd/utilidades/texto
utilizar bepd/x/enum (Enum, EnumConValores)

utilizar tokens como Tokens
utilizar ast como AST
utilizar parser como Parser
utilizar resoluciónDeNombres como RN
utilizar defuncionalización como Defun



[DOCUMENTA
@brief{Devuelve un arreglo sin duplicados.}

Devuelve un arreglo como @pd{arr} pero sin elementos duplicados. Además, el
órden de los elementos no está especificado.
DOCUMENTA]
funcion Únicos: arr
    devolver (Conjunto#desdeArreglo: arr)#comoArreglo
finfuncion


[DOCUMENTA
@brief{Camina un AST.}

Cada nodo del AST es visitado de forma recursiva. Si @pd{filtro} (una función
de la forma @pd{filtro: nodo}) devuelve verdadero entonces la recursión es
terminada y @pd{cuerpo} es llamado con dos valores: el nodo que @pd{filtro}
seleccionó y una función @pd{cont: nodo} que "continúa" con la caminata,
visitando de nuevo (de forma recursiva) @pd{nodo}. Si @pd{filtro} devuelve
falso para un nodo, @pd{cuerpo} no es llamado, en cambio, @pd{Caminar}
automáticamente se llama a si mismo sobre los campos recursivos de ese nodo.

Todo esto básicamente hace que @pd{Caminar} sea una versión más cómoda y más
fácil de usar que @pd{CaminaNodos}.
DOCUMENTA]
funcion Caminar: nodo, filtro, cuerpo
    si %filtro: nodo
        devolver %cuerpo: nodo, funcion: cont
            devolver Caminar: cont, filtro, cuerpo
        finfuncion
    finsi

    funcion recur: nodo
        devolver Caminar: nodo, filtro, cuerpo
    finfuncion

    si EsInstancia: nodo, AST#NodoPrograma
        devolver ParaCadaElemento: nodo#instrucciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoVariable
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFijar
        recur: nodo#objetivo
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoEscribir
        devolver recur: nodo#valor
    finsi
    si EsInstancia: nodo, AST#NodoNl
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoClase
        recur: nodo#nombre
        si no EsNulo: nodo#claseBase
            recur: nodo#claseBase
        finsi
        ParaCadaElemento: nodo#extiendeClases, &recur
        ParaCadaElemento: nodo#implementaClases, &recur
        devolver ParaCadaElemento: nodo#declaraciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDeclaraciónDeMétodoEnClase
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#parámetros, &recur
    finsi
    si EsInstancia: nodo, AST#NodoImplementa
        recur: nodo#nombre
        devolver ParaCadaElemento: nodo#definiciones, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineAtributosEnClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoDefineMétodoEnClase
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunción
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoNecesitas
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoDevolver
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoSi
        recur: nodo#condicional
        ParaCadaElemento: nodo#siVerdadero, &recur
        devolver ParaCadaElemento: nodo#siFalso, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMientras
        recur: nodo#condicional
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoMétodo
        si no EsNulo: nodo#deClase
            recur: nodo#deClase
        finsi
        recur: nodo#nombre
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoAtributos
        recur: nodo#deClase
        devolver ParaCadaElemento: nodo#nombres, &recur
    finsi
    si EsInstancia: nodo, AST#NodoUtilizar
        NoImplementado
    finsi

    si EsInstancia: nodo, AST#NodoIdentificador
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoNumeroLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoTextoLiteral
        devolver NULO
    finsi
    si EsInstancia: nodo, AST#NodoLlamarProcedimiento
        recur: nodo#proc
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoEnviarMensaje
        recur: nodo#objeto
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoOperador
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoNoLlamar
        devolver recur: nodo#base
    finsi
    si EsInstancia: nodo, AST#NodoAutoejecutar
        recur: nodo#expr
        devolver ParaCadaElemento: nodo#argumentos, &recur
    finsi
    si EsInstancia: nodo, AST#NodoFunciónAnónima
        ParaCadaElemento: nodo#parámetros, &recur
        devolver ParaCadaElemento: nodo#cuerpo, &recur
    finsi
    si EsInstancia: nodo, AST#NodoSonIguales
        recur: nodo#lhs
        devolver recur: nodo#rhs
    finsi
    si EsInstancia: nodo, AST#NodoReferenciar
        devolver recur: nodo#nombre
    finsi
    si EsInstancia: nodo, AST#NodoNo
        devolver recur: nodo#expresión
    finsi
    si EsInstancia: nodo, AST#NodoClonar
        recur: nodo#expresiónAClonar
        devolver ParaCadaElemento: nodo#campos, funcion: campo
            devolver recur: (campo#en: 1)
        finfuncion
    finsi

    si EsInstancia: nodo, AST#NodoVariadic
        devolver recur: nodo#interno
    finsi

    [ Nunca se llega hasta aquí. ]
    Escribir: ({Caminar no implementado para ~t}#formatear: (TipoDe: nodo))
    Inalcanzable
finfuncion


[ Este backend consiste de varios "mini-pases". Actualmente se encuentran en
  este mismo archivo, quizás deba moverlos a sus propios archivos después.

  Todos estos minipases usan la llave de anotación de capturas. ]


clase LlaveAnotaciónDeCapturas
    metodo comoTexto
finclase

metodo LlaveAnotaciónDeCapturas#comoTexto
    devolver {LLAVE_ANOTACIÓN_DE_CAPTURAS}
finmetodo

variable LLAVE_ANOTACIÓN_DE_CAPTURAS
fijar LLAVE_ANOTACIÓN_DE_CAPTURAS a LlaveAnotaciónDeCapturas#crear

[DOCUMENTA
@brief{Obtiene los nombres libres de un nodo.}

Véase el pase de defuncionalización (@pd{Defuncionalizar}).
DOCUMENTA]
funcion NombresLibres: nodo
    si EsInstancia: nodo, AST#NodoPrograma
        devolver Arreglo#vacio
    sino
        devolver nodo#obtenerMetadato: Defun#LLAVE_DEFUNCIONALIZACIÓN, {nombresLibres}
    finsi
finfuncion

[DOCUMENTA
@brief{Pase de anotación de capturas.}

Anota todos los @pd{AST#NodoIdentificador} del AST con un metadato
@code{esCapturado} (con llave @pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un
@pd{Boole} indicando si ese identificador es capturado o no por una closure.
DOCUMENTA]
procedimiento AnotaciónDeCapturas: ast
    variable nombresCapturadosAcc, nombresCapturados
    fijar nombresCapturadosAcc a Arreglo#vacio
    Caminar: ast, funcion: nodo
        variable declaraciones
        fijar declaraciones a Arreglo#crearCon:
            AST#NodoVariable, AST#NodoFunción, AST#NodoClase, AST#NodoMétodo, AST#NodoFunciónAnónima
        devolver Algún: (Mapear: declaraciones, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoFunción
            nombresCapturadosAcc#agregarAlFinal: (NombresLibres: nodo)
            ParaCadaElemento: nodo#cuerpo, procedimiento: cn
                devolver %recur: cn
            finprocedimiento
            devolver NULO
        finsi
    finprocedimiento
    fijar nombresCapturados a Reducir: Conjunto#vacío, (MétodoComoFunción: {unión}), nombresCapturadosAcc
    Caminar: ast, funcion: nodo
        devolver EsInstancia: nodo, AST#NodoIdentificador
    finfuncion, procedimiento: nodo, recur
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}, (nombresCapturados#contiene: (RN#NombreResueltoDe: nodo))
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Pase de enumeración de locales del procedimiento.}

Acumula las variables locales de todos los ámbitos del
AST. @pd{ámbitoContenedor} es el ámbito que contiene a @pd{ast}.

A medida que acumula las variables, va agregando el resultado de
@pd{%obtenerMetadatosAdicionales: nodoIdentificador} a los siguientes metadatos
de todos los nodos del AST que contienen un ámbito y al identificador
encontrado:

@itemlist(
@item{@pd{AST#NodoPrograma}: @code{localesDelNodo'}.}

@item{@pd{AST#NodoSi}: @code{localesSiVerdadero} y @code{localesSiFalso}.}

@item{@pd{AST#NodoMientras}: @code{localesDelNodo}.}

@item{@pd{AST#NodoPrograma} y @pd{AST#NodoFunción}: @code{localesDelProcedimiento}.}
)

Además, para los @pd{AST#NodoPrograma} y @pd{AST#NodoFunción} el metadato
@code{bindingsLocalesDelProcedimiento} será agregado con los bindings de todas
las variables locales del ámbito.

Todos los metadatos son agregados con la llave de anotación de capturas
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}.
DOCUMENTA]
procedimiento EnumeraciónDeLocalesDeProcedimiento: ast, ámbitoContenedor, obtenerMetadatosAdicionales
    necesitas (EsInstancia: ast, AST#NodoFunción) || (EsInstancia: ast, AST#NodoPrograma)
    variables locales, ámbitosLocales, nodosLocales
    fijar locales a Arreglo#vacio
    fijar ámbitosLocales a Pila#vacía
    fijar nodosLocales a Pila#vacía

    procedimiento AgregarLocal: nid
        locales#agregarAlFinal: nid
        necesitas ámbitosLocales#_elementos#longitud = nodosLocales#_elementos#longitud
        ParaCadaElemento: nodosLocales#_elementos, procedimiento: agregador
            devolver %agregador: nid
        finprocedimiento
    finprocedimiento

    procedimiento CreaAgregador: nodo, metadato
        nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato, Arreglo#vacio
        devolver procedimiento: nid
            (nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, metadato)#agregarAlFinal: (%obtenerMetadatosAdicionales: nid)
        finprocedimiento
    finprocedimiento

    ámbitosLocales#apilar: ámbitoContenedor
    nodosLocales#apilar: (CreaAgregador: ast, {localesDelNodo'})

    Caminar: ast, funcion: nodo
        devolver (EsInstancia: nodo, AST#NodoIdentificador)
              || (EsInstancia: nodo, AST#NodoFunción)
              || (EsInstancia: nodo, AST#NodoSi)
              || (EsInstancia: nodo, AST#NodoMientras)
    finfuncion, procedimiento: nodo, recur
        si (Defun#SonElMismoObjeto: nodo, ast) && (EsInstancia: nodo, AST#NodoFunción)
            ParaCadaElemento: nodo#parámetros, &(locales#agregarAlFinal)
            ParaCadaElemento: nodo#cuerpo, recur
            devolver NULO
        finsi
        si (no Defun#SonElMismoObjeto: nodo, ast) && (EsInstancia: nodo, AST#NodoFunción)
            AgregarLocal: nodo#nombre
            devolver EnumeraciónDeLocalesDeProcedimiento: nodo, (RN#ObtenerNombresDefinídos: nodo), obtenerMetadatosAdicionales
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            si Defun#EsLocalEntre: ámbitoContenedor, ámbitosLocales#últimoValorApilado, nodo
                Escribir: {Nodo es local:}, nodo
                AgregarLocal: nodo
            sino
                Escribir: {Nodo NO es local:}, nodo
            finsi
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            %recur: nodo#condicional
            ámbitosLocales#apilar: (RN#ObtenerNombresDefinídos: nodo)
            nodosLocales#apilar: (CreaAgregador: nodo, {localesDelNodo})
            ParaCadaElemento: nodo#cuerpo, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            %recur: nodo#condicional
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiVerdadero})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiVerdadero})
            ParaCadaElemento: nodo#siVerdadero, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            ámbitosLocales#apilar: (nodo#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSiFalso})
            nodosLocales#apilar: (CreaAgregador: nodo, {localesSiFalso})
            ParaCadaElemento: nodo#siFalso, recur
            nodosLocales#desapilar
            ámbitosLocales#desapilar
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}, (Conjunto#desdeArreglo: (Mapear: locales, &(RN#NombreResueltoDe)))
    ast#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}, (Mapear: locales, obtenerMetadatosAdicionales)
finprocedimiento


clase EstadoDeEnumeraciónDeCapturas
    [ asoc: Diccionario de los bindings a sus informaciones de capturas. ]
    [ acc: Número de capturas. ]
    atributos asoc, acc, estadoSuperior

    metodo estatico inicial
    metodo estatico desdeEstado: estado

    metodo marcarÍndiceCapturaEnDeclaración: nid
    metodo marcarÍndiceCapturaEnUso: nid
    metodo informaciónDeLaCaptura: nid
finclase

metodo estatico EstadoDeEnumeraciónDeCapturas#inicial
    devolver yo#crear
finmetodo

metodo estatico EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
    devolver clonar yo#crear con
        estadoSuperior: estado
    finclonar
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#inicializar
    fijar yo#asoc a Diccionario#vacío
    fijar yo#acc a 0
    fijar yo#estadoSuperior a NULO
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnDeclaración: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, 0
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, yo#acc
    yo#asoc#fijarEn: (RN#NombreResueltoDe: nid), yo#acc
    fijar yo#acc a yo#acc + 1
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#informaciónDeLaCaptura: nid
    si yo#asoc#contiene: (RN#NombreResueltoDe: nid)
        devolver ObjetoAdHoc: {altura}, 0, {índiceDeCaptura}, (yo#asoc#en: (RN#NombreResueltoDe: nid))
    sino
        variable dt
        fijar dt a yo#estadoSuperior#informaciónDeLaCaptura: nid
        devolver clonar dt con
            altura: dt#altura + 1
        finclonar
    finsi
finmetodo

metodo EstadoDeEnumeraciónDeCapturas#marcarÍndiceCapturaEnUso: nid
    variable dt
    fijar dt a yo#informaciónDeLaCaptura: nid
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}, dt#altura
    nid#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}, dt#índiceDeCaptura
finmetodo

[DOCUMENTA
@brief{Anota los identificadores del programa con su información de captura.}

Cada identificador es anotado con los metadatos @code{altura} y
@code{índiceDeCaptura} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}). @code{altura} es el número de entornos que
se debe "saltar" e @code{índiceDeCaptura} es el índice dentro del entorno
seleccionado. Asume que cada ámbito es compilado a un entorno en el IR.
DOCUMENTA]
procedimiento EnumeraciónDeCapturas: ast, estado
    variable DECLARACIONES
    fijar DECLARACIONES a Arreglo#crearCon: AST#NodoVariable, AST#NodoFunción, AST#NodoIdentificador, AST#NodoSi, AST#NodoMientras

    Caminar: ast, funcion: nodo
        devolver Algún: (Mapear: DECLARACIONES, (Parcial: &EsInstancia, nodo))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoVariable
            ParaCadaElemento: nodo#nombres, &(estado#marcarÍndiceCapturaEnDeclaración)
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            variable subestado
            estado#marcarÍndiceCapturaEnDeclaración: nodo#nombre
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#parámetros, &(subestado#marcarÍndiceCapturaEnDeclaración)
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoMientras
            variable subestado
            %recur: nodo#condicional
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#cuerpo, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoSi
            variable subestado
            %recur: nodo#condicional
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siVerdadero, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            fijar subestado a EstadoDeEnumeraciónDeCapturas#desdeEstado: estado
            ParaCadaElemento: nodo#siFalso, procedimiento: instr
                EnumeraciónDeCapturas: instr, subestado
            finprocedimiento
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoIdentificador
            estado#marcarÍndiceCapturaEnUso: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento

[DOCUMENTA
@brief{Anota los bindings locales de un ámbito.}

Agrega a cada nodo identificador un metadato @code{esLocal} (con la llave
@pd{LLAVE_ANOTACIÓN_DE_CAPTURAS}) que es un @pd{Boole} indicando si el
identificador es "local" a su posición: es decir, si fue declarado en la
función en la que se encuentra.
DOCUMENTA]
procedimiento AnotarBindingsLocales: ast
    necesitas (EsInstancia: ast, AST#NodoFunción) || (EsInstancia: ast, AST#NodoPrograma)
    variable bindings
    fijar bindings a BindingsLocalesDelBloque: ast
    Caminar: ast, funcion: nodo
        devolver (no Defun#SonElMismoObjeto: nodo, ast) && ((EsInstancia: nodo, AST#NodoIdentificador) || (EsInstancia: nodo, AST#NodoFunción))
    finfuncion, procedimiento: nodo, recur
        si EsInstancia: nodo, AST#NodoIdentificador
            nodo#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}, (bindings#contiene: (RN#NombreResueltoDe: nodo))
            devolver NULO
        finsi
        si EsInstancia: nodo, AST#NodoFunción
            nodo#nombre#fijarMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}, (bindings#contiene: (RN#NombreResueltoDe: nodo#nombre))
            AnotarBindingsLocales: nodo
            devolver NULO
        finsi
        Inalcanzable
    finprocedimiento
finprocedimiento


[ Fin de los minipases. Ahora comienza el backend "real": ]


[ Nombre código del backend. Véase también la variable __Impl. ]
variable PSEUDOD_IMPL
fijar PSEUDOD_IMPL a {Tupla (IR) Bootstrap}


funcion LocalDelEntornoSuperior
    devolver {ESUP}
finfuncion

funcion LocalDelEntornoActual
    devolver {EACT}
finfuncion


clase Tupla
    atributos opcode, argumentos

    metodo estatico crear: op, ...args
    metodo es: op
    metodo en: n
    metodo comoTexto
finclase

metodo estatico Tupla#crear: op, ...args
    variable inst
    fijar inst a yo#_crear
    fijar inst#opcode a op
    fijar inst#argumentos a args
    devolver inst
finmetodo

metodo Tupla#es: op
    devolver yo#op = op
finmetodo

metodo Tupla#en: n
    devolver yo#argumentos#en: n
finmetodo

metodo Tupla#comoTexto
    devolver {(Tupla ~t ~t)}#formatear:
        yo#opcode#nombre,
        (Unir:
         (Mapear: yo#argumentos, funcion: x
              devolver x#comoTexto
          finfuncion),
         {, })
finmetodo

funcion EnumConValoresIncrementales: nombre, ...valores
    variable pares
    fijar pares a Diccionario#vacío
    ParaCadaElementoConÍndice: valores, procedimiento: valor, i
        pares#fijarEn: valor, i
    finprocedimiento
    devolver EnumConValores: nombre, ...(Aplanar: pares#comoArreglo)
finfuncion

variable Opcode
fijar Opcode a EnumConValoresIncrementales: {Opcode},
    {SUM},     [ SUM ]
    {SUB},     [ SUB ]
    {MUL},     [ MUL ]
    {DIV},     [ DIV ]
    {LT},      [ LT ]
    {GT},      [ GT ]
    {LE},      [ LE ]
    {GE},      [ GE ]
    {POP},     [ POP ]
    {LCONST},  [ LCONST Cx ]
    {ICONST},  [ ICONST Na ]
    {FCONST},  [ FCONST Fa ]
    {LOCAL},   [ LOCAL Lx  (Solo al principio de un procedimiento) ]
    {PARAM},   [ PARAM Lx  (Solo antes que LOCAL en un procedimiento) ]
    {MKCLZ},   [ MKCLZ Ex, Px ]
    {MK0CLZ},  [ MK0CLZ Px ]
    {LSET},    [ LSET Lx ]
    {LGET},    [ LGET Lx ]
    {LSETC},   [ LSETC Ex, Ua, Ub ]
    {LGETC},   [ LGETC Ex, Ua, Ub ]
    {ROT},     [ ROT Ua ]
    {DYNCALL}, [ DYNCALL Ua, Ub ]
    {RETN},    [ RETN Ua ]
    {EINIT},   [ EINIT Lx, Ua, Ly ]
    {OPNFRM},  [ OPNFRM Ex, ?Ey, Ly ]
    {CLSFRM},  [ CLSFRM Ex ]
    {CHOOSE},  [ CHOOSE Tx, Ty ]
    {JMP},     [ JMP Tx ]
    {NAME},    [ NAME Tx ]
    {MTRUE},   [ MTRUE ]
    {CMPEQ},   [ CMPEQ ]
    {CMPNEQ},  [ CMPNEQ ]
    {NOT},     [ NOT ]
    {MSG},     [ MSG Cx, Ua, Ub ]
    {PRN},     [ PRN ]
    {NL},      [ NL ]
    {SPUSH},   [ SPUSH EACT ]
    {SPOP}     [ SPOP EACT ]

metodo Opcode#bytecode
    devolver yo#valor
finmetodo

variable OP
si VERDADERO
    clase I
        metodo metodoNoEncontrado: mensaje, argumentos
    finclase

    metodo I#metodoNoEncontrado: mensaje, argumentos
        devolver Tupla#crear: (EnviarMensaje: Opcode, mensaje), ...argumentos
    finmetodo

    fijar OP a I#crear
finsi

clase DeclrFunción
    atributos nombre, parámetros, cuerpo
finclase

metodo estatico DeclrFunción#crear: nom, par, cuer
    devolver clonar yo#_crear con
        nombre: nom
        parámetros: par
        cuerpo: cuer
    finclonar
finmetodo

metodo DeclrFunción#comoTexto
    devolver {(DeclrFunción ~t con ~t es ~t)}#formatear: yo#nombre, yo#parámetros, yo#cuerpo
finmetodo

clase Constante
    atributos id, valor
finclase

metodo estatico Constante#crear: id, valor
    devolver clonar yo#_crear con
        id: id
        valor: valor
    finclonar
finmetodo

metodo Constante#comoTexto
    devolver {(Constante#crear: ~t, ~t)}#formatear: yo#id, yo#valor
finmetodo


clase Compilado
    atributos instrucciones, declaraciones, constantes
finclase

metodo estatico Compilado#crear: i, d, c
    devolver clonar yo#_crear con
        instrucciones: i
        declaraciones: d
        constantes: c
    finclonar
finmetodo

metodo estatico Compilado#deInstrucciónes: i
    devolver Compilado#crear: i, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo estatico Compilado#deDeclaraciones: d
    devolver Compilado#crear: Arreglo#vacio, d, Arreglo#vacio
finmetodo

metodo estatico Compilado#deConstantes: c
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, c
finmetodo

metodo estatico Compilado#vacío
    devolver Compilado#crear: Arreglo#vacio, Arreglo#vacio, Arreglo#vacio
finmetodo

metodo Compilado#operador_>>: otro
    devolver Compilado#crear:
        (Concatenar: yo#instrucciones, otro#instrucciones),
        (Concatenar: yo#declaraciones, otro#declaraciones),
        (Concatenar: yo#constantes, otro#constantes)
finmetodo

metodo Compilado#comoTexto
    devolver {(Compilado ds = ~t, is = ~t, cs = ~t)}#formatear: yo#declaraciones, yo#instrucciones, yo#constantes
finmetodo


procedimiento Listado: compilado
    Escribir: {===== Constants:}
    ParaCadaElementoConÍndice: compilado#constantes, procedimiento: const, i
        Escribir: ({#~t}#formatear: i), {}, ({~t => ~t}#formatear: const#id, const#valor)
    finprocedimiento
    Escribir: {===== Code:}
    ParaCadaElementoConÍndice: compilado#instrucciones, procedimiento: tupla, i
        Escribir: ({#~t}#formatear: i), {}, ({[~t] 	~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
    finprocedimiento
    Escribir: {===== Declr:}
    ParaCadaElementoConÍndice: compilado#declaraciones, procedimiento: declr, i
        necesitas EsInstancia: declr, DeclrFunción
        Escribir: ({#~t}#formatear: i), {proc}, declr#nombre
        ParaCadaElementoConÍndice: declr#parámetros, procedimiento: p, j
            Escribir: {}, {}, ({#~t}#formatear: j), p
        finprocedimiento
        ParaCadaElementoConÍndice: declr#cuerpo, procedimiento: tupla, i
            Escribir: {}, ({#~t}#formatear: i), {}, ({[~t] 	~t}#formatear: tupla#opcode#bytecode, tupla#opcode#nombre), ...(tupla#argumentos)
        finprocedimiento
        Escribir: {}, {end}
    finprocedimiento
finprocedimiento


funcion UnirCompilados: partes
    devolver Reducir: Compilado#vacío, (OperadorBinario: {>>}), partes
finfuncion


funcion NombresDefinídosSinParámetros: ast
    devolver ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {nombresDefinídosSinParámetros}
finfuncion

funcion NombresDeLosParámetros: ast
    devolver Mapear: ast#parámetros, &(RN#NombreResueltoDe)
finfuncion


funcion LocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelProcedimiento}
finfuncion

funcion BindingsLocalesDelBloque: nodo
    devolver nodo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {bindingsLocalesDelProcedimiento}
finfuncion

funcion RemapeosDelBloque: locales, nombresLibres
    variable i
    fijar i a 0
    devolver Diccionario#desdeArreglo: (Mapear: locales, funcion: metalocal
        variable nuevoBinding
        fijar nuevoBinding a i
        fijar i a i + 1
        devolver Arreglo#crearCon: metalocal#índiceDeCaptura, nuevoBinding
    finfuncion)
finfuncion

variable ContadorDeEtiquetas
fijar ContadorDeEtiquetas a 0
procedimiento GenerarEtiqueta
    fijar ContadorDeEtiquetas a ContadorDeEtiquetas + 1
    devolver ContadorDeEtiquetas
finprocedimiento

variable ContadorDeConstantes
fijar ContadorDeConstantes a 0
procedimiento GenerarIdDeConstante
    fijar ContadorDeConstantes a ContadorDeConstantes + 1
    devolver ContadorDeConstantes
finprocedimiento

funcion CompilarBloqueAWasm: instrucciones, remapeos
    variable res
    fijar res a Compilado#vacío
    ParaCadaElemento: instrucciones, procedimiento: instr
        fijar res a res >> (CompilarAWasm: instr, remapeos)
        si EsInstancia: instr, AST#NodoExpresion
            fijar res a res >> (Compilado#deInstrucciónes: (Arreglo#crearCon: OP#POP))
        finsi
    finprocedimiento
    devolver res
finfuncion

funcion CompilarIdentificador: ast, remapeos
    variables id, esCaptura, altura, índiceDeCaptura, esLocal, res
    fijar altura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
    fijar índiceDeCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
    fijar esCaptura a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
    fijar esLocal a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
    si esCaptura || no esLocal
        fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGETC: LocalDelEntornoActual, altura, índiceDeCaptura))
    sino
        fijar res a Compilado#deInstrucciónes: (Arreglo#crearCon: (OP#LGET: (remapeos#en: índiceDeCaptura)))
    finsi
    devolver res
finfuncion

funcion CompilarLocales: locales, parámetros, remapeos
    devolver
        Mapear:
            (Únicos:
                (Mapear: (Filtrar: locales, funcion: meta
                              devolver meta#esLocal && (no Contiene: parámetros, meta#índiceDeCaptura)
                          finfuncion),
                        (MétodoComoFunción: {índiceDeCaptura}))),
            funcion: índiceDeCaptura
                devolver OP#LOCAL: (remapeos#en: índiceDeCaptura)
            finfuncion
finfuncion

funcion CompilarEntornoDelÁmbito: capturas, exísteMarcoSuperior, remapeos
    variables ops, máximoÍndiceDeLocalCapturado
    fijar ops a Arreglo#vacio
    fijar máximoÍndiceDeLocalCapturado a Reducir: -1, &Max, (Mapear: capturas, (MétodoComoFunción: {índiceDeCaptura}))
    [ máximoÍndiceDeLocalCapturado es el máximo ind. de los locales capturados,
      o -1 si no hay ninguno. De esta forma, máximoÍndiceDeLocalCapturado + 1
      es el tamaño mínimo necesario para el marco de activación ("marco de
      llamada" o "call-frame") ]
    ops#agregarAlFinal: (OP#OPNFRM: LocalDelEntornoActual, (exísteMarcoSuperior#escojer: LocalDelEntornoSuperior, {NIL}), (máximoÍndiceDeLocalCapturado + 1))
    ops#agregarAlFinal: (Mapear: (Únicos: (Mapear: capturas, (MétodoComoFunción: {índiceDeCaptura}))), funcion: índiceDeCaptura
        devolver OP#EINIT: LocalDelEntornoActual, índiceDeCaptura, (remapeos#en: índiceDeCaptura)
    finfuncion)
    ops#agregarAlFinal: (OP#CLSFRM: LocalDelEntornoActual)
    devolver ops
finfuncion

funcion CompilarLocalesYClosure: locales, capturas, parámetros, exísteMarcoSuperior, remapeos
    devolver Concatenar:
        (CompilarLocales: locales, parámetros, remapeos),
        (CompilarEntornoDelÁmbito: capturas, exísteMarcoSuperior, remapeos)
finfuncion

funcion Inspeccionar: A, B
    Escribir: A, B
    devolver B
finfuncion

funcion CompilarAWasm: ast, remapeos
    funcion Instrucciones: ...Is
        devolver Compilado#deInstrucciónes: Is
    finfuncion

    si EsInstancia: ast, AST#NodoPrograma
        variables locales, capturas
        fijar locales a LocalesDelBloque: ast
        fijar capturas a Únicos: (Filtrar: locales, funcion: metalocal
            devolver metalocal#esCapturado || no metalocal#esLocal
        finfuncion)
        Escribir: {locales=}, locales
        Escribir: {capturas=}, capturas
        devolver (Compilado#deInstrucciónes: (Aplanar: (CompilarLocalesYClosure: locales, capturas, Arreglo#vacio, FALSO, remapeos)))
              >> (CompilarBloqueAWasm: ast#instrucciones, remapeos)
    finsi
    si EsInstancia: ast, AST#NodoNumeroLiteral
        devolver Instrucciones: (OP#ICONST: ast#valor)
    finsi
    si EsInstancia: ast, AST#NodoTextoLiteral
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (Instrucciones: (OP#LCONST: cid))
              >> (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, ast#valor)))
    finsi
    si EsInstancia: ast, AST#NodoOperador
        variables lhs, rhs
        fijar lhs a CompilarAWasm: ast#lhs, remapeos
        fijar rhs a CompilarAWasm: ast#rhs, remapeos
        si ast#op#op = {+}
            devolver lhs >> rhs >> (Instrucciones: OP#SUM)
        finsi
        si ast#op#op = {-}
            devolver lhs >> rhs >> (Instrucciones: OP#SUB)
        finsi
        si ast#op#op = {*}
            devolver lhs >> rhs >> (Instrucciones: OP#MUL)
        finsi
        si ast#op#op = {/}
            devolver lhs >> rhs >> (Instrucciones: OP#DIV)
        finsi
        si ast#op#op = {<}
            devolver lhs >> rhs >> (Instrucciones: OP#LT)
        finsi
        si ast#op#op = {=<}
            devolver lhs >> rhs >> (Instrucciones: OP#LE)
        finsi
        si ast#op#op = {>}
            devolver lhs >> rhs >> (Instrucciones: OP#GT)
        finsi
        si ast#op#op = {>=}
            devolver lhs >> rhs >> (Instrucciones: OP#GE)
        finsi
        variables cid, optxt
        fijar cid a GenerarIdDeConstante
        fijar optxt a {operador_}#concatenar: ast#op#op
        devolver (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, optxt)))
              >> lhs >> rhs
              >> (Instrucciones: (OP#ROT: 2),
                                 (OP#MSG: cid, 2, 1))
    finsi
    si EsInstancia: ast, AST#NodoIdentificador
        variable res
        fijar res a CompilarIdentificador: ast, remapeos
        si ast#obtenerMetadato: RN#LLAVE_RESOLUCIÓN_DE_NOMBRES, {esAutoejecutable}
            fijar res a res >> (Instrucciones: (OP#DYNCALL: 0, 1))
        finsi
        devolver res
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        si ast#mensajes#longitud = 0
            devolver CompilarIdentificador: ast#base, remapeos
        sino
            NoImplementado
        finsi
    finsi
    si EsInstancia: ast, AST#NodoEnviarMensaje
        variable cid
        fijar cid a GenerarIdDeConstante
        devolver (CompilarAWasm: ast#objeto, remapeos)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos, remapeos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#MSG: cid, ast#argumentos#longitud, 1))
              >> (Compilado#deConstantes: (Arreglo#crearCon: (Constante#crear: cid, ast#mensaje)))
    finsi
    si EsInstancia: ast, AST#NodoLlamarProcedimiento
        devolver (CompilarIdentificador: ast#proc, remapeos)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos, remapeos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#DYNCALL: ast#argumentos#longitud, 1))
    finsi
    si EsInstancia: ast, AST#NodoAutoejecutar
        devolver (CompilarAWasm: ast#expr, remapeos)
              >> (UnirCompilados: (Mapear: ast#argumentos, funcion: nodos
                      devolver CompilarAWasm: nodos, remapeos
                  finfuncion))
              >> (Instrucciones: (OP#ROT: ast#argumentos#longitud),
                                 (OP#DYNCALL: ast#argumentos#longitud, 1))
    finsi
    si EsInstancia: ast, AST#NodoNoLlamar
        necesitas ast#mensajes#longitud = 0
        devolver CompilarIdentificador: ast, remapeos
    finsi
    si EsInstancia: ast, AST#NodoVariable
        devolver Compilado#vacío
    finsi
    si EsInstancia: ast, AST#NodoFijar
        variables val, altura, índiceDeCaptura, op, esCaptura
        fijar altura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        fijar índiceDeCaptura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        fijar esCaptura a ast#objetivo#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        si esCaptura || (altura > 0)
            fijar op a OP#LSETC: LocalDelEntornoActual, altura, índiceDeCaptura
        sino
            fijar op a OP#LSET: (remapeos#en: índiceDeCaptura)
        finsi
        fijar val a CompilarAWasm: ast#valor, remapeos
        devolver val >> (Instrucciones: op)
    finsi
    si EsInstancia: ast, AST#NodoSi
        variables etiqSi, etiqSino, etiqFinsi, capturasSiVerdadero, capturasSiFalso, localesSiVerdadero, localesSiFalso
        fijar etiqSi a GenerarEtiqueta
        fijar etiqSino a GenerarEtiqueta
        fijar etiqFinsi a GenerarEtiqueta

        fijar localesSiVerdadero a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiVerdadero}
        fijar capturasSiVerdadero a Únicos: (Filtrar: localesSiVerdadero, funcion: metalocal
            devolver metalocal#esCapturado
        finfuncion)
        fijar localesSiFalso a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesSiFalso}
        fijar capturasSiFalso a Únicos: (Filtrar: localesSiFalso, funcion: metalocal
            devolver metalocal#esCapturado
        finfuncion)

        devolver (CompilarAWasm: ast#condicional, remapeos)
              >> (Instrucciones: (OP#CHOOSE: etiqSi, etiqSino),
                                 (OP#NAME: etiqSi),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: capturasSiVerdadero, VERDADERO, remapeos)))
              >> (CompilarBloqueAWasm: ast#siVerdadero, remapeos)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqFinsi),
                                 (OP#NAME: etiqSino),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: capturasSiFalso, VERDADERO, remapeos)))
              >> (CompilarBloqueAWasm: ast#siFalso, remapeos)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#NAME: etiqFinsi))
    finsi
    si EsInstancia: ast, AST#NodoMientras
        variables etiqInicio, etiqCont, etiqFinmientras, locales, capturas, nombresLibres
        fijar etiqInicio a GenerarEtiqueta
        fijar etiqCont a GenerarEtiqueta
        fijar etiqFinmientras a GenerarEtiqueta

        fijar locales a ast#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {localesDelNodo}
        fijar capturas a Únicos: (Filtrar: locales, funcion: metalocal
            devolver metalocal#esCapturado
        finfuncion)

        devolver (Instrucciones: (OP#NAME: etiqInicio))
              >> (CompilarAWasm: ast#condicional, remapeos)
              >> (Instrucciones: (OP#CHOOSE: etiqCont, etiqFinmientras),
                                 (OP#NAME: etiqCont),
                                 (OP#SPUSH: LocalDelEntornoActual, LocalDelEntornoSuperior))
              >> (Compilado#deInstrucciónes: (Aplanar: (CompilarEntornoDelÁmbito: capturas, VERDADERO, remapeos)))
              >> (CompilarBloqueAWasm: ast#cuerpo, remapeos)
              >> (Instrucciones: (OP#SPOP: LocalDelEntornoActual, LocalDelEntornoSuperior),
                                 (OP#JMP: etiqInicio),
                                 (OP#NAME: etiqFinmientras))
    finsi
    si EsInstancia: ast, AST#NodoNecesitas
        devolver (CompilarAWasm: ast#expresión, remapeos) >> (Instrucciones: OP#MTRUE)
    finsi
    si EsInstancia: ast, AST#NodoDevolver
        devolver (CompilarAWasm: ast#expresión, remapeos) >> (Instrucciones: (OP#RETN: 1))
    finsi
    si EsInstancia: ast, AST#NodoFunción
        variables id, parámetros, preludio, cuerpo, fn, subremapeos, nombresLibres, inicDeClosure, locales, capturas
        fijar id a RN#NombreResueltoDe: ast#nombre

        fijar preludio a Arreglo#vacio
        [ params ]
        fijar parámetros a Mapear: ast#parámetros, funcion: nid
            devolver nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        finfuncion
        preludio#agregarAlFinal: (OP#PARAM: LocalDelEntornoSuperior)
        preludio#agregarAlFinal: (Mapear: parámetros, funcion: idx devolver OP#PARAM: idx finfuncion)
        [ locales ]
        fijar locales a LocalesDelBloque: ast
        fijar capturas a Únicos: (Filtrar: locales, funcion: metalocal
            devolver metalocal#esCapturado || no metalocal#esLocal
        finfuncion)
        Escribir: {proc locales=}, locales
        Escribir: {proc capturas=}, capturas
        fijar preludio a Concatenar: preludio, (CompilarLocalesYClosure: locales, capturas, parámetros, VERDADERO, remapeos)

        fijar nombresLibres a NombresLibres: ast
        fijar subremapeos a RemapeosDelBloque: locales, nombresLibres

        fijar inicDeClosure a Instrucciones: (OP#MKCLZ: LocalDelEntornoActual, id)
        si (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado})
            fijar inicDeClosure a inicDeClosure >> (Instrucciones:
                (OP#LSETC:
                    LocalDelEntornoActual,
                    (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}),
                    (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura})))
        sino
            fijar inicDeClosure a inicDeClosure >> (Instrucciones:
                (OP#LSET: (ast#nombre#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura})))
        finsi

        fijar cuerpo a (Compilado#deInstrucciónes: (Aplanar: preludio)) >> (CompilarBloqueAWasm: ast#cuerpo, subremapeos)
        fijar fn a DeclrFunción#crear: id, parámetros, cuerpo#instrucciones
        devolver inicDeClosure
             >> (Compilado#deDeclaraciones: cuerpo#declaraciones)
             >> (Compilado#deDeclaraciones: (Arreglo#crearCon: fn))
             >> (Compilado#deConstantes: cuerpo#constantes)
    finsi
    si EsInstancia: ast, AST#NodoSonIguales
        variable cmp
        si ast#tipoIgualdad = AST#TipoIgualdad#IGUALES
            fijar cmp a Instrucciones: OP#CMPEQ
        sino
            fijar cmp a Instrucciones: OP#CMPNEQ
        finsi
        devolver (CompilarAWasm: ast#lhs, remapeos)
              >> (CompilarAWasm: ast#rhs, remapeos)
              >> cmp
    finsi
    si EsInstancia: ast, AST#NodoNo
        devolver Instrucciones: OP#NOT
    finsi
    si EsInstancia: ast, AST#NodoEscribir
        devolver (CompilarAWasm: ast#valor, remapeos) >> (Instrucciones: OP#PRN)
    finsi
    si EsInstancia: ast, AST#NodoNl
        devolver Instrucciones: OP#NL
    finsi

    Inalcanzable
finfuncion

funcion ParsearYDefunc: programa
    variable ast
    fijar ast a Parser#CrearAST: programa

    variable ámbitoPrincipal
    fijar ámbitoPrincipal a RN#ResolverNombres:
        ast,
        procedimiento: nombreDelMódulo
            Inalcanzable
        finprocedimiento,
        procedimiento: ámbito finprocedimiento,
        procedimiento: ámbito finprocedimiento
    Defun#Defuncionalizar: ast
    devolver ast
finfuncion

variables ast, programa, cc
fijar programa a {

variables i, A, B
fijar i a 0
mientras i < 2
    variable j
    fijar i a i + 1
    fijar j a i * 5

    funcion EscribirIJ
        escribir i#comoTexto
        nl
        escribir j#comoTexto
        nl
    finfuncion

    si i = 0
        fijar A a &EscribirIJ
    sino
        fijar B a &EscribirIJ
    finsi
finmientras

A#\llamar\
B#\llamar\

}

[{

funcion Q
    2 * 3 - 20 / 4
finfuncion

funcion W: X, Y
    funcion J: K
        funcion Ñ: L
            L - K - X
        finfuncion
        K + X + Y
    finfuncion
    X + Y
finfuncion

variables X, Y, Z
fijar X a 4
fijar Y a X * 2 - Q * 2
fijar Z a Y * Y
Z / 2
Q

}]

clase XD
    atributos esCapturado, binding, índiceDeCaptura, esLocal, altura
    metodo comoTexto
finclase

metodo XD#comoTexto
    devolver {(XD binding = ~t, índiceDeCaptura = ~t, altura = ~t, esCapturado = ~t, esLocal = ~t)}#formatear: yo#binding, yo#índiceDeCaptura, yo#altura, yo#esCapturado, yo#esLocal
finmetodo

fijar ast a ParsearYDefunc: programa
AnotaciónDeCapturas: ast
EnumeraciónDeCapturas: ast, EstadoDeEnumeraciónDeCapturas#inicial
EnumeraciónDeLocalesDeProcedimiento: ast, (RN#ObtenerNombresDefinídos: ast), funcion: nid devolver NULO finfuncion
AnotarBindingsLocales: ast
EnumeraciónDeLocalesDeProcedimiento: ast, (RN#ObtenerNombresDefinídos: ast), funcion: nid
    devolver clonar XD#crear con
        esCapturado: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esCapturado}
        binding: RN#NombreResueltoDe: nid
        índiceDeCaptura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {índiceDeCaptura}
        altura: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {altura}
        esLocal: nid#obtenerMetadato: LLAVE_ANOTACIÓN_DE_CAPTURAS, {esLocal}
    finclonar
finfuncion
fijar cc a CompilarAWasm: ast, (RemapeosDelBloque: (LocalesDelBloque: ast), (NombresLibres: ast))
Listado: cc
[fijar cc a CompilarAWasm: ast, Diccionario#vacío

Escribir: ({~t :: ~t :: ~t}#formatear: (TipoDe: cc), (TipoDe: cc#declaraciones), (TipoDe: cc#instrucciones))
Escribir: ({~t~%~t}#formatear: cc#declaraciones, cc#instrucciones)
Listado: cc]
[__Lua: {rt.inspectobj}, cc]
